
<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>我的手机</title>
    <style id="custom-font-style"></style>
    <style>
        /* 页面基础样式，用于将手机框居中显示 */
        body {
            background-color: #dfdfdf;
            /* 淡灰色背景 */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: sans-serif;
        }

        /* === 新增：移除移动端点击时的高亮背景 === */
        * {
            -webkit-tap-highlight-color: transparent;
        }

        /* 手机外框 */
        .phone-frame {
            width: 375px;
            /* 模拟iPhone X/11/12/13 Pro的宽度 */
            height: 700px;
            /* 模拟iPhone X/11/12/13 Pro的高度 */
            border: 6px solid #111;
            /* 手机边框颜色 */
            border-radius: 54px;
            /* 圆角边框 */
            background: #d5d4d4;
            /* 屏幕默认背景色 */
            box-shadow: 0 19px 38px rgba(0, 0, 0, 0.30), 0 15px 12px rgba(0, 0, 0, 0.22);
            position: relative;
            overflow: hidden;
            /* 隐藏超出屏幕的内容 */
        }

        /* 手机屏幕区域 */
        .screen {
            width: 100%;
            height: 100%;
            background: #fff;
            /* 如果内容超出屏幕高度，允许滚动 */
            position: absolute;
            /* 让两个页面可以重叠 */
            transition: opacity 0.3s ease-in-out;
            /* 动画效果 */
        }



        /* --- 新的淡入淡出动画控制样式 --- */

        /* 默认状态：主屏幕完全不透明，并且可以交互 */
        #home-screen {
            opacity: 1;
            pointer-events: auto;
            /* 允许鼠标点击等交互 */
            z-index: 2;
            /* 在默认状态下，主屏幕在最上层 */
        }

        /* 默认状态：设置页完全透明，并且无法交互 */
        #settings-screen {
            opacity: 0;
            pointer-events: none;
            /* 禁止鼠标点击等交互 */
            z-index: 1;
            /* 在默认状态下，设置页在下层 */
        }

        /* 当 phone-frame 拥有 .show-settings 类名时，反转上面的状态 */
        .phone-frame.show-settings #home-screen {
            opacity: 0;
            pointer-events: none;
            z-index: 1;
            /* 主屏幕沉下去 */
        }

        .phone-frame.show-settings #settings-screen {
            opacity: 1;
            pointer-events: auto;
            z-index: 2;
            /* 设置页浮上来 */
        }

        /* === 新增：音乐App的动画控制 === */
        /* 默认状态：音乐页完全透明，并且无法交互 */
        #music-screen {
            display: flex;
            flex-direction: column;
            /* 垂直排列 */
            height: 100%;
            /* 确保它占满父容器的高度 */
            overflow: hidden;
            /* 防止整个屏幕意外滚动 */
            opacity: 0;
            pointer-events: none;
            z-index: 1;
        }

        /* 当 phone-frame 拥有 .show-music 类名时 */
        .phone-frame.show-music #home-screen {
            opacity: 0;
            pointer-events: none;
            z-index: 1;
        }

        .phone-frame.show-music #music-screen {
            opacity: 1;
            pointer-events: auto;
            z-index: 2;
            /* 音乐页浮上来 */
        }

        /* 内容区域新样式 */
        .content {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            /* <<< 修改为 flex-end */
            align-items: center;
            height: 100%;
            box-sizing: border-box;
        }

        /* === 新增：顶部内容样式 === */
        .header-content {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* 时钟容器 */
        .clock {
            display: flex;
            /* 使用flex布局 */
            align-items: center;
            /* 垂直居中对齐 */
            justify-content: center;
            gap: 2px;
            /* 数字间的细微间距 */
            width: 240px;
            /* 给予足够宽度 */
        }

        /* 时钟数字的通用样式 */
        .clock span {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-size: 100px;
            font-weight: 700;
            color: #000;
            /* 根据您的新图，颜色改为了黑色 */
            line-height: 1;
            /* 修正行高防止额外空间 */
        }

        /* 冒号的特定样式，使其稳定不跳动 */
        .clock span:nth-child(2) {
            font-weight: 700;
            position: relative;
            top: -0.1em;
            /* 微调垂直位置 */
            animation: blink 1.5s infinite;
            /* 添加闪烁效果 */
        }

        @keyframes blink {
            50% {
                opacity: 0;
            }
        }



        /* 语录容器 */
        .motto-container {
            margin-top: 10px;
            margin-bottom: 30px;
        }

        /* 语录文字样式 */
        #motto {
            font-size: 16px;
            color: #8a8a8e;
            font-weight: 500;
            border: none;
            /* 移除边框 */
            padding: 5px 10px;
            /* 增加一点内边距 */
            border-radius: 5px;
            /* 轻微圆角 */
            cursor: text;
            /* 鼠标样式为文本输入 */
        }

        /* 当用户点击编辑时，提供一个清晰的轮廓 */
        #motto:focus {
            outline: 2px solid #007aff;
            /* 编辑时的蓝色外框 */
            background-color: #f0f2f5;
        }

        /* === 修改：调整整体布局 === */
        .content {
            padding: 60px 0 50px 0;
            /* 调整上下内边距 */
            display: flex;
            flex-direction: column;
            /* 核心改动：让元素之间自动分布空间，顶部贴顶，底部贴底 */
            justify-content: space-between;
            align-items: center;
            height: 100%;
            box-sizing: border-box;
        }

        /* 调整小组件的上下间距为0，因为 space-between 会自动处理 */
        .widget-placeholder {
            margin-bottom: 0;
        }

        /* ===小组件(Widget)区域样式 === */
        .widget-placeholder {
            width: 285px;
            /* 宽度与App区域一致 */
            height: 145px;
            /* 大约两行App的高度 */
            margin-bottom: 40px;
            /* 与下方App的间距 */
            background-color: #f0f2f5;
            border: 2px dashed #d1d1d6;
            /* 虚线边框 */
            border-radius: 22px;
            /* 圆角 */
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            /* 鼠标悬浮时显示手形 */
            color: #8e8e93;
            font-size: 16px;
            transition: background-color 0.3s;

            /* 用于显示上传后的图片 */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .widget-placeholder:hover {
            background-color: #e1e3e6;
        }

        /* App 图标网格布局 */
        .app-grid {
            display: grid;
            /* 创建4个等宽的列 */
            grid-template-columns: repeat(4, 1fr);
            /* 定义行与列之间的间距 */
            row-gap: 30px;
            column-gap: 15px;
            padding: 20px;
        }

        /* 单个App的容器 (图标 + 名称) */
        .app-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        /* App图标样式 */
        .app-icon {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            /* 圆角效果 */
            margin-bottom: -20px;
            /* 核心：为图标添加阴影 */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            /* 用于垂直居中图标内的元素（例如emoji或文字） */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            /* 如果用emoji当图标，可以调整大小 */
            color: white;
        }

        /* App名称样式 */
        .app-name {
            font-size: 12px;
            color: #111;
            font-weight: 500;
            /* 核心：为文字添加轻微阴影 */
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.40);
            transform: translateY(24px);
        }


        /* 新增：App图标中图片的样式 */
        .app-icon img {
            width: 100%;
            height: 100%;
            /* 让图片本身也带圆角，这样即使是直角图片也能完美显示 */
            border-radius: 15px;
            /* object-fit: cover; 属性可以防止图片因拉伸而变形 */
            object-fit: cover;
        }

        /* === 新增：设置页面的专属样式 === */
        .settings-header {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            padding-top: 45px;
            /* 为顶部的刘海留出空间 */
            border-bottom: 1px solid #e5e5e5;
            position: absolute;
            /* 改为绝对定位，使其脱离文档流 */
            top: 0;
            left: 0;
            right: 0;
            background-color: #fff;
            /* 确保有背景色 */
            flex-shrink: 0;
            /* 防止顶栏在空间不足时被压缩 */
            z-index: 10;
            /* 让顶栏在内容之上 */
            
        }

        .app-back-button {
            background: none;
            border: none;
            font-weight: bold;
            color: #007aff;
            cursor: pointer;
            padding: 0 10px;
            margin-top: 5px;
        }

        .settings-header h1 {
            font-size: 18px;
            font-weight: 400;
            color: #111;
            margin: 0;
            /* 让标题在剩余空间里居中 */
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        #save-settings-button {
            padding: 4px 10px;

            font-size: 12px;

            font-weight: 400;

            color: #007AFF;

            background-color: rgba(0, 122, 255, 0.1);

            border: none;

            border-radius: 40px;

            cursor: pointer;
            margin-left: auto;

            transition: background-color 0.2s;
        }

/* === 唯一的、修正后的 settings-content 样式 === */
.settings-content {
    /* ▼▼▼ 新增/修改 ▼▼▼ */
    padding-top: 90px;  /* 为固定的顶栏留出足够的空间 */
    padding-left: 0;
    padding-right: 0;
    padding-bottom: 20px;

    color: #333;
    display: flex;
    flex-direction: column;
    gap: 18px;
    /* 核心：强制所有子元素在水平方向上居中 */
    align-items: center;
}

        /* Add this new rule anywhere in your styles */
        .modal-body .form-group {
            width: 100%;
        }



        .form-group {
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            /* 标签和输入框之间的间距 */
        }

        .form-group label {
            font-size: 15px;
            font-weight: 500;
            color: #333;
            padding-left: 5px;
        }

        .form-input,
        .form-select {
            width: 93%;
            height: 40px;
            background-color: #e9e9eb;
            border: 1px solid #d1d1d6;
            border-radius: 12px;
            font-size: 14px;
            outline: none;
        }

        .form-select:disabled {
            background-color: #f5f5f5;
            color: #c7c7cd;
        }

        .form-button {
            padding: 6px 15px;
            font-size: 12px;
            font-weight: 400;
            color: #007AFF;
            background-color: rgba(0, 122, 255, 0.1);
            border: none;
            border-radius: 40px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .form-button:disabled {
            background-color: #8E8E93;
            cursor: not-allowed;
        }

        /* --- 滑块样式 --- */
        .form-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 3px;
            background: linear-gradient(to right, #6fa8e5 0%, #6fa8e5 var(--progress-percent, 50%), #E5E5EA var(--progress-percent, 50%), #E5E5EA 100%);
            border-radius: 2px;
            outline: none;
        }

        .form-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #FFFFFF;
            border-radius: 50%;
            border: 0.5px solid rgba(0, 0, 0, 0.04);
            box-shadow: 0px 0.5px 4px rgba(0, 0, 0, 0.12), 0px 2px 3px rgba(0, 0, 0, 0.15);
            cursor: pointer;
        }

        .form-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #FFFFFF;
            border-radius: 50%;
            border: 0.5px solid rgba(0, 0, 0, 0.04);
            box-shadow: 0px 0.5px 4px rgba(0, 0, 0, 0.12), 0px 2px 3px rgba(0, 0, 0, 0.15);
            cursor: pointer;
        }


        /* === 新增：壁纸设置控件的样式 === */
        /* 用这段代码替换掉您已有的 .wallpaper-controls 样式 */
        .wallpaper-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            /* 预览图和按钮组之间的间距 */
        }

        /* 新增：壁纸预览图样式 (尺寸调整) */
        #wallpaper-preview {
            width: 50px;
            height: 88px;
            /* 保持一个合适的手机壁纸比例 */
            border-radius: 6px;
            border: 1px solid #d1d1d6;
            background-color: #e9e9eb;
            background-size: cover;
            background-position: center;
            flex-shrink: 0;
        }

        /* 新增：两个按钮的容器样式 */
        .wallpaper-buttons {
            flex-grow: 1;
            /* 占满剩余空间 */
            display: flex;
            flex-direction: column;
            /* 让两个按钮垂直堆叠 */
            gap: 8px;
            /* 两个按钮之间的间距 */
        }

        /* 这是一个次要按钮的样式，区别于主要的蓝色按钮 */
        .form-button-secondary {
            width: 100%;
            padding: 8px;
            font-size: 14px;
            color: #007AFF;
            background-color: rgba(0, 122, 255, 0.1);
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }

        /* --- 关键修改：确保只有主屏幕有壁纸 --- */
        #home-screen {
            background-size: cover;
            background-position: center;
            background-color: transparent;
            /* 让主屏幕背景透明，以便显示壁纸 */
        }

        #settings-screen {
            background-color: #fff;
            /* 确保设置页始终是白色背景 */
        }

        /* === 新增：用于隐藏小组件的类 === */
        .widget-hidden {
            display: none !important;
        }

        /* === 新增：开关(Toggle Switch)样式 === */
        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 0px;
            bottom: 0px;
            background-color: white;
            transition: .4s;
        }

        input:checked+.slider {
            background-color: #6fa8e5;
        }

        input:focus+.slider {
            box-shadow: 0 0 1px #6fa8e5;
        }

        input:checked+.slider:before {
            transform: translateX(25px);
        }

        .slider.round {
            border-radius: 34px;
        }

        .slider.round:before {
            border-radius: 50%;
        }

        /* === 新增：响应式缩放，修复小屏幕下的显示问题 === */

        /* 这是一个媒体查询，它表示：
   “如果浏览器窗口的宽度小于或等于 420px 时...” 
*/
        @media (max-width: 420px) {
            .phone-frame {
                /* * “...就把 .phone-frame 这个元素（包括它里面的所有内容）
         * 等比例缩小到原来的 90%。”
         * 这样它就不会超出窄屏幕的边界了。
        */
                transform: scale(0.9);
            }
        }

        /* * 你还可以为更小的屏幕添加进一步的缩放规则，
 * 例如，当屏幕宽度小于 380px 时，再缩小一点。
*/
        @media (max-width: 380px) {
            .phone-frame {
                transform: scale(0.85);
            }
        }

        /* === 音乐 App 专属样式 (新版) === */

        /* 新建歌单按钮的新样式 */
        .add-playlist-button {
            display: block;
            margin: 0 auto;
            width: 100%;
            /* 按钮宽度占满容器 */
            padding: 10px;
            margin-bottom: 20px;
            /* 与下方歌单网格的间距 */
            font-size: 16px;
            font-weight: 400;
            color: #007AFF;
            background-color: rgba(0, 122, 255, 0.1);
            border: none;
            border-radius: 8px;
            /* 圆角 */
            cursor: pointer;
            text-align: center;
            /* 文字居中 */
            transition: background-color 0.2s;

        }

        .add-playlist-button:hover {
            background-color: #e1e3e6;
            /* 鼠标悬浮时颜色加深 */
        }


        /* 音乐内容区域 */
        .music-content {
            padding: 15px;
            flex-grow: 1;
            /* 关键：让这个区域占据所有剩余的垂直空间 */
            overflow-y: auto;
            /* 内容超出这个区域时，允许垂直滚动 */
        }

        /* 歌单网格布局（瀑布流） */
        .playlist-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        /* 单个歌单卡片的样式 */
        .playlist-card {
            display: flex;
            flex-direction: column;
            cursor: pointer;
            transition: transform 0.2s ease-in-out;
        }

        .playlist-card:hover {
            transform: scale(1.03);
        }

        /* 歌单封面 */
        .playlist-cover {
            width: 100%;
            padding-bottom: 100%;
            background-color: #e9e9eb;
            border-radius: 8px;
            margin-bottom: 8px;
            background-size: cover;
            /* 关键：让图片缩放以完全覆盖容器 */
            background-position: center;
            /* 辅助：让图片在容器里居中显示 */
        }

        /* 歌单名称 */
        .playlist-name {
            font-size: 14px;
            font-weight: 500;
            color: #1c1c1e;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* 歌单歌曲数量 */
        .playlist-count {
            font-size: 12px;
            color: #8a8a8e;
        }

        /* === 新增：歌单详情页的动画控制 === */
        #playlist-detail-screen {
            opacity: 0;
            pointer-events: none;
            z-index: 3;
            /* 层级比音乐主页更高 */
            background-color: #fff;
            /* 确保有白色背景 */
            display: flex;
            /* 使用 flex 布局 */
            flex-direction: column;
            /* 垂直排列 */
        }

        .phone-frame.show-playlist-detail #playlist-detail-screen {
            opacity: 1;
            pointer-events: auto;
        }

        /* 详情页顶栏样式 */
        .playlist-header {
            border-bottom: 1px solid #f0f0f0;
        }

        /* 详情页内容区 */
        .playlist-content {
            padding: 20px;
            flex-grow: 1;
            /* 占据剩余所有空间 */
            overflow-y: auto;
            /* 内容多时可以滚动 */
        }

        /* 导入按钮样式 */
        .import-button {
            display: block;
            /* 块级元素 */
            width: 120px;
            /* 固定宽度 */
            margin: 0 auto 25px auto;
            /* 水平居中，并和下方列表拉开距离 */
            padding: 8px 16px;
            font-size: 15px;
            font-weight: 500;
            color: #007AFF;
            background-color: rgba(0, 122, 255, 0.1);
            border: 1px solid #ffffff;
            border-radius: 20px;
            /* 圆角 */
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        /* 歌曲列表样式 */
        .song-list {
            list-style: none;
            /* 移除默认的圆点 */
            padding: 0;
            margin: 0;
        }

        /* 列表中的每一项 */
        .song-item {
            border-bottom: 1px solid #f0f0f0;
            padding: 12px 5px;
        }

        /* === 新增：播放按钮和歌曲列表项新布局 === */
        .song-item {
            display: flex;
            justify-content: space-between;
            /* 两端对齐 */
            align-items: center;
            /* 垂直居中 */
            border-bottom: 1px solid #f0f0f0;
            padding: 12px 5px;
        }

        .song-info {
            /* 这个新容器用来包裹歌名和歌手 */
            display: flex;
            flex-direction: column;
        }

        .play-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            width: 32px;
            /* 固定宽度 */
            height: 32px;
            /* 固定高度 */
        }

        .play-button svg {
            width: 100%;
            height: 100%;
        }

        /* === 新增：详情页顶栏右侧按钮 === */
        .header-actions {
            margin-left: auto;
            /* 关键：将按钮组推到最右边 */
            display: flex;
            gap: 10px;
            /* 按钮之间的间距 */
        }

        .header-button {
            padding: 4px 10px;
            font-size: 12px;
            font-weight: 400;
            color: #007AFF;
            background-color: rgba(0, 122, 255, 0.1);
            border: none;
            border-radius: 40px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        /* 删除按钮的特殊样式 */
        .header-button.delete {
            border-color: #ff3b30;
            color: #ff3b30;
        }

        /* === 新增：多选删除模式下的样式 === */
        .song-item .song-checkbox {
            display: none;
            /* 默认隐藏复选框 */
            margin-right: 15px;
            /* 和歌曲信息拉开距离 */
        }

        /* 当 song-list 处于删除模式时，显示复选框 */
        .song-list.delete-mode .song-checkbox {
            display: block;
        }

        /* === 新增：统一的头部文本按钮样式 === */
        .header-text-button {
            padding: 4px 10px;
            font-size: 12px;
            font-weight: 400;
            color: #007AFF;
            background-color: rgba(0, 122, 255, 0.1);
            border: none;
            border-radius: 40px;
            cursor: pointer;
            transition: background-color 0.2s;
            /* 用于在flex布局中对齐 */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header-text-button:hover {
            background-color: rgba(0, 122, 255, 0.2);
        }


        /* === 新增：世界书App的动画控制 === */
        /* 默认状态：世界书页完全透明，并且无法交互 */
        #worldbook-screen {
            opacity: 0;
            pointer-events: none;
            z-index: 1;
            /* 默认在下层 */
        }

        /* 当 phone-frame 拥有 .show-worldbook 类名时 */
        .phone-frame.show-worldbook #home-screen {
            opacity: 0;
            pointer-events: none;
            z-index: 1;
        }

        .phone-frame.show-worldbook #worldbook-screen {
            opacity: 1;
            pointer-events: auto;
            z-index: 2;
            /* 世界书页浮上来 */
        }

        /* === 新增：消息App的动画控制 === */
        /* 默认状态：消息页完全透明，并且无法交互 */
        #messages-screen {
            opacity: 0;
            pointer-events: none;
            z-index: 1;
        }

        /* 当 phone-frame 拥有 .show-messages 类名时 */
        .phone-frame.show-messages #home-screen {
            opacity: 0;
            pointer-events: none;
            z-index: 1;
        }

        .phone-frame.show-messages #messages-screen {
            opacity: 1;
            pointer-events: auto;
            z-index: 2;
            /* 消息页浮上来 */
        }

        .dynamic-island {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 999;

            /* === 核心修改在这里 === */
            width: 180px;
            height: 36px;
            padding: 0 18px;
            /* 在左右两边增加内边距，让内容和黑边有呼吸空间 */
            box-sizing: border-box;
            /* 确保 padding 不会影响最终的宽高计算 */

            background-color: #000;
            border-radius: 40px;
            color: white;
            transition: all 0.35s cubic-bezier(0.65, 0, 0.35, 1);
            opacity: 0;
            pointer-events: none;
            cursor: pointer;
        }

        .dynamic-island.active {
            opacity: 1;
            pointer-events: auto;
        }

        /* 展开状态的尺寸 */
        .dynamic-island.expanded {
            width: 336px;
            /* 展开后的宽度 */
            height: 160px;
            /* 展开后的高度 */
        }

        /* --- 收起/展开内容的切换 --- */
        .island-collapsed-content {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            opacity: 1;
            transition: opacity 0.2s ease-out;
        }

        .dynamic-island.expanded .island-collapsed-content {
            opacity: 0;
            pointer-events: none;
        }

        /* === 用下面这段新的代码替换上面的旧代码 === */

        .island-expanded-content {
            /* --- 关键修复：添加绝对定位 --- */
            position: absolute;
            top: 0;
            left: 0;

            width: 100%;
            height: 100%;
            padding: 18px;
            box-sizing: border-box;

            /* 使用 Flexbox 布局来排列内部元素 */
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            /* 垂直方向上均匀分布 */

            opacity: 0;
            transition: opacity 0.2s ease-out;
            pointer-events: none;
            /* 在隐藏时确保无法交互 */
        }

        .dynamic-island.expanded .island-expanded-content {
            opacity: 1;
            pointer-events: auto;
            transition: opacity 0.3s 0.15s ease-in;
        }


        /* --- 内部元素样式 --- */
        /* === 用下面这段新的代码替换上面的旧代码 === */

        /* 使用 .dynamic-island 来提高优先级，确保样式只应用在灵动岛内部 */
        .dynamic-island .song-details .song-title {
            font-size: 18px;
            font-weight: bold;
            color: #FFFFFF;
            /* 强制指定为白色 */
        }

        .dynamic-island .song-details .song-artist {
            font-size: 14px;
            color: #b2b2b2;
            /* 一个更亮的灰色，在黑背景上更清晰 */
        }

        .progress-container {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #aaa;
        }

        .progress-bar-wrapper {
            flex-grow: 1;
            height: 6px;
            background-color: #333;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-bar-fill {
            width: 0%;
            height: 100%;
            background-color: #fff;
            border-radius: 3px;
        }

        .controls-container {
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        .control-button {
            background: none;
            border: none;
            width: 40px;
            height: 40px;
            cursor: pointer;
        }

        .control-button svg {
            fill: #fff;
            width: 100%;
            height: 100%;
        }

        .control-button.play-pause {
            width: 50px;
            height: 50px;
        }

        .play-icon,
        .pause-icon {
            display: none;
        }

        .control-button.play .play-icon,
        .control-button.pause .pause-icon {
            display: block;
        }

        /* 强制提升控制按钮容器的层级 */
        .dynamic-island .controls-container {
            position: relative;
            /* z-index 生效需要 position 属性 */
            z-index: 10;
        }

        /* === 新增：联系人弹出层 (Modal) 的所有样式 === */

        /* 1. 遮罩背景 */
        .modal-overlay {
            position: absolute;
            /* 相对于 .phone-frame 定位 */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            /* 半透明黑色背景 */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            /* 确保在最顶层 */
            opacity: 0;
            /* 默认透明 */
            transition: opacity 0.3s ease;
            /* 淡入淡出动画 */
        }

        /* 2. 对话框主体 */
        .modal-content {
            background-color: #f7f7f7;
            padding: 20px;
            border-radius: 18px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.2);
            width: 270px;
            max-width: 340px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            /* 内部元素的间距 */
            transform: scale(0.95);
            /* 默认稍微缩小 */
            transition: transform 0.3s ease;
            /* 缩放动画 */
        }

        /* 当 .modal-overlay 显示时，让 .modal-content 动画出现 */
        .modal-overlay.visible .modal-content {
            transform: scale(1);
        }


        /* 3. 顶部滑块和关闭按钮 */
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .role-switcher {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
        }

        .switch-label {
            color: #888;
            transition: color 0.3s;
        }

        .switch-label.active {
            color: #007AFF;
        }

        .modal-close-button {
            background: none;
            border: none;
            font-size: 28px;
            color: #aaa;
            cursor: pointer;
            line-height: 1;
        }

        /* 4. AI 和用户表单的样式 */
        .role-form {
            display: none;
            /* 默认隐藏 */
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .role-form.active {
            display: flex;
            /* .active 类使其显示 */
        }

        .avatar-uploader {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .avatar-preview {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            /* 圆形头像 */
            object-fit: cover;
            border: 2px solid #e0e0e0;
        }

        .avatar-input {
            display: none;
            /* 隐藏原始的文件选择框 */
        }

        .avatar-upload-label {
            font-size: 12px;
            color: #007AFF;
            cursor: pointer;
        }

        .form-textarea {
            width: 95%;
            height: 100px;
            background-color: #e9e9eb;
            border: 1px solid #d1d1d6;
            border-radius: 12px;
            font-size: 14px;
            padding: 10px;
            box-sizing: border-box;
            resize: vertical;
            /* 允许用户垂直调整大小 */
        }

        /* 5. 底部公共部分 */
        .modal-footer {
            display: flex;
            flex-direction: column;
            gap: 10px;
            border-top: 1px solid #e5e5e5;
            padding-top: 15px;
        }

        .form-group-inline {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }

        .form-group-inline input {
            width: 60px;
            text-align: center;
        }

        .save-button {
            width: 50%;
            padding: 12px;
            font-size: 16px;
            font-weight: 500;
            color: #fff;
            background-color: #007AFF;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            margin-left: auto;
            margin-right: auto;
        }

        /* === 新增：消息列表的样式 === */
        .contact-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .contact-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
        }

        .contact-item:hover {
            background-color: #f9f9f9;
        }

        .contact-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 15px;
        }

        .contact-info {
            flex-grow: 1;
            min-width: 0;
        }

        .contact-name {
            font-size: 16px;
            font-weight: 500;
            color: #111;
        }

        .contact-last-message {
            font-size: 14px;
            color: #888;
            margin-top: 4px;
            /* 防止文字过长换行 */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* === 新增：消息列表多选删除模式的样式 === */

        /* 1. 默认隐藏列表项中的复选框 */
        .contact-item .contact-checkbox {
            display: none;
            margin-right: 15px;
            /* 和头像拉开距离 */
        }

        /* 2. 当列表进入删除模式时，显示复选框 */
        .contact-list.delete-mode .contact-item .contact-checkbox {
            display: block;
            /* block 会让它显示出来 */
        }

        /* 3. 删除模式下，列表项内边距微调，给复选框留出空间 */
        .contact-list.delete-mode .contact-item {
            padding-left: 10px;
        }

        /* 4. 删除按钮的特殊红色样式 (复用音乐App的样式) */
        .header-button.delete {
            color: #ff3b30;
            /* 红色文字 */
        }

        /* === 新增：聊天界面的所有样式 === */

        /* 1. 聊天界面整体和滑入动画 */
        #chat-screen {
            /* 初始状态：透明且略微放大 */
            opacity: 0;
            transform: scale(1.05);
            pointer-events: none;
            /* 隐藏时不可交互 */
            transition: opacity 0.3s ease, transform 0.3s ease;
            /* 让透明度和缩放同时产生动画 */
            z-index: 4;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            height: 100%;
            /* vvv 新增：控制背景图的显示方式 vvv */
            background-size: cover;
            /* 关键：让背景图缩放以完全覆盖容器 */
            background-position: center;
            /* 辅助：让图片在容器里居中显示 */
            background-repeat: no-repeat;
            /* 辅助：防止图片在尺寸不匹配时平铺 */
            --emoji-panel-height: 250px;
        }

        /* 当 phone-frame 拥有 .show-chat 类名时 */
        .phone-frame.show-chat #chat-screen {
            /* 结束状态：完全不透明且正常大小 */
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
            /* 激活后可交互 */
        }

        /* (可选) 让消息列表页向左滑出，效果更佳 */
        .phone-frame.show-chat #messages-screen {
            /* 让消息列表页直接淡出，而不是缩小 */
            opacity: 0;
            pointer-events: none;
        }


        /* 2. 固定的高斯模糊顶栏 */
        .chat-header {
            /* 继承通用顶栏样式，但需要覆盖一些属性 */
            position: absolute;
            /* 改为绝对定位，固定在顶部 */
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            align-items: center;
            padding: 10px 15px;
            padding-top: 45px;
            /* 为手机刘海留出空间 */
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            z-index: 10;

            /* --- 高斯模糊核心样式 --- */
            background-color: rgba(255, 255, 255, 0.85);
            /* 必须是半透明背景 */
            -webkit-backdrop-filter: blur(10px);
            /* 兼容 Safari */
            backdrop-filter: blur(10px);
            /* 标准语法 */
        }

        .chat-header h1 {
            /* 继承通用标题样式 */
            font-size: 17px;
            font-weight: 400;
            color: #111;
            margin: 0;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
        }

        /* 让右侧按钮自动靠右 */
        .chat-header #chat-settings-button {
            margin-left: auto;
        }


        /* 3. 聊天消息容器 */
        .chat-messages-container {
            flex-grow: 1;
            /* 占据所有剩余的垂直空间 */
            overflow-y: auto;
            /* 内容超出时可以滚动 */
            padding: 10px;
            /* --- 关键：为固定的顶栏和底栏留出空间 --- */
            padding-top: 90px;
            /* 约等于顶栏高度 */
            padding-bottom: 70px;
            /* 约等于底栏高度 */
        }



        /* 2. 加号按钮的特定样式 */
        #chat-add-attachment-button {
    background-color: #f5f5f5; /* 更柔和的浅灰色背景 */
    color: #555; /* 更深一些的灰色图标，更有质感 */
    width: 40px; /* 适当增大按钮尺寸，方便点击 */
    height: 40px;
    border-radius: 50%; /* 保持圆形 */
    border: none; /* 去掉默认边框，用阴影营造层次 */
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); /* 轻微阴影，增加立体感 */
    transition: all 0.2s ease; /* 过渡动画，让交互更丝滑 */
    cursor: pointer; /* 鼠标悬浮显示手型，提示可点击 */
}

#chat-add-attachment-button:hover {
    background-color: #eaeaea; /*  hover 时背景稍深，反馈更明显 */
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15); /*  hover 时阴影稍重 */
    transform: scale(1.05); /*  hover 时轻微放大，增强交互感 */
}

#chat-add-attachment-button:active {
    background-color: #dcdcdc; /* 点击时背景更深，强化点击反馈 */
    transform: scale(0.98); /* 点击时轻微缩小 */
}

        /* 3. 新增：为加号按钮内的 SVG 设置样式 */
        #chat-add-attachment-button svg {
            width: 24px;
            height: 24px;
        }

        #chat-add-attachment-button svg path {
            fill: currentColor;
            /* 关键：让 SVG 颜色跟随按钮的 color 属性 */
        }

        /* 更新：输入框样式 */
        .chat-input-area input {
            width: 70%;
            height: 40px;
            border: none;
            background-color: #ffffff;
            /* 改为白色背景，更清晰 */
            border-radius: 20px;
            padding: 0 15px;
            font-size: 15px;
            outline: none;
        }

        /* 新增：控制发送按钮内部SVG的样式 */
        #chat-send-button svg {
            width: 24px;
            height: 24px;
        }

        #chat-send-button svg path {
            fill: currentColor;
            /* 关键：让SVG的路径颜色继承父按钮的color属性 (白色) */
        }

        /* === 新增：聊天设置、气泡、输入栏的最终正确样式 === */

        /* --- 1. 聊天设置对话框 --- */
        .modal-content.large {
            max-width: 350px;
            max-height: 85%;
            gap: 0;
            display: flex;
            flex-direction: column;
        }

        .modal-content.large .modal-header,
        .modal-content.large .modal-footer {
            flex-shrink: 0;
        }

        .modal-content.large .modal-header {
            padding-bottom: 10px;
            border-bottom: 1px solid #e5e5e5;
        }

        .modal-content.large .modal-header h2 {
            font-size: 18px;
            margin: 0;
        }

        .modal-body {
            display: flex;
            flex-direction: column;
            gap: 25px;
            padding: 15px 5px;
            overflow-y: auto;
            flex-grow: 1;
        }

        .settings-column {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .settings-column h4 {
            font-size: 16px;
            margin: 0 0 5px 0;
            color: #333;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }

        .form-textarea.code {
            font-family: monospace;
            height: 120px;
            white-space: pre;
            font-size: 12px;
            width: 100%;
        }

        .form-button-secondary.small {
            padding: 6px 10px;
            font-size: 14px;
        }

        .danger-zone {
            border-top: 1px solid #e5e5e5;
            padding-top: 15px;
        }

        .danger-button {
            width: 100%;
            padding: 10px;
            font-size: 14px;
            font-weight: 500;
            color: #ff3b30;
            background-color: rgba(255, 59, 48, 0.1);
            border: 1px solid rgba(255, 59, 48, 0.2);
            border-radius: 8px;
            cursor: pointer;
        }

        /* 关键修复：确保头像设置的行内元素能正确布局 */
        .form-group .form-group-inline {
            display: flex;
            justify-content: space-between;
            /* 两端对齐 */
            align-items: center;
        }

        .form-group .form-group-inline .form-input {
            flex-grow: 0;
            /* 禁止它伸展 */
        }



        .ai-bubble {
            background-color: #E5E5EA;
            color: black;
            border-bottom-left-radius: 4px;
        }

        .message-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            width: 100%;
            animation: bubble-scale-in 0.3s ease-out;
        }

        .message-row.user {
            flex-direction: row-reverse;
            transform-origin: bottom right;
            padding-left: 15%;
        }

        .message-row.ai {
            transform-origin: bottom left;
            padding-right: 15%;
        }

        .hide-avatars .chat-avatar {
            display: none;
        }

        .hide-avatars .message-row.user {
            justify-content: flex-end;
        }

        .chat-messages-container {
            display: flex;
            flex-direction: column;
        }


        /* --- 3. 聊天输入栏 --- */
        .chat-input-area {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            /* 明确宽度 */
            display: flex;
            align-items: center;
            padding: 8px 12px;
            padding-bottom: 25px;
            background-color: #ffffff;
            border-top: 1px solid #dcdcdc;
            gap: 10px;
            box-sizing: border-box;
            /* 关键修复：确保 padding 不会撑大宽度 */
            z-index: 20;
        }

        .chat-action-button {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            flex-shrink: 0;
            padding: 0;
            background-color: transparent;
        }

        #chat-add-attachment-button {
            color: #333;
        }

        #chat-add-attachment-button svg {
            width: 26px;
            height: 26px;
        }

        #chat-add-attachment-button svg path {
            fill: currentColor;
        }

        .chat-input-area input {
            flex-grow: 1;
            height: 40px;
            border: none;
            background-color: #e5e5e5;
            border-radius: 20px;
            padding: 0 15px;
            font-size: 15px;
            outline: none;
        }
        #chat-send-button {
    /* 基础样式保持与附件按钮一致的设计语言 */
    background-color: #f5f5f5;
    color: #555;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1),
                background-color 0.3s ease,
                box-shadow 0.3s ease;
    cursor: pointer;
    position: relative;
    overflow: hidden;
}

/* 悬停效果 */
#chat-send-button:hover {
    background-color: #eaeaea;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

/* 点击效果 */
#chat-send-button:active {
    background-color: #dcdcdc;
    transition: all 0.1s ease;
}

/* 强调色相关 */
#chat-send-button {
    background-color: #007aff;
    color: white;
}

#chat-send-button:hover {
    background-color: #0066cc;
}

#chat-send-button:active {
    background-color: #0052aa;
}

#chat-send-button svg {
    width: 24px;
    height: 24px;
    transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    transform-origin: center;
}

/* 悬停时：从原大小 → 放大 → 缩小回原大小 */
#chat-send-button:hover svg {
    animation: scaleUpDown 0.6s forwards;
}

/* 点击时：快速缩小再恢复（保持点击反馈） */
#chat-send-button:active svg {
    animation: clickScale 0.2s forwards;
}

/* 放大后再缩小回原大小的动画 */
@keyframes scaleUpDown {
    0% {
        transform: scale(1); /* 初始大小 */
    }
    50% {
        transform: scale(1.2); /* 放大到 1.2 倍 */
    }
    100% {
        transform: scale(1); /* 缩小回原大小 */
    }
}

/* 点击时快速缩放的动画 */
@keyframes clickScale {
    0% {
        transform: scale(1); /* 原大小（或 hover 结束后的大小） */
    }
    50% {
        transform: scale(0.9); /* 快速缩小 */
    }
    100% {
        transform: scale(1); /* 恢复原大小 */
    }
}

/* 波纹反馈（保持之前的逻辑） */
#chat-send-button::before {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.3);
    transform: scale(0);
    opacity: 0;
    transition: transform 0.3s ease, opacity 0.3s ease;
    pointer-events: none;
}

#chat-send-button:active::before {
    transform: scale(1);
    opacity: 1;
    animation: ripple 0.6s linear;
}

@keyframes ripple {
    to {
        transform: scale(2);
        opacity: 0;
    }
}

        /* === 更新：更多功能面板的样式 (竖向布局) === */
/* === 更新：更多功能面板的样式 (竖向布局) === */
.features-panel {
    position: absolute;
    bottom: 70px;
    left: 4px;
    background-color: rgba(255, 255, 255, 0.98);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border-radius: 20px;
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
    box-sizing: border-box;
    border: 1px solid rgba(230, 230, 230, 0.8);
    
    opacity: 0;
    transform: translateY(15px) scale(0.95);
    /* 优化过渡曲线，让动画更有弹性 */
    transition: opacity 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), 
                transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    pointer-events: none;
    z-index: 50;
}

.features-panel.active {
    opacity: 1;
    transform: translateY(0) scale(1);
    /* 添加展开时的细微弹跳效果 */
    animation: panelPop 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    pointer-events: auto;
}

/* 新增面板展开动画 */
@keyframes panelPop {
    0% {
        transform: translateY(15px) scale(0.95);
    }
    80% {
        transform: translateY(-2px) scale(1.02);
    }
    100% {
        transform: translateY(0) scale(1);
    }
}

.features-grid {
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.feature-item {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 14px;
    cursor: pointer;
    border-radius: 12px;
    padding: 7px 12px;
    /* 延长过渡时间，让动画更流畅 */
    transition: all 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
    /* 初始状态设置，为动画做准备 */
    opacity: 0;
    transform: translateX(-10px);
}

/* 面板激活时，为每个项目添加依次出现的动画 */
.features-panel.active .feature-item {
    animation: itemSlideIn 0.3s forwards cubic-bezier(0.34, 1.56, 0.64, 1);
}

/* 为每个项目设置不同的延迟，创建层次感 */
.features-panel.active .feature-item:nth-child(1) { animation-delay: 0.05s; }
.features-panel.active .feature-item:nth-child(2) { animation-delay: 0.1s; }
.features-panel.active .feature-item:nth-child(3) { animation-delay: 0.15s; }
.features-panel.active .feature-item:nth-child(4) { animation-delay: 0.2s; }
.features-panel.active .feature-item:nth-child(5) { animation-delay: 0.25s; }

/* 项目滑入动画 */
@keyframes itemSlideIn {
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

.feature-item:hover {
    background-color: rgba(0, 0, 0, 0.04);
    transform: translateX(2px) translateY(-1px); /* 增加Y轴轻微浮动 */
}

.feature-item:active {
    background-color: rgba(0, 0, 0, 0.08);
    /* 点击时的按压效果 */
    transform: translateX(1px) scale(0.98);
    transition: all 0.1s ease;
}

.feature-icon {
    width: 30px;
    height: 30px;
    border-radius: 8px;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-shrink: 0;
    background-color: #f0f2f7;
    transition: background-color 0.25s ease, transform 0.25s ease;
}

.feature-item:hover .feature-icon {
    background-color: #e5e8ef;
    transform: scale(1.1); /* 悬停时图标轻微放大 */
}

.feature-icon svg {
    width: 18px;
    height: 18px;
    fill: #333;
    transition: fill 0.25s ease, transform 0.25s ease;
}

.feature-item:hover .feature-icon svg {
    fill: #007aff;
    transform: rotate(5deg); /* 图标轻微旋转，增加生动感 */
}

.feature-name {
    font-size: 15px;
    color: #1c1c1e;
    font-weight: 500;
    letter-spacing: 0.02em;
    transition: color 0.25s ease;
}



        @keyframes bubble-scale-in {

            /* 动画开始时：完全透明，且只有正常大小的80% */
            from {
                opacity: 0;
                transform: scale(0.8);
            }

            /* 动画结束时：完全不透明，恢复正常大小 */
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* === 新增：“正在输入”提示的CSS样式 === */

        /* 动画容器的样式 */
        .typing-animation {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 16px;
            /* 控制整体高度 */
        }

        /* 动画点的基础样式 */
        .typing-dot {
            width: 6px;
            height: 6px;
            margin: 0 2px;
            background-color: #8E8E93;
            /* 点的颜色 */
            border-radius: 50%;

            /* 应用我们下面定义的动画 */
            animation: typing-bounce 1.2s infinite ease-in-out;
        }

        /* 为第二个和第三个点设置动画延迟，形成波浪效果 */
        .typing-dot:nth-child(2) {
            animation-delay: 0.15s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.3s;
        }

        /* 定义一个名为 "typing-bounce" 的动画 */
        @keyframes typing-bounce {

            0%,
            80%,
            100% {
                transform: scale(0);
                /* 开始、快结束和结束时，点是缩小的 */
            }

            40% {
                transform: scale(1.0);
                /* 动画进行到40%时，点放大到最大 */
            }
        }

        /* --- 新增：消息选择功能的CSS样式 --- */
        /* --- 这是消息布局的【最终修复版】CSS --- */

        /* 1. 外层行容器：永远100%宽度，用于对齐选择器 */
        .message-row {
            position: relative;
            display: flex;
            margin-bottom: 10px;
            width: 100%;
            box-sizing: border-box;
        }

        /* 2. 新增！内容包装层：负责对齐和限制宽度 */
        .message-content-wrapper {
            display: flex;
            align-items: flex-end;
            max-width: 85%;
            /* 约束内容最大宽度 */
            transition: transform 0.3s ease;
            /* 动画效果 */
        }

        .message-content-wrapper.user {
            margin-left: auto;
            /* 关键：将用户的内容推到最右边 */
            flex-direction: row-reverse;
            /* 头像在右，气泡在左 */
        }

        /* 3. 气泡、头像和选择器样式 (基本不变，但选择器更准确) */
        .chat-bubble {
            padding: 10px 15px;
            border-radius: 18px;
            line-height: 1.4;
            word-wrap: break-word;
            font-size: 13.5px;
            min-width: 0;
            /* 确保能正确换行 */
        }

        .ai-bubble {
            background-color: #E5E5EA;
            color: black;
            border-bottom-left-radius: 4px;
        }

        .chat-avatar {
            width: 40px;
            height: 40px;
            object-fit: cover;
            flex-shrink: 0;
            margin: 0 8px;
        }

        .selection-indicator {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            border: 2px solid #c7c7cc;
            border-radius: 50%;
            background-color: #fff;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* 4. 选择模式下的样式 (选择器更精确) */
        .selection-mode-active .selection-indicator {
            opacity: 1;
        }

        .selection-mode-active .message-row {
            /* 注意是 message-row */
            background-color: rgba(0, 122, 255, 0.0);
            /* 移除之前的选中背景色 */
        }

        .message-row.selected {
            background-color: transparent;
        }

        .message-row.selected .selection-indicator {
            background-color: #007aff;
            border-color: #007aff;
        }

        .message-row.selected .selection-indicator::after {
            content: '✔';
            color: white;
            font-size: 12px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* 5. 【关键】选择模式下的平移动画 (最终加强版) */
        #chat-screen.selection-mode-active .message-content-wrapper.ai {
            transform: translateX(30px) !important;
        }

        /* === 新增：全屏模式的样式 === */
        body.fullscreen-mode {
            /* 1. 取消强制居中，让内容从左上角开始 */
            display: block;
            /* 2. 背景设为干净的白色 */
            background-color: #fff;
            /* 3. 新增：在全屏模式下，禁止整个页面滚动 */
    overflow: hidden;
        }

        body.fullscreen-mode .phone-frame {
            /* 3. 覆盖固定的宽高，让它占满整个屏幕 */
            width: 100%;
            height: 100vh;
            /* vh 单位代表视口高度 */
            max-width: none;
            max-height: none;

            /* 4. 移除所有手机框的视觉样式 */
            border: none;
            border-radius: 0;
            box-shadow: none;
            background: #fff;
            /* 背景也设为白色 */

            /* 5. 强制覆盖掉针对小屏幕的 transform: scale 缩放效果 */
            transform: none !important;
        }

        /* === 更新：为悬浮顶栏下的内容区域添加上边距并使其可滚动 === */
        #settings-screen .settings-content,
        #messages-screen .messages-content,
        #playlist-detail-screen .playlist-content,
        #icon-settings-screen .settings-content {
            
            padding-top: 90px;
            height: 100%;
            overflow-y: auto;
            box-sizing: border-box;
        }

        #icon-list-container {
    width: 100%;
}

        /* 将音乐和世界书界面单独设置，使用Flexbox布局 */
        #music-screen .music-content,
        #worldbook-screen .music-content {
            padding: 90px 15px 15px 15px;
            /* 调整内边距，左右也加上 */
            height: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            /* 垂直排列 */
            gap: 15px;
            /* 按钮和列表的间距 */
        }

        /* === 新增：使“新建”按钮固定 === */
        .add-playlist-button {
            flex-shrink: 0;
            /* 防止按钮在空间不足时被压缩 */
            /* 其他样式保持不变 */
        }

        /* === 新增：让新的列表容器可滚动 === */
        .scrollable-list-container {
            flex-grow: 1;
            /* 占据所有剩余的垂直空间 */
            overflow-y: auto;
            /* 让这个容器自己负责滚动 */
        }

        /* === 最终版：独立转账卡片样式 === */

        /* 1. 卡片主容器 */
        .transfer-card {
            background-color: #F0F0F0;
            /* 独立的浅灰色背景 */
            border: 1px solid #E5E5EA;
            border-radius: 12px;
            /* 使用更像卡片的直角一些的圆角 */
            padding: 16px;
            width: 240px;
            /* 宽度调整为240px，不会显得太大 */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 6px;
            /* 调整内部元素间距 */
            color: #000;
            position: relative;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            /* 添加轻微阴影增加质感 */
        }

        /* 2. 卡片内部元素的样式 */
        .transfer-card .card-title {
            font-size: 16px;
            font-weight: 500;
        }

        .transfer-card .card-remark {
            font-size: 14px;
            color: #8A8A8E;
        }

        .transfer-card .card-amount {
            font-size: 32px;
            font-weight: 400;
            margin-top: 8px;
        }

        .transfer-card .card-icon {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 34px;
            /* 直接为图标容器设置尺寸 */
            height: 28px;
        }

        /* === 新增：世界书多选列表的样式 === */
        .multiselect-container {
            max-height: 120px;
            /* 设置一个最大高度 */
            overflow-y: auto;
            /* 内容超出时出现滚动条 */
            background-color: #e9e9eb;
            border: 1px solid #d1d1d6;
            border-radius: 12px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            /* 选项之间的间距 */
        }

        .multiselect-item {
            display: flex;
            align-items: center;
            gap: 10px;
            /* 复选框和文字的间距 */
            font-size: 14px;
            cursor: pointer;
        }

        /* === 新增：歌单多选删除模式的样式 === */

        /* 1. 让歌单卡片成为复选框的定位基准 */
        .playlist-card {
            position: relative;
        }

        /* 2. 复选框的样式，默认隐藏 */
        .playlist-checkbox {
            display: none;
            position: absolute;
            top: 8px;
            right: 8px;
            width: 20px;
            height: 20px;
            z-index: 5;
            /* 确保在封面之上，可以被点击 */
        }

        /* 3. 当歌单网格进入删除模式时，显示复选框 */
        .playlist-grid.delete-mode .playlist-checkbox {
            display: block;
        }

        /* === 最终版 V2：使用专属类名 chatsearch-content === */

        /* 1. 外部容器样式 (保持不变) */
        .search-result-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 6px 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .search-result-item:hover {
            background-color: #e9e9eb;
        }

        /* 2. 第一行容器样式 (保持不变) */
        .search-result-item .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* 3. 发送者和时间样式 (保持不变) */
        .search-result-item .sender-name {
            font-size: 14px;
            font-weight: 500;
            color: #1c1c1e;
        }

        .search-result-item .time {
            font-size: 12px;
            color: #8a8a8e;
        }

        /* 4. 【核心修改】第二行内容摘要样式，应用到新的类名上 */
        .search-result-item .chatsearch-content {
            font-size: 13px;
            color: #333;
            white-space: nowrap;
            /* 禁止换行 */
            overflow: hidden;
            /* 隐藏溢出部分 */
            text-overflow: ellipsis;
            /* 显示省略号 */
        }

        /* 5. 高亮样式 (保持不变) */
        .search-result-item .highlight {
            background-color: rgba(0, 122, 255, 0.15);
            color: rgb(0, 0, 0);
            border-radius: 3px;
            padding: 0 2px;
        }

        /* 其他相关样式 (保持不变) ... */
        @keyframes temporary-highlight {

            0%,
            100% {
                background-color: transparent;
            }

            20%,
            80% {
                background-color: rgba(0, 122, 255, 0.15);
            }
        }

        .message-highlight {
            animation: temporary-highlight 1.5s ease-out;
        }

        /* 新增：隐藏搜索框内自带的清除按钮(x) */
        #search-input::-webkit-search-cancel-button {
            display: none;
        }



        /* === 用于图标和滚动标题的新样式 === */

        /* 1. 主容器，用于对齐图标和文本 */
        .collapsed-music-info {
            display: flex;
            align-items: center;
            gap: 6px;
            /* 图标和文字之间的间距 */
            width: 100%;
            padding: 0 10px;
            box-sizing: border-box;
        }

        /* 2. SVG 图标的样式 */
        .music-icon-collapsed {
            flex-shrink: 0;
            /* 防止图标被压缩变形 */
        }

        /* 3. “窗口”容器，用于隐藏溢出的文本 */
        .title-scroller-window {
            overflow: hidden;
            /* 关键！隐藏所有超出这个容器的内容 */
            flex-grow: 1;
            /* 让它占据所有剩余的空间 */
        }

        /* 4. 标题文本的基础样式 */
        .collapsed-title {
            color: white;
            font-weight: 400;
            white-space: nowrap;
            /* 强制文本不换行 */
            display: inline-block;
            /* 这是让动画正确工作所必需的 */
        }

        /* 5. 这个类将由 JavaScript 添加，用于激活滚动动画 */
        .collapsed-title.scrolling {
            /* 让文本的起点移动到“窗口”的右侧，为滚动入场做准备 */
            padding-left: 100%;
            /* 应用我们下面定义的 'marquee-scroll' 动画 */
            animation: marquee-scroll 8s linear infinite;
        }

        /* 6. 定义滚动动画的关键帧 */
        @keyframes marquee-scroll {
            0% {
                transform: translateX(0);
            }

            100% {
                /* 将文本向左移动，直到它完全从视野中消失 */
                transform: translateX(-100%);
            }
        }

        /* === 新增：灵动岛展开后顶部的样式 === */
        .expanded-header {
            width: 100%;
            position: relative;
            display: flex;
            justify-content: center;
            /* 左右两端对齐 */
            align-items: flex-start;
            /* 顶部对齐 */
        }

        /* 复用 .song-details 的样式，但确保它不会被压缩 */
        .song-details {
            text-align: center;
            flex-shrink: 0;
        }

        /* 新增的邀请按钮样式 */
        .island-action-button {
            position: absolute;
            top: -5px;
            /* 微调垂直位置 */
            right: -5px;
            /* 微调水平位置 */
            background: none;
            border: none;
            padding: 5px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .island-action-button:hover {
            opacity: 1;
        }

        /* === 新增：邀请联系人对话框的CSS (这是缺失的样式部分) === */

        /* 对话框的遮罩背景 */
        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            display: none;
            /* JS会控制它显示 */
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* 对话框主体 */
        .modal-content {
            background-color: #f7f7f7;
            border-radius: 18px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.2);
            width: 300px;
            /* 对话框宽度 */
            max-width: 90%;
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }

        /* 对话框头部 */
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid #e5e5e5;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 17px;
            font-weight: 500;
        }

        .modal-close-button {
            background: none;
            border: none;
            font-size: 28px;
            color: #aaa;
            cursor: pointer;
            line-height: 1;
        }

        /* 对话框内容区域 */
        .modal-body {
            max-height: 400px;
            overflow-y: auto;
            padding: 10px 0;
        }

        /* 列表项的样式 (这个之前给过，请确保它存在) */
        .invite-contact-item {
            display: flex;
            align-items: center;
            padding: 8px 20px;
            transition: background-color 0.2s;
        }

        .invite-contact-item:hover {
            background-color: #f0f0f0;
        }

        .invite-contact-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 12px;
        }

        .invite-contact-name {
            font-size: 16px;
            color: #111;
            flex-grow: 1;
        }

        .invite-button {
            padding: 5px 15px;
            font-size: 13px;
            font-weight: 500;
            color: #007AFF;
            background-color: rgba(0, 122, 255, 0.1);
            border: none;
            border-radius: 20px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .invite-button.invited {
            background-color: #e5e5ea;
            color: #8e8e93;
            cursor: not-allowed;
        }

        /* === 新增：共享听歌重叠头像的样式 === */

        /* 头像容器的样式 */
        .shared-avatars {
            position: absolute;
            /* 绝对定位，浮动在左上角 */
            top: -5px;
            /* 垂直方向微调，使其与歌名对齐 */
            left: 0;
            display: flex;
            /* 使用flex布局来排列头像 */
            align-items: center;
            padding: 2px;
            display: none;
            /* 默认状态下隐藏 */
        }

        /* 当需要显示时，JS会添加这个 .active 类 */
        .shared-avatars.active {
            display: flex;
        }

        /* 单个头像的样式 */
        .shared-avatar-img {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            /* 圆形 */
            border: 2px solid rgba(255, 255, 255, 0.8);
            /* 半透明白色边框，增加质感 */
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            /* 轻微阴影 */
            object-fit: cover;
            /* 防止图片变形 */
        }

        /* 关键：让第二个头像向左移动，与第一个头像重叠 */
        .shared-avatar-img:nth-child(2) {
            margin-left: -12px;
        }

        /* === 新增：“结束一起听”确认气泡的样式 === */
        .confirmation-bubble {
            position: absolute;
            top: 10%;
            left: 250%;
            transform: translateX(-50%);
            margin-top: 8px;

            background-color: rgba(60, 60, 60, 0.85);
            /* 半透明深灰色背景 */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);

            color: white;
            padding: 8px 12px;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);

            display: flex;
            align-items: center;
            gap: 10px;
            white-space: nowrap;
            /* 防止文字换行 */

            /* 默认隐藏，通过JS控制显示 */
            opacity: 0;
            visibility: hidden;
            transform: translateX(-50%) translateY(-5px);
            /* 增加一个轻微的上移动画 */
            transition: opacity 0.2s ease, transform 0.2s ease, visibility 0.2s;
            z-index: 10;
        }

        /* JS添加 .active 类时，气泡显示出来 */
        .confirmation-bubble.active {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }

        .confirmation-bubble span {
            font-size: 14px;
        }

        .confirmation-bubble button {
            background-color: #ff3b30;
            /* 红色背景 */
            color: white;
            border: none;
            border-radius: 8px;
            padding: 4px 10px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
        }

        /* === 新增：用于在聊天界面显示系统提示的样式 === */
        .system-notification {
            text-align: center;
            margin: 10px auto;
            padding: 6px 14px;
            font-size: 12px;
            font-weight: 500;
            color: #007AFF;
            background-color: rgba(0, 122, 255, 0.1);
            border-radius: 20px;
            width: fit-content;
            pointer-events: none;
        }

        /* --- 输入框包装层的正确样式 --- */
        .chat-input-wrapper {
            position: relative;
            /* 这是最关键的一步！为内部的按钮提供定位参考 */
            flex-grow: 1;
            display: flex;
            align-items: center;
        }

        /* --- 表情按钮的正确样式 --- */
        #chat-emoji-button {
            position: absolute;
            /* 绝对定位，会根据上面那个 relative 的父级来定位 */
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            background-color: #e9e9eb;
            color: #333;
            width: 32px;
            height: 32px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        #chat-emoji-button svg {
            width: 20px;
            height: 20px;
        }

        /* --- 输入框的正确样式 --- */
        .chat-input-area input {
            width: 100%;
            padding-right: 42px;
            /* 在右侧留出空间给按钮 */
            box-sizing: border-box;
        }


        /* --- 新增：表情选择面板的样式 --- */

        #emoji-panel {
            position: absolute;
            left: 0;
            width: 100%;
            background-color: #ffffff;
            border-top: 1px solid #dcdcdc;
            z-index: 15;

            /* 使用变量来控制高度 */
            height: var(--emoji-panel-height);

            /* 使用 calc() 函数和变量来计算它的初始隐藏位置 */
            bottom: calc(var(--emoji-panel-height) * -1);

            transition: bottom 0.3s ease-in-out;

            /* === 新增：将其变为垂直弹性布局容器 === */
            display: flex;
            flex-direction: column;
        }


        /* 3. 让其他元素的动画也使用这个变量 */
        .chat-input-area,
        .chat-messages-container {
            transition: bottom 0.3s ease-in-out, padding-bottom 0.3s ease-in-out;
        }


        /* --- 激活状态：所有距离都将根据变量自动计算 --- */

        /* 表情面板上移 */
        #chat-screen.emoji-panel-active #emoji-panel {
            bottom: 0;
        }

        /* 输入栏上移，移动的距离就是变量的值 */
        #chat-screen.emoji-panel-active .chat-input-area {
            bottom: var(--emoji-panel-height);
        }

        /* 消息容器增加内边距，使用 calc() 自动计算总高度 */
        #chat-screen.emoji-panel-active .chat-messages-container {
            padding-bottom: calc(70px + var(--emoji-panel-height));
        }

        /* --- 新增：表情面板内部的样式 --- */

        /* 1. 面板头部的 flex 布局，让按钮分布在两端 */
        .emoji-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 15px;
            /* 上下6px, 左右15px */
            flex-shrink: 0;
            /* 防止头部被压缩 */
        }

        /* 2. 头部按钮的简单样式 */
        .panel-header-button {
            background: none;
            border: none;
            color: #007AFF;
            /* 苹果蓝 */
            font-size: 14px;
            cursor: pointer;
            padding: 5px;
        }

        /* 3. 表情显示的网格容器 */
        /* 3. 表情显示的网格容器 (修正版) */
        #emoji-grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(55px, 1fr));
            gap: 15px;
            row-gap: 20px;

            padding: 15px;
            box-sizing: border-box;

            /* === 新增/修改：让它占据剩余空间并可以垂直滚动 === */
            flex-grow: 1;
            overflow-y: auto;
        }

        /* 4. 单个表情图片的样式 */
        /* 2. 单个表情图片的样式 (核心修改) */
        .emoji-item {
            width: 100%;
            /* 【关键】强制图片的容器为1:1的正方形 */
            aspect-ratio: 1 / 1;
            /* 【关键】让图片在正方形容器内保持自身比例并完整显示，多余部分留白 */
            object-fit: contain;

            cursor: pointer;
            border-radius: 4px;
            background-color: #fff;
            /* 给图片一个白色背景板，更好看 */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            /* 添加轻微阴影 */
            transition: transform 0.2s;
        }

        .emoji-item:hover {
            transform: scale(1.1);
            /* 鼠标悬浮时放大一点 */
        }

        /* 3. 表情项外层容器的样式 (保持不变) */
        .emoji-item-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        /* 4. 可编辑备注的样式 (保持不变) */
        .emoji-remark {
            font-size: 11px;
            color: #555;
            background-color: transparent;
            border: 1px solid transparent;
            border-radius: 4px;
            padding: 2px 4px;
            margin: 0;
            text-align: center;
            width: 100%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .emoji-remark:focus {
            background-color: #fff;
            border: 1px solid #007AFF;
            outline: none;
            white-space: normal;
            overflow: visible;
        }

        /* (可选) 添加这个 CSS 来美化你的表情包 */
        .sticker-bubble {
            padding: 0;
            /* 移除继承自 chat-bubble 的内边距 */
            background-color: transparent;
            /* 移除背景色 */
            max-width: 120px;
            /* 限制表情包最大宽度 */
            max-height: 120px;
            /* 限制表情包最大高度 */
            border-radius: 8px;
            /* 给图片也加个小圆角 */
            object-fit: contain;
            /* 确保图片内容完整显示 */
        }

        /* === 新增：表情包删除模式的样式 === */

        /* 1. 让每个表情包的容器成为复选框的定位基准 */
        .emoji-item-container {
            position: relative;
        }

        /* 2. 复选框的样式，默认隐藏 */
        .emoji-checkbox {
            display: none;
            /* 默认不显示 */
            position: absolute;
            top: -2px;
            right: -2px;
            width: 20px;
            height: 20px;
            z-index: 5;
            /* 确保在图片之上，可以被点击 */
        }

        /* 3. 当网格进入删除模式时，显示复选框 */
        .emoji-grid-container.delete-mode .emoji-checkbox {
            display: block;
        }

        /* 4. (可选) 删除模式下，给选中的表情一个视觉反馈 */
        /* 请只保留下面这一段关于选中样式的 CSS */

        #emoji-grid-container.delete-mode .emoji-item-container.selected {
            aspect-ratio: 1 / 1;
            /* 为了确保这次一定能看到效果，我们使用了一个非常强烈的样式。
    如果这个样式生效了，您可以再把它改成您喜欢的样子。
    */
            border: 3px solid #007AFF !important;
            /* 一个3px宽、不透明的蓝色实线边框 */
            background-color: rgba(0, 122, 255, 0.15) !important;
            /* 一个更明显的淡蓝色背景 */

            border-radius: 8px;
            /* 圆角 */
            transform: scale(0.95);
            /* 轻微缩小以示区别 */
            box-shadow: none !important;
            /* 确保没有其他阴影覆盖边框 */
        }

        /* 确保容器有过渡效果，让动画更平滑 */
        .emoji-item-container {
            position: relative;
            transition: all 0.2s ease-in-out;
        }

        /* === 新增：美化App的动画控制 === */

        /* 默认状态：美化页完全透明，并且无法交互 */
        #beautify-screen {
            opacity: 0;
            pointer-events: none;
            z-index: 1;
            /* 默认在下层 */
        }

        /* 当 phone-frame 拥有 .show-beautify 类名时 */
        .phone-frame.show-beautify #home-screen {
            opacity: 0;
            pointer-events: none;
            z-index: 1;
        }

        .phone-frame.show-beautify #beautify-screen {
            opacity: 1;
            pointer-events: auto;
            z-index: 2;
            /* 美化页浮上来 */
        }
        /* === 新增：更换图标界面的动画控制 === */

/* 默认状态：更换图标页完全透明，并且无法交互 */
#icon-settings-screen {
    opacity: 0;
    pointer-events: none;
    z-index: 1; /* 默认在下层 */
}

/* 当 phone-frame 拥有 .show-icon-settings 类名时 */
.phone-frame.show-icon-settings #beautify-screen {
    opacity: 0; /* 隐藏美化界面 */
    pointer-events: none;
    z-index: 2;
}

.phone-frame.show-icon-settings #icon-settings-screen {
    opacity: 1;
    pointer-events: auto;
    z-index: 3; /* 更换图标页浮上来，层级要比美化页更高 */
}
/* === 新增：图标更换列表的样式 === */
.icon-setting-item {
    display: flex;
    align-items: center;
    width: 90%;
    margin: 0 auto 15px auto; /* 上下15px间距，左右自动居中 */
    padding: 10px;
    background-color: #f7f7f7;
    border-radius: 12px;
}

.icon-preview {
    width: 50px;
    height: 50px;
    border-radius: 12px;
    margin-right: 15px;
    object-fit: cover;
    flex-shrink: 0; /* 防止图标被压缩 */
}

.icon-details {
    display: flex;
    flex-direction: column;
    gap: 8px;
    flex-grow: 1; /* 占据所有剩余空间 */
    min-width: 0; /* 防止内容溢出时破坏布局 */
}

.app-name-setting {
    font-size: 16px;
    font-weight: 500;
    color: #111;
}

.icon-url-input {
    width: 100%;
    padding: 8px;
    border: 1px solid #dcdcdc;
    border-radius: 8px;
    font-size: 12px;
    background-color: #fff;
    box-sizing: border-box; /* 确保padding不会撑大宽度 */
}

/* === 新增：更换时钟界面的动画控制 === */

/* 默认状态：时钟设置页完全透明，且无法交互 */
#clock-settings-screen {
    opacity: 0;
    pointer-events: none;
    z-index: 1; /* 默认在下层 */
}

/* 当 .phone-frame 拥有 .show-clock-settings 类名时 */
.phone-frame.show-clock-settings #beautify-screen {
    opacity: 0; /* 隐藏美化界面 */
    pointer-events: none;
    z-index: 3;
}

.phone-frame.show-clock-settings #clock-settings-screen {
    opacity: 1;
    pointer-events: auto;
    z-index: 4; /* 层级比图标更换页更高 */
}

/* === 新增：时钟高斯模糊背景效果 === */
.clock.clock-blur-enabled {
    /* 1. 半透明背景色，这是模糊效果能看到东西的前提 */
    background-color: rgba(255, 255, 255, 0.15); 
    
    /* 2. 核心：高斯模糊效果 */
    -webkit-backdrop-filter: blur(15px); /* 兼容 Safari */
    backdrop-filter: blur(15px);
    
    /* 3. 美化样式，让它看起来像个圆角卡片 */
    padding: 5px 20px;
    border-radius: 25px;
    
    /* 4. （可选）添加一点边框和阴影增加质感 */
    border: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
}

/* === 新增：回到底部按钮的样式 === */
#scroll-to-bottom-btn {
    /* 定位和尺寸 */
    position: absolute;
    right: 20px;
    bottom: 90px; /* 定位在输入框上方 */
    width: 25px;
    height: 25px;
    z-index: 30; /* 确保在消息之上 */

    /* 视觉样式 */
    background-color: white;
    border-radius: 50%; /* 圆形 */
    border: none;
    cursor: pointer;
    
    /* 阴影和发光效果，增强立体感 */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), 
                0 0 20px rgba(0, 122, 255, 0.1);

    /* 内部SVG居中 */
    display: flex;
    justify-content: center;
    align-items: center;

    /* 隐藏/显示动画效果 */
    opacity: 0;
    visibility: hidden;
    transform: translateY(15px);
    transition: all 0.25s ease-out;
}

/* 当按钮需要显示时，JS会为其添加这个类 */
#scroll-to-bottom-btn.visible {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
}

/* === START: SHOPMALL SCREEN CSS === */

/* Default state: Shop page is transparent and cannot be interacted with */
#shop-screen {
    opacity: 0;
    pointer-events: none;
    z-index: 1; /* Default on a lower layer */
}

/* When the phone-frame has the .show-shop class */
.phone-frame.show-shop #home-screen {
    opacity: 0;
    pointer-events: none;
    z-index: 1;
}

.phone-frame.show-shop #shop-screen {
    opacity: 1;
    pointer-events: auto;
    z-index: 2; /* Bring the shop page to the top */
}

/* Style for the blue, bold title */
#shop-screen .settings-header h1 {
    color: #007AFF; /* A standard blue color */
    font-weight: bold;
}
/* === START: 七袋购物身份头像 CSS === */
.shopper-avatar-btn {
    background: none;
    border: none;
    padding: 0;
    cursor: pointer;
    border-radius: 50%;
}

.shopper-avatar-btn img {
    width: 32px;
    height: 32px;
    border-radius: 50%; /* 圆形 */
    border: 1.5px solid rgba(0, 0, 0, 0.1);
    object-fit: cover; /* 防止图片变形 */
    display: block;
}
/* === END: 七袋购物身份头像 CSS === */

/* === START: SHOPMALL 底栏和内容面板 CSS === */

/* 内容区域主容器，使用flex布局来管理面板和底栏 */
#shop-screen {
    display: flex;
    flex-direction: column;
}


/* ▼▼▼ START: 商城分类栏最终修复版 ▼▼▼ */

/* 1. 确保这是主滚动容器 */
#shop-main-content {
    flex-grow: 1;
    position: relative;
    padding-top: 90px;
    overflow-y: auto; 
}

/* 2. 【核心修改】移除面板自身的滚动，让它只是一个普通容器 */
#shopping-content-panel.active {
    display: block;
    overflow-y: visible; /* 从 auto 改为 visible */
}

/* 3. 【核心修改】修正粘性定位，并添加横向滚动功能 */
.category-tabs {
    /* --- 粘性定位部分 --- */
    position: sticky;
    top: 0;
    background-color: #ffffff;
    z-index: 10;
    
    /* --- 布局部分 --- */
    display: flex;
    gap: 10px;
    padding: 15px 15px 10px 15px;

    /* --- 【新增】横向滚动功能 --- */
    overflow-x: auto;      /* 允许内容横向滚动 */
    white-space: nowrap;   /* 禁止分类按钮自动换行 */
    -ms-overflow-style: none;  /* 隐藏IE和Edge的滚动条 */
    scrollbar-width: none;     /* 隐藏Firefox的滚动条 */
}

/* 【新增】隐藏 Webkit 浏览器 (Chrome, Safari) 的滚动条 */
.category-tabs::-webkit-scrollbar {
    display: none;
}

/* ▲▲▲ END: 商城分类栏最终修复版 ▲▲▲ */

/* 每个独立的内容面板 */
.shop-content-panel {
    display: none; /* 默认隐藏 */
    box-sizing: border-box;
}

/* 当面板被激活时，显示它 */
.shop-content-panel.active {
    display: block;
}

/* 底栏容器 */
.shop-tab-bar {
    display: flex;
    justify-content: space-around;
    align-items: center;
    width: 100%;
    height: 60px;
    background-color: #ffffff;
    border-top: 1px solid #e5e5e5;
    flex-shrink: 0; /* 防止底栏在空间不足时被压缩 */
}

/* 单个标签按钮 */
.shop-tab-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 2px; /* 图标和文字的间距 */
    background: none;
    border: none;
    cursor: pointer;
    font-size: 10px;
    color: #8A8A8E; /* 未选中时的颜色 */
    transition: color 0.2s;
}

/* 激活状态的标签按钮 */
.shop-tab-item.active {
    color: #007AFF; /* 选中时的蓝色 */
}

/* 标签按钮内的SVG图标 */
.shop-tab-item svg {
    width: 24px;
    height: 24px;
}

/* === START: SHOPMALL 购物界面 CSS (V3 - 最终修复版) === */

/* --- 核心修改：让“购物”面板自己负责滚动 --- */


/* --- 1. 分类切换按钮 (保持粘性定位) --- */


.category-tab {
    padding: 8px 16px;
    font-size: 14px;
    font-weight: 500;
    color: #333;
    background-color: #f0f2f5;
    border: none;
    border-radius: 18px;
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}

.category-tab.active {
    background-color: #007AFF;
    color: #fff;
    box-shadow: 0 4px 8px rgba(0, 122, 255, 0.2);
    transform: translateY(-2px);
}

/* --- 2. 商品瀑布流网格 (不再需要自己滚动) --- */
.product-grid-shop {
    padding: 20px 15px; /* 仅设置内边距，把滚动交给父级 */
    display: grid;
    grid-template-columns: repeat(2, 1fr); 
    gap: 15px;
}

/* --- 3. 单个商品卡片 --- */
.product-card {
    background-color: #ffffff;
    border-radius: 12px; /* 更柔和的圆角 */
    padding: 20px;
    /* 更有层次的阴影，模拟真实悬浮效果 */
    display: flex;
    flex-direction: column;
    gap: 14px; /* 优化间距呼吸感 */
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); /* 更自然的过渡曲线 */
    border: 1.7px solid rgba(0, 0, 0, 0.03); /* 极细边框增加质感 */
    /* 关键：确保卡片高度由内容决定 */
    height: auto; /* 明确指定高度自动 */
    min-height: auto; /* 移除可能存在的最小高度限制 */
}

/* 悬停时增强阴影和微抬效果 */
.product-card:hover {
    box-shadow: 
        0 4px 8px rgba(0, 0, 0, 0.06),
        0 8px 20px rgba(0, 0, 0, 0.08);
    transform: translateY(-2px); /* 微妙上浮 */
}

.product-name {
    font-size: 16px;
    font-weight: 600;
    color: #1c1c1e;
    line-height: 1.3; /* 优化行高 */
    letter-spacing: 0.02em; /* 微调字间距 */
}

.product-description {
    font-size: 12px;
    color: #8a8a8e;
    line-height: 1.5; /* 提升可读性 */
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
    min-height: 36px; /* 确保高度稳定 */
}

.product-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 8px;
    padding-top: 10px; /* 增加分隔感 */
    border-top: 1px solid rgba(0, 0, 0, 0.03); /* 细分割线 */
}

.product-price {
    font-size: 16px;
    font-weight: 700;
    color: #007AFF;
    letter-spacing: 0.01em; /* 价格更精致 */
}

.add-to-cart-btn {
    padding: 4px 10px; /* 稍大点击区域 */
    font-size: 11px;
    font-weight: 500;
    color: #007AFF;
    background-color: rgba(0, 122, 255, 0.1);
    border: none;
    border-radius: 16px; /* 更圆润的按钮 */
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 1px 2px rgba(0, 122, 255, 0.1); /* 按钮微妙阴影 */
}

.add-to-cart-btn:hover {
    background-color: rgba(0, 122, 255, 0.15);
    transform: scale(1.03); /* 轻微放大 */
}

.add-to-cart-btn:active {
    transform: scale(0.98); /* 点击反馈 */
}
/* === END: SHOPMALL 购物界面 CSS (V3 - 最终修复版) === */

/* === START: SHOPMALL “我的”界面 CSS === */

/* 列表容器，整体像一个卡片 */
.my-account-list {
    margin: 20px 0; /* 上下留出一些间距 */
    background-color: #ffffff;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
    overflow: hidden; /* 确保内部元素的边框不会超出圆角 */
}

/* 列表中的每一项 */
.my-account-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px 18px; /* 轻微增加右侧内边距，让内容不拥挤 */
    font-size: 16px;
    color: #1c1c1e;
    cursor: pointer;
    transition: all 0.2s ease; /* 统一过渡效果 */
    background-color: #ffffff;
    /* 用双层边框替代单层，增加精致感 */
    border-bottom: 1px solid #f0f0f0;
    border-top: 1px solid transparent; /* 顶部隐形边框，hover时显形 */
    /* 轻微圆角，弱化直角的生硬感 */
    border-radius: 4px;
    margin: 0 4px; /* 与父容器保持间距，增强独立感 */
}

/* 悬停状态强化交互反馈 */
.my-account-item:hover {
    background-color: #fafafa;
    border-top-color: #eeeeee; /* 顶部边框显形，形成上下呼应 */
    transform: translateX(2px); /* 极轻微右移，增强交互感知 */
}


/* 最后一个项目不需要分隔线 */
.my-account-item:last-child {
    border-bottom: none;
}

/* 鼠标悬浮或点击时的效果 */
.my-account-item:active {
    background-color: #f0f2f5;
}

/* 右侧小箭头的样式 */
.chevron-icon {
    width: 20px;
    height: 20px;
}

/* === END: SHOPMALL “我的”界面 CSS === */
/* === START: SHOPMALL 购物车和订单 CSS (V2 - 悬浮按钮修复) === */

/* --- 1. 页面切换动画 (样式不变) --- */
#cart-screen, #orders-screen {
    opacity: 0;
    pointer-events: none;
    z-index: 5;
    background-color: #f0f2f5;
}
.phone-frame.show-cart #shop-screen,
.phone-frame.show-orders #shop-screen {
    opacity: 0;
    pointer-events: none;
}
.phone-frame.show-cart #cart-screen,
.phone-frame.show-orders #orders-screen {
    opacity: 1;
    pointer-events: auto;
}

/* --- 2. 购物车页面 --- */
.cart-page-content {
    padding-top: 90px;
    display: flex;
    flex-direction: column;
    height: 100%;
    box-sizing: border-box;
    position: relative; /* 关键：为悬浮的footer提供定位基准 */
}
#cart-items-container {
    flex-grow: 1;
    overflow-y: auto;
    padding: 15px;
    padding-bottom: 130px; /* 关键：为悬浮按钮留出足够的底部空间 */
}
.cart-item {
    display: flex;
    align-items: center;
    background-color: #fff;
    padding: 15px;
    border-radius: 12px;
    margin-bottom: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.07);
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

/* 添加悬停效果 */
.cart-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

/* 为卡片添加装饰性元素 */
.cart-item::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 5px;
    height: 100%;
    background-color: #007AFF;
    border-radius: 2px 0 0 2px;
}

.cart-item-details {
    flex-grow: 1;
    padding: 0 15px;
    transition: all 0.3s ease;
}

.cart-item-name {
    font-size: 16px;
    font-weight: 600;
    color: #2d3436;
    margin: 0;
    transition: color 0.2s ease;
}



.cart-item-price {
    font-size: 15px;
    color: #2d3436;
    margin-top: 5px;
    font-weight: 500;
    display: flex;
    align-items: center;
}

.cart-item-delete-btn {
    background: none;
    border: none;
    cursor: pointer;
    padding: 5px;
}
.cart-item-delete-btn svg {
    width: 20px;
    height: 20px;
    fill: #ff3b30;
}
/* 关键修改：购物车底部按钮样式 */
.cart-footer {
    position: absolute; /* 改为绝对定位 */
    bottom: 20px; /* 距离底部20px */
    left: 90px; /* 距离左边15px */
    right: 15px; /* 距离右边15px */
    z-index: 20; /* 确保在滚动内容之上 */
    width: 200px;
    display: flex;
    flex-direction: column;
    gap: 10px;

}
/* 为悬浮按钮增加阴影，使其在复杂背景下更清晰 */
.cart-footer .form-button-secondary,
.cart-footer .save-button {
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}


/* --- 3. 订单页面 (样式不变... except for these changes) --- */
.orders-page-content {
    padding: 105px 15px 15px 15px;
    overflow-y: auto;
    height: 100%;
    box-sizing: border-box;
}
.order-card {
    background-color: #fff;
    padding: 20px;
    border-radius: 4px;
    margin-bottom: 18px;
    box-shadow: 0 2px 12px rgba(0, 0, 0, 0.06);
    position: relative;
    border: 1px solid #f0f2f5;
    transition: all 0.2s ease;
}

.order-card:hover {
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.09);
}

.order-header, .order-details, .order-recipient {
    padding-bottom: 14px;
    margin-bottom: 14px;
    border-bottom: 1px solid #f0f2f5;
}

.order-share-btn {
    position: absolute;
    top: 18px;
    right: 18px;
    background: #f0f2f5;
    border: none;
    border-radius: 50%;
    width: 34px;
    height: 34px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    transition: all 0.2s ease;
}

.order-share-btn:hover {
    background-color: #e4e6eb;
    transform: scale(1.05);
}

.order-card div:last-child {
    border-bottom: none;
    margin-bottom: 0;
    padding-bottom: 0;
}

.order-title {
    font-size: 14px;
    color: #666;
    margin-bottom: 6px;
    letter-spacing: 0.2px;
}

.order-value {
    font-size: 17px;
    font-weight: 500;
    color: #1d1d1f;
    line-height: 1.5;
}

/* ▼▼▼ START: 在这里粘贴新的摸鱼App CSS代码 ▼▼▼ */

/* --- 摸鱼App的显示/隐藏动画控制 --- */
#slacking-off-screen {
    opacity: 0;
    pointer-events: none;
    z-index: 1;
    display: flex; /* 使用flex布局来管理顶栏、内容和底栏 */
    flex-direction: column;
}

.phone-frame.show-slacking-off #home-screen {
    opacity: 0;
    pointer-events: none;
    z-index: 1;
}

.phone-frame.show-slacking-off #slacking-off-screen {
    opacity: 1;
    pointer-events: auto;
    z-index: 2;
}

/* --- 摸鱼App的内容区域和面板 --- */
#slacking-off-main-content {
    flex-grow: 1;
    position: relative;
    padding-top: 90px; /* 为顶栏留出空间 */
    background: white;
    overflow-y: auto;
}

.slacking-off-content-panel {
    display: none;
    box-sizing: border-box;
}

.slacking-off-content-panel.active {
    display: block;
}

/* --- 摸鱼App的底栏样式 (参考七袋App) --- */
.slacking-off-tab-bar {
    display: flex;
    justify-content: space-around;
    align-items: center;
    width: 100%;
    height: 60px;
    background-color: #ffffff;
    border-top: 1px solid #e5e5e5;
    flex-shrink: 0;
}

.slacking-off-tab-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 2px;
    background: none;
    border: none;
    cursor: pointer;
    font-size: 10px;
    color: #8A8A8E;
    transition: color 0.2s;
}

.slacking-off-tab-item.active {
    color: #007AFF;
}

.slacking-off-tab-item svg {
    width: 24px;
    height: 24px;
}
/* ▼▼▼ 在这里粘贴新的游戏界面CSS代码 ▼▼▼ */

/* --- 游戏瀑布流网格 --- */
#games-grid {
    padding: 15px;
    /* 核心：创建两列的瀑布流布局 */
    column-count: 2;
    column-gap: 15px;
}

/* --- 单个游戏卡片 --- */
.game-card {
    background-color: #fff;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    margin-bottom: 15px;
    overflow: hidden;
    /* 核心：防止卡片在切换分栏时被切断 */
    break-inside: avoid;
    display: flex;
    flex-direction: column;
}

.game-card img {
    width: 100%;
    height: auto;
    display: block;
}

.game-card-info {
    padding: 12px;
}

.game-card-info h3 {
    font-size: 16px;
    margin: 0 0 5px 0;
    color: #1c1c1e;
}

.game-card-info p {
    font-size: 12px;
    color: #8a8a8e;
    line-height: 1.4;
    margin: 0 0 10px 0;
}

.play-game-btn {
    width: 100%;
    padding: 8px;
    font-size: 14px;
    font-weight: 500;
    color: #fff;
    background-color: #007AFF;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.play-game-btn:hover {
    background-color: #0056b3;
}
/* ▼▼▼ 在这里粘贴新的储蓄卡片CSS代码 ▼▼▼ */

/* --- 储蓄卡片样式 --- */
.savings-card {
    background-color: #fff;
    border-radius: 8px; /* 圆角更大，看起来更柔和 */
    margin: 1px 10px; /* 卡片与屏幕边缘的间距 */
    padding: 25px 20px; /* 卡片内部的填充 */
    border: 1px solid rgba(0, 0, 0, 0.05); /* 添加一个非常淡的边框增加质感 */
}

/* 卡片内的标题样式 */
.savings-card .card-title {
    color: #8a8a8e; /* 柔和的灰色 */
    font-size: 16px;
    font-weight: 500;
    margin: 0 0 8px 0; /* 调整与下方数字的间距 */
}

/* 卡片内的余额数字样式 */
.savings-card .card-balance {
    color: #1c1c1e;
    font-size: 40px; /* 调整字体大小以更好地适应卡片 */
    font-weight: 600;
    margin: 0;
    line-height: 1.2; /* 确保行高正常 */
}

/* ▼▼▼ 在这里粘贴新的游戏弹窗CSS代码 ▼▼▼ */

/* --- 游戏弹窗内的选项容器 --- */
.game-choices {
    display: flex;
    justify-content: center;
    gap: 15px; /* 按钮之间的间距 */
    margin-top: 20px;
}

/* --- 游戏选项按钮的样式 --- */
.game-choice-btn {
    width: 80px;
    height: 60px;
    font-size: 24px;
    font-weight: 600;
    color: #007AFF;
    background-color: rgba(0, 122, 255, 0.1);
    border: 1px solid rgba(0, 122, 255, 0.2);
    border-radius: 10px;
    cursor: pointer;
    transition: background-color 0.2s, transform 0.1s;
}

.game-choice-btn:active {
    transform: scale(0.95); /* 点击时有轻微下沉效果 */
    background-color: rgba(0, 122, 255, 0.2);
}

/* ▼▼▼ 在这里粘贴新的“申请解除”按钮CSS代码 ▼▼▼ */

/* --- 让储蓄卡片成为按钮定位的基准 --- */
.savings-card {
    position: relative; /* 关键！*/
}

/* --- “申请解除”按钮的样式 --- */
.apply-unlock-button {
    position: absolute; /* 绝对定位，相对于父级.savings-card */
    top: 15px;
    right: 15px;
    padding: 6px 12px;
    font-size: 12px;
    font-weight: 500;
    color: #ff3b30; /* 醒目的红色 */
    background-color: rgba(255, 59, 48, 0.1);
    border: 1px solid rgba(255, 59, 48, 0.2);
    border-radius: 20px; /* 圆角胶囊形状 */
    cursor: pointer;
    transition: background-color 0.2s;
}

.apply-unlock-button:hover {
    background-color: rgba(255, 59, 48, 0.2);
}

/* ▼▼▼ 在这里粘贴新的上班模拟按钮CSS代码 ▼▼▼ */

/* --- 上班模拟按钮的特殊样式 --- */
.play-game-btn[data-game-id="go_to_work"] {
    background-color: #34C759; /* 一个充满“生产力”的绿色 */
}

.play-game-btn[data-game-id="go_to_work"]:hover {
    background-color: #2a9e4a;
}
/* ▼▼▼ 在这里粘贴新的“收支明細”CSS代码 ▼▼▼ */

/* --- “收支明细”卡片样式 (类似“我的”页面的卡片) --- */
.details-card {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px;
    font-size: 16px;
    color: #1c1c1e;
    cursor: pointer;
    transition: background-color 0.2s;
    background-color: #ffffff;
    border-radius: 8px;
    margin: 10px 10px;
    border: 1px solid rgba(0, 0, 0, 0.05);
}
.details-card:active {
    background-color: #f0f2f5;
}

/* --- “收支明细”页面的显示/隐藏动画 --- */
#transactions-screen {
    opacity: 0;
    pointer-events: none;
    z-index: 5; /* 层级要比摸鱼App主页高 */
    background-color: #f0f2f5;
}
.phone-frame.show-transactions #slacking-off-screen {
    opacity: 0;
    pointer-events: none;
}
.phone-frame.show-transactions #transactions-screen {
    opacity: 1;
    pointer-events: auto;
}

/* --- 明细页面的内容区域 --- */
.transactions-page-content {
    padding: 90px 15px 15px 15px;
    overflow-y: auto;
    height: 100%;
    box-sizing: border-box;
}

/* --- 单条收支记录的样式 --- */
.transaction-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: #fff;
    padding: 12px 15px;
    border-radius: 10px;
    margin-bottom: 10px;
}

.transaction-info .description {
    font-size: 15px;
    color: #1c1c1e;
    margin-bottom: 4px;
}

.transaction-info .timestamp {
    font-size: 12px;
    color: #8a8a8e;
}

.transaction-amount {
    font-size: 16px;
    font-weight: 600;
}

.transaction-amount.income {
    color: #34C759; /* 收入用绿色 */
}

.transaction-amount.expense {
    color: #FF3B30; /* 支出用红色 */
}
/* --- GACHA App的显示/隐藏动画控制 --- */
#gacha-screen {
    opacity: 0;
    pointer-events: none;
    z-index: 1;
    display: flex; /* 使用flex布局来管理顶栏、内容和底栏 */
    flex-direction: column;
    background-color: #f2f1f6; /* 给页面一个基础背景色 */
}

.phone-frame.show-gacha #home-screen {
    opacity: 0;
    pointer-events: none;
    z-index: 1;
}

.phone-frame.show-gacha #gacha-screen {
    opacity: 1;
    pointer-events: auto;
    z-index: 2;
}

/* --- GACHA App的内容区域和面板 --- */
#gacha-main-content {
    flex-grow: 1;
    position: relative;
    padding-top: 90px; /* 为顶栏留出空间 */
    overflow-y: auto;
}

.gacha-content-panel {
    display: none; /* 默认隐藏所有面板 */
    box-sizing: border-box;
}

.gacha-content-panel.active {
    display: block; /* 只显示激活的面板 */
}

/* --- GACHA App的底栏样式 --- */
.gacha-tab-bar {
    display: flex;
    justify-content: space-around;
    align-items: center;
    width: 100%;
    height: 60px;
    background-color: #ffffff;
    border-top: 1px solid #e5e5e5;
    flex-shrink: 0; /* 防止底栏被压缩 */
}

.gacha-tab-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 2px;
    background: none;
    border: none;
    cursor: pointer;
    font-size: 10px;
    color: #8A8A8E; /* 未选中时的颜色 */
    transition: color 0.2s;
}

.gacha-tab-item.active {
    color: #007AFF; /* 选中时的颜色 */
}

.gacha-tab-item svg {
    width: 24px;
    height: 24px;
}

/* === START: GACHA App 新增样式 === */

/* --- 悬浮发帖按钮 --- */
.floating-action-button {
    position: absolute; /* 相对于父容器 gacha-screen 定位 */
    bottom: 80px; /* 距离底部 80px (留出空间给底部导航栏) */
    right: 20px;  /* 距离右侧 20px */
    z-index: 100; /* 确保它在帖子列表之上 */
    
    width: 40px;
    height: 40px;
    background-color: #007AFF; /* 苹果蓝 */
    border-radius: 50%; /* 制作成圆形 */
    border: none;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); /* 添加阴影使其有立体感 */
    
    display: flex; /* 使用flex布局 */
    justify-content: center; /* 水平居中SVG图标 */
    align-items: center;   /* 垂直居中SVG图标 */
    cursor: pointer;
    transition: transform 0.2s ease-in-out;
}

.floating-action-button:hover {
    transform: scale(1.05); /* 鼠标悬浮时轻微放大 */
}

/* === START: GACHA Post 独立样式 (V-Final) === */

/* --- 1. 帖子流容器，设置5px边距 --- */
#gacha-posts-container {
    padding: 15px 5px 0 5px;
    width: 100%;
    box-sizing: border-box;
}

/* --- 2. 帖子卡片 (gp-card) --- */
.gp-card {
    width: 100%;
    margin: 0px 8px 8px 0px;
    background-color: white;
    /* box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05); */
    overflow: hidden;
    text-align: left;
    border-radius: 12px;
}

/* --- 3. 帖子头部 (gp-header) --- */
.gp-header {
    padding: 12px 15px;
    background-color: #ffffff;
}

.gp-header-content { /* 专属类名，不再冲突 */
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

.gp-user-info {
    display: flex;
    align-items: center;
    text-align: left;
    flex-grow: 1;
    margin-right: 10px;
    min-width: 0;
}

.gp-avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    margin-right: 10px;
    flex-shrink: 0;
    background-size: cover;
    background-position: center;
}

.gp-user-info > div:last-child {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
}

.gp-user-name { font-size: 15px; font-weight: 500; color: #111827; }
.gp-user-handle, .gp-post-date { font-size: 11px; color: #86868b; }
.gp-post-date { white-space: nowrap; flex-shrink: 0; text-align: right; }

/* --- 4. 内容与分割线 --- */
.gp-divider { height: 1px; background-color: #f0f0f0; }
.gp-post-content { padding: 15px; }
.gp-post-text { color: #1f2937; line-height: 1.5; margin-bottom: 16px; font-size: 15px; }
.gp-post-text p { margin-bottom: 12px; }
.gp-post-text p:last-child { margin-bottom: 0; }

/* --- 5. 操作按钮 --- */
.gp-action-buttons { display: flex; align-items: center; justify-content: flex-end; gap: 20px; }
.gp-action-button { display: flex; align-items: center; color: #86868b; background: none; border: none; padding: 0; cursor: pointer; }
.gp-action-button svg { width: 18px; height: 18px; }
.gp-action-button.liked svg path { fill: #007AFF !important; fill-opacity: 1 !important; }

/* --- 6. 评论区 --- */
.gp-comment-section { border-top: 1px solid #f3f4f6; background-color: white; }
.gp-comment-input-area { padding: 12px 15px; border-bottom: 1px solid #f3f4f6; }
.gp-comment-input-wrapper { display: flex; align-items: center; gap: 10px; }
.gp-comment-avatar { width: 30px; height: 30px; border-radius: 50%; flex-shrink: 0; background-size: cover; background-position: center; }
.gp-comment-input { flex: 1; border: 1px solid #e5e7eb; border-radius: 18px; padding: 7px 14px; font-size: 13px; outline: none; min-width: 0;box-sizing: border-box;}
.gp-comment-input:focus { border-color: #007AFF; }
.gp-comment-list { max-height: 350px; overflow-y: auto; }
.gp-comment-item { display: flex; gap: 10px; padding: 12px 15px; border-bottom: 1px solid #f9fafb; }
.gp-comment-content { flex: 1; }
.gp-comment-header { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
.gp-comment-username { font-weight: 500; font-size: 13px; }
.gp-comment-time { color: #86868b; font-size: 11px; }
.gp-comment-text { color: #374151; font-size: 13px; line-height: 1.5; margin-bottom: 8px; }
.gp-comment-actions { display: flex; gap: 12px; }
.gp-reply-btn { background: none; border: none; color: #86868b; font-size: 11px; cursor: pointer; padding: 0; }
.gp-reply-input-area { margin-top: 8px; display: flex; gap: 8px; align-items: center; }
.gp-reply-input { flex: 1; border: 1px solid #e5e7eb; border-radius: 16px; padding: 6px 12px; font-size: 12px; outline: none; }
.gp-reply-input:focus { border-color: #007AFF; }
.gp-reply-mention {
    color: #007AFF; /* 苹果蓝 */
    font-weight: 500; /* 字体稍粗一些 */
}

/* --- 7. 深色模式适配 --- */
.phone-frame.dark-mode .gp-card { background-color: #2c2c2e; border-color: #3a3a3c; }
.phone-frame.dark-mode .gp-header { background-color: #1c1c1e; }
.phone-frame.dark-mode .gp-user-name,
.phone-frame.dark-mode .gp-post-text,
.phone-frame.dark-mode .gp-comment-username,
.phone-frame.dark-mode .gp-comment-text { color: #f5f5f7; }
.phone-frame.dark-mode .gp-user-handle,
.phone-frame.dark-mode .gp-post-date,
.phone-frame.dark-mode .gp-comment-time,
.phone-frame.dark-mode .gp-reply-btn { color: #8e8e93; }
.phone-frame.dark-mode .gp-divider { background-color: #3a3a3c; }

/* === END: GACHA Post 独立样式 (V-Final) === */
/* --- END: GACHA App 新增样式 === */

/* ▼▼▼ START: Add these new styles for Dark Mode ▼▼▼ */

/* When dark mode is on, change the main background and text colors */
.phone-frame.dark-mode .screen,
.phone-frame.dark-mode .modal-content,
.phone-frame.dark-mode #shop-screen,
.phone-frame.dark-mode .shop-tab-bar {
    background-color: #1c1c1e; /* Dark grey background */
    color: #f5f5f7;           /* Light grey text */
}

/* Style for headers in dark mode */
.phone-frame.dark-mode .settings-header,
.phone-frame.dark-mode .chat-header {
    background-color: rgba(44, 44, 46, 0.85); /* Semi-transparent darker grey */
    border-bottom-color: #3a3a3c;
    color: #f5f5f7;
}

/* Make sure header titles and buttons are also light-colored */
.phone-frame.dark-mode .settings-header h1,
.phone-frame.dark-mode .chat-header h1,
.phone-frame.dark-mode .header-text-button {
    color: #f5f5f7;
}

/* Style for input fields and other form elements */
.phone-frame.dark-mode .form-input,
.phone-frame.dark-mode .form-select,
.phone-frame.dark-mode .form-textarea,
.phone-frame.dark-mode .chat-input-area input {
    background-color: #2c2c2e;
    color: #f5f5f7;
    border-color: #3a3a3c;
}

/* Style for buttons */
.phone-frame.dark-mode .form-button-secondary {
    background-color: #2c2c2e;
    color: #0a84ff; /* A slightly brighter blue for dark mode */
}

/* Home screen specific text */
.phone-frame.dark-mode .clock span,
.phone-frame.dark-mode .app-name,
.phone-frame.dark-mode #motto {
    color: #ffffff;
}

/* Chat bubbles */
.phone-frame.dark-mode .ai-bubble {
    background-color: #2c2c2e;
    color: #f5f5f7;
}

.phone-frame.dark-mode .user-bubble {
    background-color: #0a84ff;
    color: white;
}
/* ▼▼▼ START: Dark Mode Fixes (粘贴到这里) ▼▼▼ */

/* --- 综合修复 --- */
/* 确保所有白色背景的屏幕在深色模式下变黑 */
.phone-frame.dark-mode #settings-screen,
.phone-frame.dark-mode #playlist-detail-screen,
.phone-frame.dark-mode #slacking-off-screen,
.phone-frame.dark-mode #icon-settings-screen {
    background-color: #1c1c1e !important; /* 使用 !important 确保最高优先级 */
}

/* 1. 修复：聊天界面底栏 & 表情包面板 */
.phone-frame.dark-mode .chat-input-area,
.phone-frame.dark-mode #emoji-panel {
    background-color: #1c1c1e;
    border-top-color: #3a3a3c;
}
.phone-frame.dark-mode #emoji-grid-container {
    background-color: #1c1c1e;
}
/* 表情包在深色模式下的背景板 */
.phone-frame.dark-mode .emoji-item {
    background-color: #2c2c2e;
}


/* 2. 修复：音乐App歌单详情页 (已包含在上面的综合修复中) */
/* (无需额外代码, #playlist-detail-screen 已处理) */


/* 3. 修复：摸鱼App */
.phone-frame.dark-mode #slacking-off-main-content,
.phone-frame.dark-mode .slacking-off-tab-bar {
    background-color: #1c1c1e;
}
.phone-frame.dark-mode .game-card,
.phone-frame.dark-mode .savings-card,
.phone-frame.dark-mode .details-card,
.phone-frame.dark-mode .transaction-item {
    background-color: #2c2c2e;
    color: #f5f5f7;
}
/* 摸鱼App内的文字颜色修复 */
.phone-frame.dark-mode .savings-card .card-balance,
.phone-frame.dark-mode .game-card-info h3,
.phone-frame.dark-mode .details-card span,
.phone-frame.dark-mode .transaction-info .description {
    color: #f5f5f7;
}


/* 4. 修复：美化App的更换图标卡片 */
.phone-frame.dark-mode .icon-setting-item {
    background-color: #2c2c2e;
}
.phone-frame.dark-mode .app-name-setting {
    color: #f5f5f7;
}


/* 5. 修复：设置App背景 (已包含在上面的综合修复中) */
/* (无需额外代码, #settings-screen 已处理) */


/* --- 其他细节优化 --- */
/* 修复“我的”和“购物车/订单”页面的白色卡片 */
.phone-frame.dark-mode .my-account-list,
.phone-frame.dark-mode .cart-item,
.phone-frame.dark-mode .order-card {
    background-color: #2c2c2e;
    border-color: #3a3a3c;
    color: #f5f5f7;
}
.phone-frame.dark-mode .my-account-item {
    color: #f5f5f7;
    border-bottom-color: #3a3a3c;
}
.phone-frame.dark-mode .order-value {
    color: #f5f5f7;
}

/* 修复GACHA App */
.phone-frame.dark-mode #gacha-screen,
.phone-frame.dark-mode .gacha-tab-bar {
     background-color: #1c1c1e;
}
.phone-frame.dark-mode .gacha-post-card,
.phone-frame.dark-mode .comment-content {
    background-color: #2c2c2e;
}
.phone-frame.dark-mode .post-author-name,
.phone-frame.dark-mode .post-content,
.phone-frame.dark-mode .post-likes-info,
.phone-frame.dark-mode .comment-author-name,
.phone-frame.dark-mode .comment-text {
    color: #f5f5f7;
}
.phone-frame.dark-mode .post-image-desc {
    background-color: #3a3a3c;
    color: #c7c7cc;
    border-left-color: #0a84ff;
}
.phone-frame.dark-mode .post-action-btn {
    color: #8e8e93;
}
.phone-frame.dark-mode .post-action-btn.liked {
    color: #0a84ff;
}
.phone-frame.dark-mode .comment-input {
    background-color: #3a3a3c;
    border-color: #545458;
    color: #f5f5f7;
}


/* ▲▲▲ END: Dark Mode Fixes ▲▲▲ */
/* ▲▲▲ END: Dark Mode styles ▲▲▲ */

.select-recipient-btn {
    /* 基础宽度设置 */
    width: 60%;
    padding: 10px 0; /* 垂直内边距，水平为0保持比例 */
    
    /* 文本样式 */
    font-size: 16px;
    font-weight: 500;
    color: #007AFF; /* 主题色文字 */
    text-align: center;
    
    /* 按钮外观 */
    background-color: rgba(0, 122, 255, 0.1); /* 主题色浅色背景 */
    border: 1px solid rgba(0, 122, 255, 0.2); /* 细边框增强轮廓 */
    border-radius: 12px; /* 柔和圆角 */
    
    /* 交互效果 */
    cursor: pointer;
    transition: all 0.2s ease; /* 平滑过渡 */
    
    /* 居中显示 */
    margin-left: auto;
    margin-right: auto;
    display: block; /* 确保宽度和margin生效 */
}

/* 悬停状态优化 */
.select-recipient-btn:hover {
    background-color: rgba(0, 122, 255, 0.15); /* 略深背景增强反馈 */
    border-color: rgba(0, 122, 255, 0.3); /* 边框色同步加深 */
}

/* 点击状态反馈 */
.select-recipient-btn:active {
    background-color: rgba(0, 122, 255, 0.2);
    transform: scale(0.99); /* 轻微缩放强化点击感 */
}
/* === START: Gacha Post 可见范围功能样式 (V9) === */

/* 右上角可见范围设置按钮 */
.gp-visibility-btn {
    background: none;
    border: none;
    cursor: pointer;
    margin-left: auto; /* 将按钮推到最右边 */
    display: none;
}
.gp-visibility-btn svg {
    width: 18px;
    height: 18px;
    fill: #86868b; /* 默认灰色 */
}
.gp-visibility-btn.private svg {
    fill: #007AFF; /* 设置为私密后变为蓝色 */
}

/* Modal内的世界书列表样式 */
.visibility-item {
    display: flex;
    align-items: center;
    padding: 8px 0;
}
.visibility-item input {
    margin-right: 12px;
    width: 18px;
    height: 18px;
}
.visibility-item label {
    font-size: 16px;
}
/* === START: Gacha Post 点赞显示样式 (V12) === */

/* 点赞信息行的容器 */
.gp-comment-likes {
    background-color: #f0f2f5; /* 淡灰色背景 */
    border-radius: 8px;
    padding: 6px 10px;
    margin-top: 8px; /* 与上方元素的间距 */
    font-size: 12px;
    color: #555;
    display: flex; /* 使用flex布局 */
    align-items: center; /* 垂直居中 */
    gap: 6px; /* 图标和文字的间距 */
}

/* 点赞列表里的小爱心图标 */
.gp-comment-likes svg {
    width: 14px;
    height: 14px;
    fill: #8a8a8e; /* 图标颜色 */
    flex-shrink: 0; /* 防止图标被压缩 */
}

/* 深色模式下的适配 */
.phone-frame.dark-mode .gp-comment-likes {
    background-color: #3a3a3c;
    color: #c7c7cc;
}
.phone-frame.dark-mode .gp-comment-likes svg {
    fill: #8e8e93;
}

/* === END: Gacha Post 点赞显示样式 (V12) === */

/* === END: Gacha Post 可见范围功能样式 (V9) === */
    </style>

    <style id="custom-bubble-styles"></style>

</head>

<body>
    <div id="click-shield" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9999; display: none;"></div>
    <div class="phone-frame">
        <div id="dynamic-island" class="dynamic-island">
            <div class="island-collapsed-content">
                <div class="collapsed-music-info">
                    <svg class="music-icon-collapsed" width="16" height="16" viewBox="0 0 24 24" fill="none"
                        xmlns="http://www.w3.org/2000/svg">
                        <path d="M9 18V5l12-2v13" stroke="white" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round"></path>
                        <circle cx="6" cy="18" r="3" stroke="white" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round"></circle>
                        <circle cx="18" cy="16" r="3" stroke="white" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round"></circle>
                    </svg>
                    <div class="title-scroller-window">
                        <span id="collapsed-song-title" class="collapsed-title"></span>
                    </div>
                </div>
            </div>
            <div class="island-expanded-content">

                <div class="expanded-header">

                    <div id="shared-listening-avatars" class="shared-avatars">

                        <div id="avatar-image-container"></div>

                        <div id="end-session-bubble" class="confirmation-bubble">
                            <span>结束一起听?</span>
                            <button id="end-listening-session-btn">结束</button>
                        </div>

                    </div>

                    <div class="song-details">
                        <div id="island-song-title" class="song-title">Pepas</div>
                        <div id="island-song-artist" class="song-artist">Farruko</div>
                    </div>

                    <button id="island-invite-button" class="island-action-button">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path
                                d="M8 11C10.7614 11 13 8.76142 13 6C13 3.23858 10.7614 1 8 1C5.23858 1 3 3.23858 3 6C3 8.76142 5.23858 11 8 11Z"
                                fill="white" />
                            <path
                                d="M0 21C0 16.5817 3.58172 13 8 13C12.4183 13 16 16.5817 16 21C16 22.1046 15.1046 23 14 23H2C0.895431 23 0 22.1046 0 21Z"
                                fill="white" />
                            <path
                                d="M17 13C18.6569 13 20 11.6569 20 10C20 8.34315 18.6569 7 17 7C15.3431 7 14 8.34315 14 10C14 11.6569 15.3431 13 17 13Z"
                                fill="white" />
                            <path d="M19 10V2L22 3" stroke="white" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" />
                        </svg>
                    </button>

                </div>

                <div class="progress-container">
                    <span id="progress-current-time">0:00</span>
                    <div class="progress-bar-wrapper">
                        <div id="progress-bar-fill" class="progress-bar-fill"></div>
                    </div>
                    <span id="progress-remaining-time">-0:00</span>
                </div>
                <div class="controls-container">
                    <button id="island-prev-btn" class="control-button">
                        <svg viewBox="0 0 24 24">
                            <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"></path>
                        </svg>
                    </button>
                    <button id="island-play-pause-btn" class="control-button play-pause">
                        <svg class="play-icon" viewBox="0 0 24 24">
                            <path d="M8 5v14l11-7z"></path>
                        </svg>
                        <svg class="pause-icon" viewBox="0 0 24 24">
                            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path>
                        </svg>
                    </button>
                    <button id="island-next-btn" class="control-button">
                        <svg viewBox="0 0 24 24">
                            <path d="M16 6h2v12h-2zm-4.5 6l-8.5 6V6z"></path>
                        </svg>
                    </button>
                </div>

            </div>
        </div>
        <div id="home-screen" class="screen active">

            <div class="content">

                <div class="header-content">
                    <div class="clock">
                        <span id="clock-hours">--</span>
                        <span>:</span>
                        <span id="clock-minutes">--</span>
                    </div>
                    <div class="motto-container">
                        <p id="motto" contenteditable="true">签名语录 (点击编辑)</p>
                    </div>
                </div>

                <div class="widget-placeholder" id="widgetContainer">
                    <span id="widgetText">Widgets（点击展示照片）</span>
                    <input type="file" id="imageUploader" accept="image/*" style="display: none;">
                </div>

                <div class="app-grid">
                    <div class="app-container" id="worldbook-app-icon">
                        <div class="app-icon">
                            <img src="https://i.postimg.cc/50WLGSrN/Icon-pages-2.png" alt="世界书">
                        </div>
                        <span class="app-name">世界书</span>
                    </div>
                    <div class="app-container" id="messages-app-icon">
                        <div class="app-icon">
                            <img src="https://i.postimg.cc/bJnwpTQR/app.png" alt="消息图标">
                        </div>
                        <span class="app-name">消息</span>
                    </div>

                    <div class="app-container" id="music-app-icon">
                        <div class="app-icon">
                            <img src="https://i.postimg.cc/TPzWVh0C/Apple-Music-Icon.png" alt="音乐图标">
                        </div>
                        <span class="app-name">音乐</span>
                    </div>

                    <div class="app-container" id="gacha-app-icon"> <div class="app-icon">
                        <img src="https://i.postimg.cc/fTB7tWYK/GACHA.png" alt="GACHA">
                    </div>
                    <span class="app-name">GACHA！</span>
                    </div>

                    <div class="app-container" id="SHOP-app-icon"> <div class="app-icon">
                        <img src="https://i.postimg.cc/J41HL8kw/shopmall.png" alt="qidai">
                    </div>
                    <span class="app-name">七袋</span>
                    </div>

                    <div class="app-container" id="GAME-app-icon"> <div class="app-icon">
                        <img src="https://i.postimg.cc/8zyrPYVy/game-2.png" alt="game">
                    </div>
                    <span class="app-name">摸鱼</span>
                    </div>

                    <div class="app-container" id="beautify-app-icon">
                        <div class="app-icon">
                            <img src="https://i.postimg.cc/X7kVw6yR/ui.png" alt="美化">
                        </div>
                        <span class="app-name">美化</span>
                    </div>

                    <div class="app-container" id="settings-app-icon">
                        <div class="app-icon">
                            <img src="https://i.postimg.cc/y6g7qvVg/Settings.png" alt="设置图标">
                        </div>
                        <span class="app-name">设置</span>
                    </div>
                </div>

            </div>

        </div>
        <div id="settings-screen" class="screen">
            <div class="settings-header">
                <button id="back-button" class="header-text-button">返回</button>
                <h1>设置</h1>
                <button id="save-settings-button" class="header-text-button">保存</button>
            </div>
            <div class="settings-content">
                <div class="form-group">
                    <label for="api-url">URL</label>
                    <input type="text" id="api-url" class="form-input" placeholder="例如：https://api.openai.com">
                </div>

                <div class="form-group">
                    <label for="api-key">KEY</label>
                    <input type="password" id="api-key" class="form-input" placeholder="请输入您的 API Key">
                </div>

                <div class="form-group" style="display:flex; align-items:center; gap:15px;">
                    <button id="connect-api-button" class="form-button">连接测试</button>
                    <span id="api-connection-status" style="font-size: 14px; color: #8A8A8E;"></span>
                </div>

                <div class="form-group">
                    <label for="api-model">模型</label>
                    <select id="api-model" class="form-select" disabled>
                        <option value="" disabled selected>请先连接成功</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="temperature-slider" style="display:flex; justify-content:space-between;">
                        <span>温度</span>
                        <span id="temperature-value">1.0</span>
                    </label>
                    <input type="range" id="temperature-slider" class="form-slider" min="0" max="2" value="1"
                        step="0.1">
                </div>
                <div class="form-group">
                    <label style="display: flex; justify-content: space-between; align-items: center;">
                        <span>显示小组件</span>
                        <label class="switch">
                            <input type="checkbox" id="toggle-widget-visibility" checked>
                            <span class="slider round"></span>
                        </label>
                    </label>
                </div>
                <div class="form-group">
                    <label style="display: flex; justify-content: space-between; align-items: center;">
                        <span>启用全屏模式</span>
                        <label class="switch">
                            <input type="checkbox" id="toggle-frame-visibility">
                        </label>
                    </label>
                </div>
                <div class="form-group">
    <label style="display: flex; justify-content: space-between; align-items: center;">
        <span>夜间模式</span>
        <label class="switch">
            <input type="checkbox" id="toggle-dark-mode">
            <span class="slider round"></span>
        </label>
    </label>
</div>
                <div class="form-group"> <label>主页壁纸</label>
                    <div class="wallpaper-controls">
                        <div id="wallpaper-preview"></div>
                        <div class="wallpaper-buttons">
                            <button id="upload-wallpaper-btn" class="form-button-secondary">选择图片</button>
                            <button id="reset-wallpaper-btn" class="form-button-secondary">恢复默认</button>
                        </div>
                    </div>
                </div>
                <!-- === 新增：全局字体更换功能 === -->
                <div class="form-group">
                    <label>全局字体</label>
                    <div class="wallpaper-buttons"> <!-- 复用壁纸按钮的布局 -->
                        <button id="change-font-btn" class="form-button-secondary">更换字体</button>
                        <button id="restore-font-btn" class="form-button-secondary">恢复默认</button>
                    </div>
                </div>
                <div class="form-group">
                    <label>数据管理</label>
                    <div class="wallpaper-buttons"> <button id="backup-data-btn"
                            class="form-button-secondary">备份</button>
                        <button id="import-data-btn" class="form-button-secondary">导入</button>
                    </div>
                </div>
                <input type="file" id="import-file-input" accept=".json" style="display: none;">

                <input type="file" id="wallpaper-upload-input" accept="image/*" style="display: none;">
            </div>

        </div>
        <div id="music-screen" class="screen">
            <div class="settings-header">
                <button id="music-back-button" class="header-text-button">返回</button>
                <h1>音乐</h1>
                <div class="header-actions">
                    <button id="playlist-multiselect-btn" class="header-button">多选</button>
                </div>
            </div>
            <div id="music-content" class="music-content">
                <button id="add-playlist-btn" class="add-playlist-button">新建歌单</button>
                <div class="scrollable-list-container">
                    <div id="playlist-grid" class="playlist-grid">
                    </div>
                </div>
            </div>

        </div>
        <div id="playlist-detail-screen" class="screen">
            <div class="settings-header playlist-header">
                <button id="playlist-back-button" class="header-text-button">返回</button>
                <h1 id="playlist-name-title">歌单名称</h1>
                <div class="header-actions">
                    <button id="edit-playlist-name-btn" class="header-button">编</button>
                    <button id="upload-cover-btn" class="header-button">封</button>
                    <button id="multi-select-btn" class="header-button">批</button>
                </div>
            </div>
            <div class="playlist-content">
                <button id="import-music-button" class="import-button">导入歌曲</button>
                <ul id="song-list" class="song-list">
                </ul>
            </div>
            <input type="file" id="music-file-input" accept=".mp3,.wav,.flac" multiple="" style="display: none;">
        </div>
        <div id="messages-screen" class="screen">
            <div class="settings-header">
                <button id="messages-back-button" class="header-text-button">返回</button>
                <h1>消息</h1>
                <div class="header-actions">
                    <button id="messages-add-btn" class="header-button">添加</button>
                    <button id="messages-multiselect-btn" class="header-button">多选</button>
                </div>
            </div>
            <!-- 这里是消息界面的内容区域，现在是空的 -->
            <div class="messages-content">
                <ul id="contact-list" class="contact-list">
                    <!-- 联系人列表项将通过 JS 动态添加到这里 -->
                </ul>
            </div>
        </div>

        <input type="file" id="cover-upload-input" accept="image/*" style="display: none;">
        <audio id="audio-player" style="display:none;"></audio>
        <!-- === 新增：添加联系人弹出层 (Modal) === -->
        <div id="add-contact-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">

                <!-- 1. 顶部滑块和关闭按钮 -->
                <div class="modal-header">
                    <div class="role-switcher">
                        <span class="switch-label active" data-form="ai">Char</span>
                        <label class="switch">
                            <input type="checkbox" id="role-switch-checkbox">
                            <span class="slider round"></span>
                        </label>
                        <span class="switch-label" data-form="user">User</span>
                    </div>
                    <button id="modal-close-btn" class="modal-close-button">&times;</button>
                </div>

                <!-- 2. AI信息表单 (默认显示) -->
                <div id="ai-form" class="role-form active">
                    <div class="avatar-uploader">
                        <img src="https://placehold.co/100x100/EFEFEF/AAAAAA?text=AI" id="ai-avatar-preview"
                            class="avatar-preview">
                        <input type="file" id="ai-avatar-input" class="avatar-input" accept="image/*">
                        <label for="ai-avatar-input" class="avatar-upload-label">上传头像</label>
                    </div>
                    <input type="text" id="ai-name-input" class="form-input" placeholder="  角色名">
                    <textarea id="ai-persona-input" class="form-textarea" placeholder="人设输入区域..."></textarea>
                </div>

                <!-- 3. 用户信息表单 (默认隐藏) -->
                <div id="user-form" class="role-form">
                    <div class="avatar-uploader">
                        <img src="https://placehold.co/100x100/EFEFEF/AAAAAA?text=User" id="user-avatar-preview"
                            class="avatar-preview">
                        <input type="file" id="user-avatar-input" class="avatar-input" accept="image/*">
                        <label for="user-avatar-input" class="avatar-upload-label">上传头像</label>
                    </div>
                    <input type="text" id="user-name-input" class="form-input" placeholder="  你的名字">
                    <textarea id="user-persona-input" class="form-textarea" placeholder="你的人设..."></textarea>
                </div>

                <!-- 4. 底部公共部分 -->
                <div class="modal-footer">
                    <div class="form-group-inline">
                        <label for="context-memory-input">上下文记忆:</label>
                        <input type="number" id="context-memory-input" class="form-input" value="10" min="0" max="100">
                    </div>
                    <button id="save-contact-btn" class="save-button">保存</button>
                </div>

            </div>
        </div>
        <!-- === 新增：聊天界面 === -->
        <div id="chat-screen" class="screen">
            <!-- 1. 悬浮顶栏 -->
            <div class="chat-header">
                <button id="chat-back-button" class="header-text-button">返回</button>
                <h1 id="chat-contact-name">角色名</h1>
                <div id="chat-header-actions-normal"
                    style="margin-left: auto; display: flex; align-items: center; gap: 10px;">
                    <button id="chat-search-button" class="header-text-button">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path
                                d="M14.4733 13.5267L12 11.0733C12.9601 9.87627 13.425 8.35686 13.2992 6.82753C13.1734 5.2982 12.4664 3.87519 11.3237 2.85109C10.1809 1.827 8.6892 1.27967 7.15528 1.32164C5.62136 1.36362 4.16181 1.99171 3.07676 3.07676C1.99171 4.16181 1.36362 5.62136 1.32164 7.15528C1.27967 8.6892 1.827 10.1809 2.85109 11.3237C3.87519 12.4664 5.2982 13.1734 6.82753 13.2992C8.35686 13.425 9.87627 12.9601 11.0733 12L13.5267 14.4533C13.5886 14.5158 13.6624 14.5654 13.7436 14.5993C13.8249 14.6331 13.912 14.6505 14 14.6505C14.088 14.6505 14.1751 14.6331 14.2564 14.5993C14.3376 14.5654 14.4114 14.5158 14.4733 14.4533C14.5935 14.329 14.6607 14.1629 14.6607 13.99C14.6607 13.8171 14.5935 13.651 14.4733 13.5267V13.5267ZM7.33333 12C6.41035 12 5.5081 11.7263 4.74067 11.2135C3.97324 10.7007 3.3751 9.97191 3.02189 9.11919C2.66868 8.26646 2.57627 7.32815 2.75633 6.42291C2.9364 5.51766 3.38085 4.68614 4.0335 4.0335C4.68614 3.38085 5.51766 2.9364 6.42291 2.75633C7.32815 2.57627 8.26646 2.66868 9.11919 3.02189C9.97191 3.3751 10.7007 3.97324 11.2135 4.74067C11.7263 5.5081 12 6.41035 12 7.33333C12 8.57101 11.5083 9.75799 10.6332 10.6332C9.75799 11.5083 8.57101 12 7.33333 12V12Z"
                                fill="#007AFF" />
                        </svg>
                    </button>
                    <button id="chat-settings-button" class="header-text-button">设置</button>
                </div>
                <div id="chat-header-actions-select" style="margin-left: auto; display: none;">
                    <button id="delete-messages-btn" class="header-text-button" style="color: #ff3b30;">删除</button>
                    <button id="cancel-selection-btn" class="header-text-button">取消</button>
                </div>
            </div>

            <!-- 2. 聊天消息容器 -->
            <div id="chat-messages-container" class="chat-messages-container">

                <!-- 聊天气泡将通过 JS 动态添加到这里 -->
            </div>

            <div id="more-features-panel" class="features-panel">
                <div class="features-grid">
                    <div class="feature-item" id="time-perception-feature">
                        <div class="feature-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M12 6C11.8687 5.99997 11.7386 6.02581 11.6173 6.07605C11.4959 6.12629 11.3857 6.19995 11.2928 6.29282C11.2 6.38568 11.1263 6.49593 11.0761 6.61728C11.0258 6.73862 11 6.86867 11 7V10.2676L9.90234 9.63379C9.67262 9.50134 9.3997 9.46555 9.14359 9.53427C8.88748 9.60299 8.66914 9.7706 8.53658 10.0003C8.40401 10.2299 8.36807 10.5028 8.43666 10.759C8.50525 11.0151 8.67276 11.2335 8.90234 11.3662L11.5 12.8662C11.652 12.954 11.8245 13.0002 12.0001 13.0002C12.1756 13.0002 12.3481 12.954 12.5001 12.8662C12.6521 12.7784 12.7783 12.6521 12.8661 12.5001C12.9539 12.348 13 12.1756 13 12V7C13 6.86867 12.9742 6.73862 12.924 6.61728C12.8737 6.49593 12.8001 6.38568 12.7072 6.29282C12.6143 6.19995 12.5041 6.12629 12.3827 6.07605C12.2614 6.02581 12.1313 5.99997 12 6ZM12 2C10.0222 2 8.08879 2.58649 6.4443 3.6853C4.79981 4.78412 3.51809 6.3459 2.76121 8.17317C2.00433 10.0004 1.8063 12.0111 2.19215 13.9509C2.578 15.8907 3.53041 17.6725 4.92894 19.0711C6.32746 20.4696 8.10929 21.422 10.0491 21.8079C11.9889 22.1937 13.9996 21.9957 15.8268 21.2388C17.6541 20.4819 19.2159 19.2002 20.3147 17.5557C21.4135 15.9112 22 13.9778 22 12C21.997 9.34877 20.9424 6.80699 19.0677 4.93228C17.193 3.05758 14.6512 2.00303 12 2ZM12 20C10.4178 20 8.87104 19.5308 7.55544 18.6518C6.23985 17.7727 5.21447 16.5233 4.60897 15.0615C4.00347 13.5997 3.84504 11.9911 4.15372 10.4393C4.4624 8.88743 5.22433 7.46197 6.34315 6.34315C7.46197 5.22433 8.88743 4.4624 10.4393 4.15372C11.9911 3.84504 13.5997 4.00346 15.0615 4.60896C16.5233 5.21447 17.7727 6.23984 18.6518 7.55544C19.5308 8.87103 20 10.4177 20 12C19.9976 14.121 19.1539 16.1544 17.6542 17.6542C16.1544 19.1539 14.121 19.9976 12 20Z" fill="black"/>
                                </svg>
                                
                                
                        </div>
                        <span class="feature-name">时间</span>
                    </div>
                    <div class="feature-item" id="transfer-feature">
                        <div class="feature-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M9.50001 10.5001H12C12.2652 10.5001 12.5196 10.3947 12.7071 10.2072C12.8947 10.0196 13 9.76528 13 9.50007C13 9.23485 12.8947 8.9805 12.7071 8.79296C12.5196 8.60543 12.2652 8.50007 12 8.50007H11V8.00007C11 7.73485 10.8947 7.4805 10.7071 7.29296C10.5196 7.10543 10.2652 7.00007 10 7.00007C9.73479 7.00007 9.48044 7.10543 9.2929 7.29296C9.10537 7.4805 9.00001 7.73485 9.00001 8.00007V8.55007C8.39243 8.67344 7.85237 9.01817 7.48466 9.51733C7.11696 10.0165 6.94785 10.6345 7.01015 11.2513C7.07246 11.8682 7.36174 12.4398 7.82184 12.8554C8.28194 13.2709 8.88003 13.5007 9.50001 13.5001H10.5C10.6326 13.5001 10.7598 13.5527 10.8536 13.6465C10.9473 13.7403 11 13.8675 11 14.0001C11 14.1327 10.9473 14.2599 10.8536 14.3536C10.7598 14.4474 10.6326 14.5001 10.5 14.5001H8.00001C7.73479 14.5001 7.48044 14.6054 7.2929 14.793C7.10537 14.9805 7.00001 15.2349 7.00001 15.5001C7.00001 15.7653 7.10537 16.0196 7.2929 16.2072C7.48044 16.3947 7.73479 16.5001 8.00001 16.5001H9.00001V17.0001C9.00001 17.2653 9.10537 17.5196 9.2929 17.7072C9.48044 17.8947 9.73479 18.0001 10 18.0001C10.2652 18.0001 10.5196 17.8947 10.7071 17.7072C10.8947 17.5196 11 17.2653 11 17.0001V16.4501C11.6076 16.3267 12.1476 15.982 12.5154 15.4828C12.8831 14.9836 13.0522 14.3657 12.9899 13.7488C12.9276 13.132 12.6383 12.5603 12.1782 12.1448C11.7181 11.7292 11.12 11.4994 10.5 11.5001H9.50001C9.3674 11.5001 9.24022 11.4474 9.14645 11.3536C9.05269 11.2599 9.00001 11.1327 9.00001 11.0001C9.00001 10.8675 9.05269 10.7403 9.14645 10.6465C9.24022 10.5527 9.3674 10.5001 9.50001 10.5001ZM21 12.0001H18V3.00007C18.0007 2.82386 17.9548 2.65059 17.867 2.49781C17.7792 2.34504 17.6526 2.21817 17.5 2.13007C17.348 2.0423 17.1755 1.99609 17 1.99609C16.8245 1.99609 16.652 2.0423 16.5 2.13007L13.5 3.85007L10.5 2.13007C10.348 2.0423 10.1755 1.99609 10 1.99609C9.82447 1.99609 9.65203 2.0423 9.50001 2.13007L6.50001 3.85007L3.50001 2.13007C3.34799 2.0423 3.17554 1.99609 3.00001 1.99609C2.82447 1.99609 2.65203 2.0423 2.50001 2.13007C2.3474 2.21817 2.22079 2.34504 2.13299 2.49781C2.04518 2.65059 1.99931 2.82386 2.00001 3.00007V19.0001C2.00001 19.7957 2.31608 20.5588 2.87869 21.1214C3.4413 21.684 4.20436 22.0001 5.00001 22.0001H19C19.7957 22.0001 20.5587 21.684 21.1213 21.1214C21.6839 20.5588 22 19.7957 22 19.0001V13.0001C22 12.7349 21.8947 12.4805 21.7071 12.293C21.5196 12.1054 21.2652 12.0001 21 12.0001ZM5.00001 20.0001C4.73479 20.0001 4.48044 19.8947 4.2929 19.7072C4.10536 19.5196 4.00001 19.2653 4.00001 19.0001V4.73007L6.00001 5.87007C6.15435 5.95068 6.32589 5.99278 6.50001 5.99278C6.67413 5.99278 6.84567 5.95068 7.00001 5.87007L10 4.15007L13 5.87007C13.1543 5.95068 13.3259 5.99278 13.5 5.99278C13.6741 5.99278 13.8457 5.95068 14 5.87007L16 4.73007V19.0001C16.0027 19.3412 16.0636 19.6794 16.18 20.0001H5.00001ZM20 19.0001C20 19.2653 19.8947 19.5196 19.7071 19.7072C19.5196 19.8947 19.2652 20.0001 19 20.0001C18.7348 20.0001 18.4804 19.8947 18.2929 19.7072C18.1054 19.5196 18 19.2653 18 19.0001V14.0001H20V19.0001Z" fill="black"/>
                                </svg>                   
                        </div>
                        <span class="feature-name">转账</span>
                    </div>
                    <div class="feature-item" id="receipt-feature">
                        <div class="feature-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M8.29 13.29C8.19627 13.383 8.12188 13.4936 8.07111 13.6154C8.02034 13.7373 7.9942 13.868 7.9942 14C7.9942 14.132 8.02034 14.2627 8.07111 14.3846C8.12188 14.5064 8.19627 14.617 8.29 14.71L11.29 17.71C11.383 17.8037 11.4936 17.8781 11.6154 17.9289C11.7373 17.9797 11.868 18.0058 12 18.0058C12.132 18.0058 12.2627 17.9797 12.3846 17.9289C12.5064 17.8781 12.617 17.8037 12.71 17.71L15.71 14.71C15.8983 14.5217 16.0041 14.2663 16.0041 14C16.0041 13.7337 15.8983 13.4783 15.71 13.29C15.5217 13.1017 15.2663 12.9959 15 12.9959C14.7337 12.9959 14.4783 13.1017 14.29 13.29L13 14.59V3C13 2.73478 12.8946 2.48043 12.7071 2.29289C12.5196 2.10536 12.2652 2 12 2C11.7348 2 11.4804 2.10536 11.2929 2.29289C11.1054 2.48043 11 2.73478 11 3V14.59L9.71 13.29C9.61704 13.1963 9.50644 13.1219 9.38458 13.0711C9.26272 13.0203 9.13201 12.9942 9 12.9942C8.86799 12.9942 8.73728 13.0203 8.61542 13.0711C8.49356 13.1219 8.38296 13.1963 8.29 13.29ZM18 9H16C15.7348 9 15.4804 9.10536 15.2929 9.29289C15.1054 9.48043 15 9.73478 15 10C15 10.2652 15.1054 10.5196 15.2929 10.7071C15.4804 10.8946 15.7348 11 16 11H18C18.2652 11 18.5196 11.1054 18.7071 11.2929C18.8946 11.4804 19 11.7348 19 12V19C19 19.2652 18.8946 19.5196 18.7071 19.7071C18.5196 19.8946 18.2652 20 18 20H6C5.73478 20 5.48043 19.8946 5.29289 19.7071C5.10536 19.5196 5 19.2652 5 19V12C5 11.7348 5.10536 11.4804 5.29289 11.2929C5.48043 11.1054 5.73478 11 6 11H8C8.26522 11 8.51957 10.8946 8.70711 10.7071C8.89464 10.5196 9 10.2652 9 10C9 9.73478 8.89464 9.48043 8.70711 9.29289C8.51957 9.10536 8.26522 9 8 9H6C5.20435 9 4.44129 9.31607 3.87868 9.87868C3.31607 10.4413 3 11.2044 3 12V19C3 19.7956 3.31607 20.5587 3.87868 21.1213C4.44129 21.6839 5.20435 22 6 22H18C18.7956 22 19.5587 21.6839 20.1213 21.1213C20.6839 20.5587 21 19.7956 21 19V12C21 11.2044 20.6839 10.4413 20.1213 9.87868C19.5587 9.31607 18.7956 9 18 9Z" fill="black"/>
                                </svg>
                                
                        </div>
                        <span class="feature-name">接收</span>
                    </div>

                </div>

            </div>

            <!-- 3. 底部输入区域 -->
            <div class="chat-input-area">
                <!-- 用下面的 SVG 替换掉原来的加号按钮 -->
                <button id="chat-add-attachment-button" class="chat-action-button">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M9.55563 13.3232L9.43584 13.3123C7.90803 13.1735 7.14412 13.104 6.90146 12.5814C6.65881 12.0588 7.09869 11.4304 7.97846 10.1736L11.5612 5.05544C12.1424 4.22517 12.433 3.81003 12.6836 3.89831C12.9342 3.98658 12.9005 4.4922 12.8331 5.50343L12.6299 8.55194C12.5685 9.47214 12.5379 9.93224 12.8023 10.2419C13.0667 10.5515 13.5259 10.5933 14.4444 10.6768L14.5642 10.6877C16.092 10.8265 16.8559 10.896 17.0985 11.4186C17.3412 11.9412 16.9013 12.5696 16.0215 13.8264L12.4388 18.9446C11.8576 19.7748 11.567 20.19 11.3164 20.1017C11.0658 20.0134 11.0995 19.5078 11.1669 18.4966L11.3701 15.4481C11.4315 14.5279 11.4621 14.0678 11.1977 13.7581C10.9333 13.4485 10.4741 13.4067 9.55563 13.3232Z" fill="#222222"/>
                        <path d="M18.5 4L17 6H19L17.5 8" stroke="#7E869E" stroke-opacity="0.25" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M6.5 16L5 18H7L5.5 20" stroke="#7E869E" stroke-opacity="0.25" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        
                        
                </button>

                <div class="chat-input-wrapper">
                    <input type="text" id="chat-message-input" placeholder="输入消息...">

                    <button id="chat-emoji-button" class="chat-action-button">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path
                                d="M14.66 13.56L10.47 15.06C10.2498 15.1399 10.0646 15.2945 9.94677 15.497C9.82893 15.6994 9.78589 15.9368 9.82517 16.1678C9.86446 16.3987 9.98356 16.6085 10.1617 16.7606C10.3399 16.9127 10.5658 16.9974 10.8 17C10.916 16.9999 11.031 16.9796 11.14 16.94L15.34 15.44C15.467 15.3981 15.5842 15.3312 15.6849 15.2431C15.7855 15.1551 15.8675 15.0478 15.926 14.9276C15.9844 14.8073 16.0182 14.6766 16.0252 14.5431C16.0323 14.4095 16.0125 14.276 15.967 14.1502C15.9215 14.0245 15.8513 13.9092 15.7604 13.8111C15.6696 13.7129 15.56 13.634 15.4382 13.579C15.3163 13.524 15.1847 13.4939 15.051 13.4907C14.9174 13.4874 14.7844 13.511 14.66 13.56ZM10.66 8.56C10.4726 8.37375 10.2192 8.26921 9.955 8.26921C9.69082 8.26921 9.43737 8.37375 9.25 8.56C9.15704 8.65373 9.04644 8.72812 8.92458 8.77889C8.80272 8.82966 8.67202 8.8558 8.54 8.8558C8.40799 8.8558 8.27729 8.82966 8.15543 8.77889C8.03357 8.72812 7.92297 8.65373 7.83 8.56C7.64264 8.37375 7.38919 8.26921 7.125 8.26921C6.86082 8.26921 6.60737 8.37375 6.42 8.56C6.32628 8.65296 6.25188 8.76356 6.20111 8.88542C6.15034 9.00728 6.12421 9.13799 6.12421 9.27C6.12421 9.40201 6.15034 9.53272 6.20111 9.65458C6.25188 9.77644 6.32628 9.88704 6.42 9.98C6.98251 10.5418 7.745 10.8574 8.54 10.8574C9.33501 10.8574 10.0975 10.5418 10.66 9.98C10.7542 9.88405 10.8282 9.77008 10.8773 9.64491C10.9265 9.51974 10.9499 9.38593 10.9462 9.25149C10.9425 9.11706 10.9117 8.98476 10.8556 8.86251C10.7996 8.74026 10.7194 8.63057 10.62 8.54L10.66 8.56ZM17.66 8.56C17.4726 8.37375 17.2192 8.26921 16.955 8.26921C16.6908 8.26921 16.4374 8.37375 16.25 8.56C16.157 8.65373 16.0464 8.72812 15.9246 8.77889C15.8027 8.82966 15.672 8.8558 15.54 8.8558C15.408 8.8558 15.2773 8.82966 15.1554 8.77889C15.0336 8.72812 14.923 8.65373 14.83 8.56C14.6426 8.37375 14.3892 8.26921 14.125 8.26921C13.8608 8.26921 13.6074 8.37375 13.42 8.56C13.3263 8.65296 13.2519 8.76356 13.2011 8.88542C13.1503 9.00728 13.1242 9.13799 13.1242 9.27C13.1242 9.40201 13.1503 9.53272 13.2011 9.65458C13.2519 9.77644 13.3263 9.88704 13.42 9.98C13.9825 10.5418 14.745 10.8574 15.54 10.8574C16.335 10.8574 17.0975 10.5418 17.66 9.98C17.7542 9.88405 17.8282 9.77008 17.8773 9.64491C17.9265 9.51974 17.9499 9.38593 17.9462 9.25149C17.9425 9.11706 17.9117 8.98476 17.8556 8.86251C17.7996 8.74026 17.7194 8.63057 17.62 8.54L17.66 8.56ZM12 2C10.0222 2 8.08879 2.58649 6.4443 3.6853C4.79981 4.78412 3.51809 6.3459 2.76121 8.17317C2.00433 10.0004 1.8063 12.0111 2.19215 13.9509C2.578 15.8907 3.53041 17.6725 4.92894 19.0711C6.32746 20.4696 8.10929 21.422 10.0491 21.8079C11.9889 22.1937 13.9996 21.9957 15.8268 21.2388C17.6541 20.4819 19.2159 19.2002 20.3147 17.5557C21.4135 15.9112 22 13.9778 22 12C22 10.6868 21.7413 9.38642 21.2388 8.17317C20.7363 6.95991 19.9997 5.85752 19.0711 4.92893C18.1425 4.00035 17.0401 3.26375 15.8268 2.7612C14.6136 2.25866 13.3132 2 12 2ZM12 20C10.4178 20 8.87104 19.5308 7.55544 18.6518C6.23985 17.7727 5.21447 16.5233 4.60897 15.0615C4.00347 13.5997 3.84504 11.9911 4.15372 10.4393C4.4624 8.88743 5.22433 7.46197 6.34315 6.34315C7.46197 5.22433 8.88743 4.4624 10.4393 4.15372C11.9911 3.84504 13.5997 4.00346 15.0615 4.60896C16.5233 5.21447 17.7727 6.23984 18.6518 7.55544C19.5308 8.87103 20 10.4177 20 12C20 14.1217 19.1572 16.1566 17.6569 17.6569C16.1566 19.1571 14.1217 20 12 20Z"
                                fill="black" />
                        </svg>
                    </button>
                </div>
                <button id="chat-send-button" class="chat-action-button">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" clip-rule="evenodd" d="M9.93929 12.6464L7.69205 11.8973L7.69205 11.8973L7.69204 11.8973C5.33883 11.1129 4.16223 10.7207 4.16223 9.99997C4.16223 9.27921 5.33884 8.88701 7.69205 8.10261L16.2052 5.26488C17.861 4.71295 18.6889 4.43699 19.1259 4.87401C19.5629 5.31102 19.287 6.13892 18.735 7.79471L15.8973 16.3079L15.8973 16.3079L15.8973 16.3079C15.1129 18.6611 14.7207 19.8377 14 19.8377C13.2792 19.8377 12.887 18.6611 12.1026 16.3079L11.3535 14.0606L15.7071 9.70708C16.0976 9.31656 16.0976 8.68339 15.7071 8.29287C15.3165 7.90234 14.6834 7.90234 14.2928 8.29287L9.93929 12.6464Z" fill="white"/>
                        </svg>
                        
                        
                        
                        
                </button>
            </div>

            <div id="emoji-panel">
                <div class="emoji-panel-header">
                    <button id="add-emoji-btn" class="panel-header-button">添加</button>
                    <button id="multiselect-emoji-btn" class="panel-header-button">多选</button>
                </div>
                <div id="emoji-grid-container">
                </div>

                
            </div>

        </div>

        <button id="scroll-to-bottom-btn">
            <svg width="27" height="31" viewBox="0 0 27 31" fill="none" xmlns="http://www.w3.org/2000/svg">
                <g clip-path="url(#clip0_201_5911)">
                <path d="M24.9049 13.6817L26.191 14.9678C26.7356 15.5123 26.7356 16.3929 26.191 16.9316L14.9349 28.1935C14.3904 28.7381 13.5098 28.7381 12.9711 28.1935L1.7092 16.9316C1.16464 16.3871 1.16464 15.5065 1.7092 14.9678L2.99528 13.6817C3.54562 13.1313 4.44356 13.1429 4.98232 13.7049L11.6329 20.6856V4.03611C11.6329 3.26562 12.2527 2.64575 13.0232 2.64575H14.877C15.6475 2.64575 16.2674 3.26562 16.2674 4.03611V20.6856L22.9179 13.7049C23.4567 13.1371 24.3546 13.1255 24.9049 13.6817Z" fill="black"/>
                </g>
                <defs>
                <clipPath id="clip0_201_5911">
                <rect width="25.9533" height="29.6609" fill="white" transform="translate(0.973877 0.791992)"/>
                </clipPath>
                </defs>
            </svg>
        </button>

        <div id="worldbook-screen" class="screen">
            <div class="settings-header">
                <button id="worldbook-back-button" class="header-text-button">返回</button>
                <h1>世界书</h1>
                <div class="header-actions">
                    <button id="worldbook-multiselect-btn" class="header-button">多选</button>
                </div>
            </div>
            <div class="music-content">
                <button id="add-worldbook-btn" class="add-playlist-button">新建世界书</button>
                <div class="scrollable-list-container">
                    <div id="worldbook-list" class="contact-list" style="margin-top: 20px;">
                    </div>
                </div>
            </div>
        </div>

        


        <!-- === 新增：聊天设置弹出层 (Modal) === -->
        <div id="chat-settings-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content large"> <!-- 使用 .large 类让对话框更宽敞 -->

                <!-- 顶部关闭按钮 -->
                <div class="modal-header">
                    <h2>聊天设置</h2>
                    <button id="chat-settings-close-btn" class="modal-close-button">&times;</button>
                </div>

                <!-- 对话框主体内容 -->
                <div class="modal-body">

                    <!-- 左侧：角色编辑区域 (复用之前的结构) -->
                    <div class="settings-column">
                        <h4>角色信息</h4>
                        <div class="role-switcher">
                            <span class="switch-label active" data-form="ai-settings">Char</span>
                            <label class="switch">
                                <input type="checkbox" id="role-switch-checkbox-settings">
                                <span class="slider round"></span>
                            </label>
                            <span class="switch-label" data-form="user-settings">User</span>
                        </div>

                        <div id="ai-form-settings" class="role-form active">
                            <div class="avatar-uploader">
                                <img src="https://placehold.co/100x100/EFEFEF/AAAAAA?text=AI"
                                    id="ai-avatar-preview-settings" class="avatar-preview">
                                <input type="file" id="ai-avatar-input-settings" class="avatar-input" accept="image/*">
                                <label for="ai-avatar-input-settings" class="avatar-upload-label">上传头像</label>
                            </div>
                            <input type="text" id="ai-name-input-settings" class="form-input" placeholder="角色名">
                            <textarea id="ai-persona-input-settings" class="form-textarea"
                                placeholder="人设..."></textarea>
                        </div>

                        <div id="user-form-settings" class="role-form">
                            <div class="avatar-uploader">
                                <img src="https://placehold.co/100x100/EFEFEF/AAAAAA?text=User"
                                    id="user-avatar-preview-settings" class="avatar-preview">
                                <input type="file" id="user-avatar-input-settings" class="avatar-input"
                                    accept="image/*">
                                <label for="user-avatar-input-settings" class="avatar-upload-label">上传头像</label>
                            </div>
                            <input type="text" id="user-name-input-settings" class="form-input" placeholder="你的名字">
                            <textarea id="user-persona-input-settings" class="form-textarea"
                                placeholder="你的人设..."></textarea>
                        </div>
                        <div class="form-group-inline">
                            <label>上下文记忆:</label>
                            <input type="number" id="context-memory-input-settings" class="form-input" value="10"
                                min="0" max="100">
                        </div>

                        <div class="form-group"> <label>关联世界书 (可多选):</label>
                            <div id="worldbook-multiselect-container" class="multiselect-container">
                            </div>
                        </div>
                    </div>

                    <!-- 右侧：新增的聊天自定义区域 -->
                    <div class="settings-column">
                        <h4>个性化</h4>
                        <div class="form-group">
                            <label>自定义气泡样式 (CSS)</label>
                            <textarea id="bubble-css-input" class="form-textarea code"
                                placeholder=".user-bubble {&#10;  background-color: #007AFF;&#10;}&#10;.ai-bubble {&#10;  background-color: #E5E5EA;&#10;}"></textarea>
                            <button id="restore-bubble-css-btn" class="form-button-secondary small">恢复默认</button>
                        </div>
                        <div class="form-group">
                            <label style="display: flex; justify-content: space-between; align-items: center;">
                                <span>显示聊天头像</span>
                                <label class="switch">
                                    <input type="checkbox" id="show-avatars-toggle" checked>
                                    <span class="slider round"></span>
                                </label>
                            </label>
                            <div class="form-group-inline" style="margin-top: 8px;">
                                <label for="avatar-radius-input">头像圆角值:</label>
                                <input type="text" id="avatar-radius-input" class="form-input" value="50%"
                                    placeholder="e.g., 50% or 8px">
                            </div>
                        </div>

                        <div class="form-group">
                            <label>聊天背景</label>
                            <div class="wallpaper-buttons">
                                <button id="upload-chat-bg-btn" class="form-button-secondary">选择图片</button>
                                <button id="reset-chat-bg-btn" class="form-button-secondary">恢复默认</button>
                            </div>
                        </div>

                        <div class="form-group danger-zone">
                            <label>危险操作</label>
                            <button id="clear-history-btn" class="danger-button">清除聊天记录</button>
                        </div>
                    </div>

                </div>

                <!-- 底部保存按钮 -->
                <div class="modal-footer">
                    <button id="save-chat-settings-btn" class="save-button">保存设置</button>
                </div>

                <!-- 隐藏的文件上传输入框 -->
                <input type="file" id="chat-bg-upload-input" accept="image/*" style="display: none;">
            </div>
        </div>

        <!-- 隐藏的文件选择框，用于导入字体 -->
        <input type="file" id="font-import-input" accept=".ttf,.otf" style="display: none;">

        <div id="add-worldbook-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>新建世界书</h2>
                    <button id="worldbook-modal-close-btn" class="modal-close-button">&times;</button>
                </div>
                <div class="modal-body" style="gap: 15px; padding: 15px 0;">
                    <div class="form-group">
                        <label for="worldbook-name-input">世界书名称</label>
                        <input type="text" id="worldbook-name-input" class="form-input" placeholder="例如：艾泽拉斯编年史">
                    </div>
                    <div class="form-group">
                        <label for="worldbook-content-input">世界书内容</label>
                        <textarea id="worldbook-content-input" class="form-textarea" placeholder="输入关于这个世界的设定..."
                            style="height: 200px;"></textarea>
                    </div>
                </div>
                <div class="modal-footer">
                    <button id="save-worldbook-btn" class="save-button">保存</button>
                </div>
            </div>
        </div>

        <div id="beautify-screen" class="screen">
            <div class="settings-header">
                <button id="beautify-back-button" class="header-text-button">返回</button>
                <h1>美化</h1>
            </div>

            <div class="settings-content">
                <button id="change-icon-button" class="form-button-secondary" style="width: 90%;">更换图标</button>
                <button id="change-clock-button" class="form-button-secondary" style="width: 90%;">更换时钟</button>
            </div>
            
        </div>

        <div id="icon-settings-screen" class="screen">
            <div class="settings-header">
                <button id="icon-settings-back-button" class="header-text-button">返回</button>
                <h1>更换图标</h1>
            </div>
            
            <div class="settings-content">
                <div id="icon-list-container">
                    </div>
            </div>
        </div>

        <div id="clock-settings-screen" class="screen">
            <div class="settings-header">
                <button id="clock-settings-back-button" class="header-text-button">返回</button>
                <h1>更换时钟</h1>
            </div>
        
            <div class="settings-content" style="padding-top: 90px;">
                <div class="form-group">
                    <label for="clock-color-input">时钟颜色 (输入颜色代码或点右侧色块)</label>
                    <div style="display: flex; align-items: center; width: 93%; gap: 10px;">
                        <input type="text" id="clock-color-input" class="form-input" placeholder="#000000">
                        <input type="color" id="clock-color-picker" style="height: 40px; width: 50px; border-radius: 8px; border: 1px solid #d1d1d6; cursor: pointer;">
                    </div>
                </div>
                <div class="form-group">
                    <label style="display: flex; justify-content: space-between; align-items: center;">
                        <span>启用高斯模糊背景</span>
                        <label class="switch">
                            <input type="checkbox" id="clock-blur-toggle">
                            <span class="slider round"></span>
                        </label>
                    </label>
                </div>
            </div>
        </div>


        <div id="transfer-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>发起转账</h2>
                    <button id="transfer-modal-close-btn" class="modal-close-button">&times;</button>
                </div>
                <div class="modal-body" style="gap: 15px; padding: 15px 0;">
                    <div class="form-group">
                        <label for="transfer-amount-input">转账金额 (¥)</label>
                        <input type="number" id="transfer-amount-input" class="form-input" placeholder="0.00">
                    </div>
                    <div class="form-group">
                        <label for="transfer-remark-input">备注</label>
                        <input type="text" id="transfer-remark-input" class="form-input" placeholder="最多20个字">
                    </div>
                </div>
                <div class="modal-footer" style="align-items: center;">
                    <button id="confirm-transfer-btn" class="save-button">确认转账</button>
                </div>
            </div>


        </div>
        <div id="search-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content large">
                <div class="modal-header">
                    <h2>搜索聊天记录</h2>
                    <button id="search-modal-close-btn" class="modal-close-button">&times;</button>
                </div>
                <div class="modal-body" style="padding: 15px;">
                    <input type="search" id="search-input" class="form-input" placeholder="输入关键词..."
                        style="width: 100%; box-sizing: border-box; margin-bottom: 15px;">
                    <div id="search-results-container">
                    </div>
                </div>
            </div>
        </div>
        <div id="invite-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>一起听</h2>
                    <button id="invite-modal-close-btn" class="modal-close-button">&times;</button>
                </div>
                <div class="modal-body" id="invite-contact-list-container">
                </div>
            </div>
        </div>

        <div id="shopper-select-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>选择身份</h2>
                    <button id="shopper-modal-close-btn" class="modal-close-button">&times;</button>
                </div>
                <div class="modal-body" id="shopper-list-container">
                    </div>
            </div>
        </div>

        <div id="add-emoji-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>批量添加表情</h2>
                    <button id="emoji-modal-close-btn" class="modal-close-button">&times;</button>
                </div>
                <div class="modal-body">
                    <p style="font-size: 13px; color: #555; margin-top: 0;">请输入一个或多个图片URL，用英文逗号 (,) 分隔。格式如下：[备注1:url1],[备注2:url2]，注意冒号是英文冒号</p>
                    <textarea id="emoji-urls-textarea" class="form-textarea"
                        placeholder="示例：[好饿:https://i.postimg.cc/8zyrPYVy.png],[咋啦:https://i.postimg.cc/7Y5fdyLZ/47ee5e40ea3.jpg]" style="height: 150px;"></textarea>
                </div>
                <div class="modal-footer">
                    <button id="save-emoji-btn" class="save-button">确认添加</button>
                </div>
            </div>
        </div>
        
        <div id="shop-screen" class="screen">
            <div class="settings-header">
                <button id="shop-back-button" class="header-text-button">返回</button>
                <h1 id="shop-title">7 SHOP</h1> <div class="header-actions">
                    <button id="shopper-avatar-button" class="shopper-avatar-btn">
                        <img id="shopper-avatar-img" src="https://i.postimg.cc/85Qrg485/image.png" alt="当前用户">
                    </button>
                </div>
            </div>
        
            <div id="shop-main-content">
                <div id="shopping-content-panel" class="shop-content-panel active">
                    <div id="shopping-content-panel" class="shop-content-panel active">
                        <div class="category-tabs">
                            <button class="category-tab active" data-category="takeout">外卖</button>
                            <button class="category-tab" data-category="electronics">电子设备</button>
                            <button class="category-tab" data-category="daily">日常用品</button>
                            <button class="category-tab" data-category="sports">运动户外</button>
                            <button class="category-tab" data-category="beautyCare">美妆个护</button>
                            <button class="category-tab" data-category="foodSnacks">食品零食</button>
                        </div>
                    
                        <div id="product-grid" class="product-grid-shop">
                            </div>
                    </div>
                </div>
        
                <div id="my-account-content-panel" class="shop-content-panel">
                    <div class="my-account-list">
                        <div class="my-account-item" id="my-orders-button">
                            <span>我的订单</span>
                            <svg class="chevron-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M9 18L15 12L9 6" stroke="#C7C7CC" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </div>
                        <div class="my-account-item" id="my-cart-button">
                            <span>我的购物车</span>
                            <svg class="chevron-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M9 18L15 12L9 6" stroke="#C7C7CC" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </div>
                    </div>
                </div>
            </div>
        
            <div class="shop-tab-bar">
                <button id="shop-tab-shopping" class="shop-tab-item active" data-panel-id="shopping-content-panel" data-title="7 SHOP">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M19 7H16V6C16 4.93913 15.5786 3.92172 14.8284 3.17157C14.0783 2.42143 13.0609 2 12 2C10.9391 2 9.92172 2.42143 9.17157 3.17157C8.42143 3.92172 8 4.93913 8 6V7H5C4.73478 7 4.48043 7.10536 4.29289 7.29289C4.10536 7.48043 4 7.73478 4 8V19C4 19.7956 4.31607 20.5587 4.87868 21.1213C5.44129 21.6839 6.20435 22 7 22H17C17.7956 22 18.5587 21.6839 19.1213 21.1213C19.6839 20.5587 20 19.7956 20 19V8C20 7.73478 19.8946 7.48043 19.7071 7.29289C19.5196 7.10536 19.2652 7 19 7ZM10 6C10 5.46957 10.2107 4.96086 10.5858 4.58579C10.9609 4.21071 11.4696 4 12 4C12.5304 4 13.0391 4.21071 13.4142 4.58579C13.7893 4.96086 14 5.46957 14 6V7H10V6ZM18 19C18 19.2652 17.8946 19.5196 17.7071 19.7071C17.5196 19.8946 17.2652 20 17 20H7C6.73478 20 6.48043 19.8946 6.29289 19.7071C6.10536 19.5196 6 19.2652 6 19V9H8V10C8 10.2652 8.10536 10.5196 8.29289 10.7071C8.48043 10.8946 8.73478 11 9 11C9.26522 11 9.51957 10.8946 9.70711 10.7071C9.89464 10.5196 10 10.2652 10 10V9H14V10C14 10.2652 14.1054 10.5196 14.2929 10.7071C14.4804 10.8946 14.7348 11 15 11C15.2652 11 15.5196 10.8946 15.7071 10.7071C15.8946 10.5196 16 10.2652 16 10V9H18V19Z" fill="currentColor"/>
                    </svg>
                    <span>购物</span>
                </button>
                <button id="shop-tab-my" class="shop-tab-item" data-panel-id="my-account-content-panel" data-title="我的">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M15.71 12.7099C16.6904 11.9385 17.406 10.8808 17.7572 9.68382C18.1085 8.48684 18.0779 7.21015 17.6698 6.03135C17.2617 4.85255 16.4963 3.83027 15.4801 3.10674C14.4639 2.3832 13.2474 1.99438 12 1.99438C10.7525 1.99438 9.53611 2.3832 8.51993 3.10674C7.50374 3.83027 6.73834 4.85255 6.33021 6.03135C5.92208 7.21015 5.89151 8.48684 6.24276 9.68382C6.59401 10.8808 7.3096 11.9385 8.29 12.7099C6.61007 13.3829 5.14428 14.4992 4.04889 15.9398C2.95349 17.3804 2.26956 19.0912 2.07 20.8899C2.05555 21.0212 2.06711 21.1541 2.10402 21.2809C2.14093 21.4078 2.20246 21.5261 2.28511 21.6292C2.45202 21.8374 2.69478 21.9707 2.96 21.9999C3.22521 22.0291 3.49116 21.9517 3.69932 21.7848C3.90749 21.6179 4.04082 21.3751 4.07 21.1099C4.28958 19.1551 5.22168 17.3497 6.68822 16.0387C8.15475 14.7277 10.0529 14.0029 12.02 14.0029C13.9871 14.0029 15.8852 14.7277 17.3518 16.0387C18.8183 17.3497 19.7504 19.1551 19.97 21.1099C19.9972 21.3556 20.1144 21.5825 20.2991 21.7469C20.4838 21.9113 20.7228 22.0014 20.97 21.9999H21.08C21.3421 21.9697 21.5817 21.8372 21.7466 21.6311C21.9114 21.4251 21.9881 21.1622 21.96 20.8999C21.7595 19.0961 21.0719 17.3809 19.9708 15.9381C18.8698 14.4953 17.3969 13.3794 15.71 12.7099ZM12 11.9999C11.2089 11.9999 10.4355 11.7653 9.77772 11.3258C9.11992 10.8862 8.60723 10.2615 8.30448 9.53061C8.00173 8.79971 7.92251 7.99544 8.07686 7.21952C8.2312 6.4436 8.61216 5.73086 9.17157 5.17145C9.73098 4.61204 10.4437 4.23108 11.2196 4.07674C11.9956 3.9224 12.7998 4.00161 13.5307 4.30436C14.2616 4.60711 14.8863 5.1198 15.3259 5.7776C15.7654 6.4354 16 7.20876 16 7.99988C16 9.06075 15.5786 10.0782 14.8284 10.8283C14.0783 11.5785 13.0609 11.9999 12 11.9999Z" fill="currentColor"/>
                    </svg>
                    <span>我的</span>
                </button>
            </div>
        </div>

        <!-- ▼▼▼ START: 在这里粘贴新的摸鱼App HTML代码 ▼▼▼ -->

<div id="slacking-off-screen" class="screen">
    <!-- 1. 顶部栏 -->
    <div class="settings-header">
        <button id="slacking-off-back-button" class="header-text-button">返回</button>
        <h1 id="slacking-off-title">游戏</h1>
    </div>

    <!-- 2. 中间内容区域 -->
    <div id="slacking-off-main-content">
        <!-- 游戏面板 -->
        <div id="games-content-panel" class="slacking-off-content-panel active">
            <div id="games-content-panel" class="slacking-off-content-panel active">
                <div id="games-grid">
                    </div>
                </div>
            <!-- 这里将来放游戏内容 -->
        </div>

        <!-- 储蓄面板 -->
        <div id="savings-content-panel" class="slacking-off-content-panel">
            <div class="savings-card">
                <button id="apply-unlock-btn" class="apply-unlock-button" style="display: none;">申请解除</button>
                <h2 class="card-title">当前储蓄</h2>
                <div id="balance-display" class="card-balance">¥0.00</div>
            </div>
            <div id="transaction-history-card" class="details-card">
                <span>收支明细</span>
                <svg class="chevron-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M9 18L15 12L9 6" stroke="#C7C7CC" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </div>
            </div>
    </div>

    <!-- 3. 底部标签栏 -->
    <div class="slacking-off-tab-bar">
        <button id="slacking-off-tab-games" class="slacking-off-tab-item active" data-panel-id="games-content-panel" data-title="游戏">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M12.75 8.75H20C21.6569 8.75 23 10.0931 23 11.75V17.75C23 19.4069 21.6569 20.75 20 20.75H4C2.34315 20.75 1 19.4069 1 17.75V11.75C1 10.0931 2.34315 8.75 4 8.75H11.25V6.75C11.25 5.7835 12.0335 5 13 5C13.1381 5 13.25 4.88807 13.25 4.75C13.25 4.33579 13.5858 4 14 4C14.4142 4 14.75 4.33579 14.75 4.75C14.7337 5.70641 13.9565 6.4747 13 6.48C12.9301 6.47978 12.8633 6.50884 12.8158 6.56015C12.7683 6.61145 12.7444 6.6803 12.75 6.75V8.75ZM20 19.25C20.8284 19.25 21.5 18.5784 21.5 17.75V11.75C21.4837 10.9333 20.8169 10.2798 20 10.28H4C3.18315 10.2798 2.51634 10.9333 2.5 11.75V17.75C2.5 18.5784 3.17157 19.25 4 19.25H20Z" fill="currentColor"/>
                <path d="M9 14.02H7.75V12.75C7.75 12.3358 7.41421 12 7 12C6.58579 12 6.25 12.3358 6.25 12.75V14H5C4.58579 14 4.25 14.3358 4.25 14.75C4.25 15.1642 4.58579 15.5 5 15.5H6.25V16.75C6.25 17.1642 6.58579 17.5 7 17.5C7.41421 17.5 7.75 17.1642 7.75 16.75V15.52H9C9.41421 15.52 9.75 15.1842 9.75 14.77C9.75 14.3558 9.41421 14.02 9 14.02Z" fill="currentColor"/>
                <path d="M17 12.77C17 13.3223 16.5523 13.77 16 13.77C15.4477 13.77 15 13.3223 15 12.77C15 12.2177 15.4477 11.77 16 11.77C16.5523 11.77 17 12.2177 17 12.77Z" fill="currentColor"/>
                <path d="M17 16.77C17 17.3223 16.5523 17.77 16 17.77C15.4477 17.77 15 17.3223 15 16.77C15 16.2177 15.4477 15.77 16 15.77C16.5523 15.77 17 16.2177 17 16.77Z" fill="currentColor"/>
                <path d="M19 14.77C19 15.3223 18.5523 15.77 18 15.77C17.4477 15.77 17 15.3223 17 14.77C17 14.2177 17.4477 13.77 18 13.77C18.5523 13.77 19 14.2177 19 14.77Z" fill="currentColor"/>
                <path d="M15 14.77C15 15.3223 14.5523 15.77 14 15.77C13.4477 15.77 13 15.3223 13 14.77C13 14.2177 13.4477 13.77 14 13.77C14.5523 13.77 15 14.2177 15 14.77Z" fill="currentColor"/>
            </svg>
            <span>游戏</span>
        </button>
        <button id="slacking-off-tab-savings" class="slacking-off-tab-item" data-panel-id="savings-content-panel" data-title="储蓄">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M19.58 16.71L19.82 17.85C20.0474 18.8356 19.8229 19.8713 19.2077 20.6742C18.5924 21.4771 17.6508 21.9633 16.64 22H7.36C6.34917 21.9633 5.40757 21.4771 4.79235 20.6742C4.17713 19.8713 3.95257 18.8356 4.18 17.85L4.42 16.71C4.69604 15.1668 6.02262 14.0327 7.59 14H16.41C17.9774 14.0327 19.304 15.1668 19.58 16.71ZM16.64 20.49C17.1478 20.4841 17.6257 20.2489 17.94 19.85V19.86C18.3257 19.3762 18.476 18.7458 18.35 18.14L18.11 17C17.9768 16.1552 17.2646 15.5226 16.41 15.49H7.59C6.73537 15.5226 6.02317 16.1552 5.89 17L5.65 18.14C5.52716 18.7426 5.67727 19.3687 6.06 19.85C6.37434 20.2489 6.85221 20.4841 7.36 20.49H16.64Z" fill="currentColor"/>
                <path fill-rule="evenodd" clip-rule="evenodd" d="M12.5 12H11.5C9.29085 12 7.49998 10.2092 7.49998 8.00001V5.36001C7.49732 4.46807 7.85046 3.61189 8.48116 2.98119C9.11186 2.35049 9.96804 1.99735 10.86 2.00001H13.14C14.0319 1.99735 14.8881 2.35049 15.5188 2.98119C16.1495 3.61189 16.5027 4.46807 16.5 5.36001V8.00001C16.5 10.2092 14.7091 12 12.5 12ZM10.86 3.50002C9.83274 3.50002 8.99999 4.33277 8.99999 5.36001V8.00001C8.99999 9.38073 10.1193 10.5 11.5 10.5H12.5C13.8807 10.5 15 9.38073 15 8.00001V5.36001C15 4.86671 14.804 4.39361 14.4552 4.0448C14.1064 3.69598 13.6333 3.50002 13.14 3.50002H10.86Z" fill="currentColor"/>
            </svg>
            <span>储蓄</span>
        </button>
    </div>
</div>

<div id="transactions-screen" class="screen">
    <div class="settings-header">
        <button id="transactions-back-button" class="header-text-button">返回</button>
        <h1>收支明细</h1>
    </div>
    <div id="transactions-list-container" class="transactions-page-content">
        </div>
</div>

<div id="number-guess-modal" class="modal-overlay" style="display: none; opacity: 0;">
    <div class="modal-content" style="transform: scale(0.95);">
        <div class="modal-header">
            <h2>数字大师</h2>
        </div>
        <div class="modal-body" style="text-align: center;">
            <p style="margin: 0 0 20px 0; color: #555;">从 1, 2, 3 中选择一个数字</p>
            <div class="game-choices">
                <button class="game-choice-btn" data-choice="1">1</button>
                <button class="game-choice-btn" data-choice="2">2</button>
                <button class="game-choice-btn" data-choice="3">3</button>
            </div>
        </div>
    </div>
</div>

<div id="coin-flip-modal" class="modal-overlay" style="display: none; opacity: 0;">
    <div class="modal-content" style="transform: scale(0.95);">
        <div class="modal-header">
            <h2>幸运硬币</h2>
        </div>
        <div class="modal-body" style="text-align: center;">
            <p style="margin: 0 0 20px 0; color: #555;">猜猜硬币是正面还是反面？</p>
            <div class="game-choices">
                <button class="game-choice-btn" data-choice="heads">正面</button>
                <button class="game-choice-btn" data-choice="tails">反面</button>
            </div>
        </div>
    </div>
</div>

<!-- ▼▼▼ START: 【新增】买彩票游戏弹窗 ▼▼▼ -->
<div id="lottery-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h2>买彩票</h2>
            <button class="modal-close-button">&times;</button>
        </div>
        <div class="modal-body" style="text-align: center;">
            <p style="margin: 0 0 20px 0; color: #555;">请选择您要购买的彩票金额：</p>
            <div class="game-choices" style="flex-wrap: wrap; justify-content: center;">
                <button class="game-choice-btn" data-cost="10">¥10</button>
                <button class="game-choice-btn" data-cost="20">¥20</button>
                <button class="game-choice-btn" data-cost="50">¥50</button>
                <button class="game-choice-btn" data-cost="100">¥100</button>
                <button class="game-choice-btn" data-cost="200">¥200</button>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ END: 【新增】买彩票游戏弹窗 ▲▲▲ -->

<div id="blacklist-modal" class="modal-overlay" style="display: none; opacity: 0;">
    <div class="modal-content" style="transform: scale(0.95);">
        <div class="modal-header">
            <h2>系统通知</h2>
        </div>
        <div class="modal-body" style="text-align: center; padding: 20px 15px;">
            <p style="margin: 0 0 25px 0; color: #333; line-height: 1.5;">
                您因欠款已被七七银行拉黑，请联系七七总裁申请解除限制。
            </p>
            <button id="go-to-savings-btn" class="save-button">去储蓄页面申请解除</button>
        </div>
    </div>
</div>

<div id="unlock-modal" class="modal-overlay" style="display: none; opacity: 0;">
    <div class="modal-content" style="transform: scale(0.95);">
        <div class="modal-header">
            <h2>申请解除限制</h2>
            <button id="unlock-modal-close-btn" class="modal-close-button">&times;</button>
        </div>
        <div class="modal-body" style="gap: 15px; padding: 15px 0;">
            <div class="form-group">
                <label for="unlock-code-input">请输入解锁码</label>
                <input type="text" id="unlock-code-input" class="form-input" placeholder="输入七七总裁给的解锁码">
            </div>
        </div>
        <div class="modal-footer">
            <button id="confirm-unlock-btn" class="save-button">确认解锁</button>
        </div>
    </div>
</div>

<div id="gacha-post-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h2>创建新分享</h2>
            <button id="gacha-post-modal-close-btn" class="modal-close-button">&times;</button>
        </div>
        <div class="modal-body">
            <textarea id="gacha-post-text-input" class="form-textarea" placeholder="分享你的想法..." style="height: 120px;"></textarea>
            <input type="text" id="gacha-post-image-desc-input" class="form-input" placeholder="[可选] 为图片添加文字描述...">
        </div>
        <div class="modal-footer">
            <button id="gacha-confirm-post-btn" class="save-button">确认分享</button>
        </div>
    </div>
</div>

<div id="visibility-settings-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h2>设置帖子可见范围</h2>
            <button id="visibility-modal-close-btn" class="modal-close-button">&times;</button>
        </div>
        <div class="modal-body" id="worldbook-visibility-list" style="max-height: 300px; overflow-y: auto; padding: 15px;">
            </div>
        <div class="modal-footer">
            <button id="save-visibility-btn" class="save-button">保存设置</button>
        </div>
    </div>
</div>

<div id="summon-ai-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h2>选择要召唤的AI</h2>
            <button id="summon-ai-modal-close-btn" class="modal-close-button">&times;</button>
        </div>
        <div class="modal-body" id="summon-ai-list-container" style="max-height: 400px; overflow-y: auto; padding: 10px 0;">
            </div>
    </div>
</div>


        <div id="cart-screen" class="screen">
            <div class="settings-header">
                <button id="cart-back-button" class="header-text-button">返回</button>
                <h1>我的购物车</h1>
            </div>
            <div id="cart-content" class="cart-page-content">
                <div id="cart-items-container">
                    </div>
                <div class="cart-footer">
                    <button id="select-recipient-btn" class="select-recipient-btn">收货人: <span id="recipient-name-display">未选择</span></button>
                    <button id="confirm-purchase-btn" class="save-button">确认购买</button>
                </div>
            </div>
        </div>
        
        <div id="orders-screen" class="screen">
            <div class="settings-header">
                <button id="orders-back-button" class="header-text-button">返回</button>
                <h1>我的订单</h1>
            </div>
            <div id="orders-list-container" class="orders-page-content">
                </div>
        </div>
        
        <div id="recipient-select-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>选择收货人</h2>
                    <button id="recipient-modal-close-btn" class="modal-close-button">&times;</button>
                </div>
                <div class="modal-body" id="recipient-list-container">
                    </div>
            </div>
        </div>

        <div id="gacha-screen" class="screen">
            <!-- 1. 顶部栏 -->
            <div class="settings-header">
                <button id="gacha-back-button" class="header-text-button">返回</button>
                <h1 id="gacha-title">SHARE</h1>
                <div class="header-actions">
                    <button id="gacha-avatar-button" class="shopper-avatar-btn">
                        <img id="gacha-avatar-img" src="https://i.postimg.cc/85Qrg485/image.png" alt="当前身份">
                    </button>
                </div>
                <!-- 这里可以留空，或者放其他按钮 -->
            </div>
        
            <!-- 2. 中间内容区域 -->
            <div id="gacha-main-content">
                <!-- “SHARE” 面板 -->
                <div id="share-content-panel" class="gacha-content-panel active">
                    <div id="gacha-posts-container">
                        </div>
                </div>
        
                <!-- “FORUM” 面板 -->
                <div id="forum-content-panel" class="gacha-content-panel">
                    <!-- 在这里放入 FORUM 页面的具体内容 -->
                    <p style="text-align: center; padding-top: 100px;">FORUM待开发</p>
                </div>
            </div>
        
            <!-- 3. 底部标签栏 -->
            <div class="gacha-tab-bar">
                <button id="gacha-tab-share" class="gacha-tab-item active" data-panel-id="share-content-panel" data-title="SHARE">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M10 8H16C16.2652 8 16.5196 7.89464 16.7071 7.70711C16.8946 7.51957 17 7.26522 17 7C17 6.73478 16.8946 6.48043 16.7071 6.29289C16.5196 6.10536 16.2652 6 16 6H10C9.73478 6 9.48043 6.10536 9.29289 6.29289C9.10536 6.48043 9 6.73478 9 7C9 7.26522 9.10536 7.51957 9.29289 7.70711C9.48043 7.89464 9.73478 8 10 8ZM8 12H16C16.2652 12 16.5196 11.8946 16.7071 11.7071C16.8946 11.5196 17 11.2652 17 11C17 10.7348 16.8946 10.4804 16.7071 10.2929C16.5196 10.1054 16.2652 10 16 10H8C7.73478 10 7.48043 10.1054 7.29289 10.2929C7.10536 10.4804 7 10.7348 7 11C7 11.2652 7.10536 11.5196 7.29289 11.7071C7.48043 11.8946 7.73478 12 8 12ZM8 16H16C16.2652 16 16.5196 15.8946 16.7071 15.7071C16.8946 15.5196 17 15.2652 17 15C17 14.7348 16.8946 14.4804 16.7071 14.2929C16.5196 14.1054 16.2652 14 16 14H8C7.73478 14 7.48043 14.1054 7.29289 14.2929C7.10536 14.4804 7 14.7348 7 15C7 15.2652 7.10536 15.5196 7.29289 15.7071C7.48043 15.8946 7.73478 16 8 16ZM20 2H4C3.73478 2 3.48043 2.10536 3.29289 2.29289C3.10536 2.48043 3 2.73478 3 3V21C3 21.1857 3.05171 21.3678 3.14935 21.5257C3.24698 21.6837 3.38668 21.8114 3.55279 21.8944C3.71889 21.9775 3.90484 22.0126 4.08981 21.996C4.27477 21.9793 4.45143 21.9114 4.6 21.8L6.67 20.25L8.73 21.8C8.9031 21.9298 9.11363 22 9.33 22C9.54637 22 9.7569 21.9298 9.93 21.8L12 20.25L14.07 21.8C14.2431 21.9298 14.4536 22 14.67 22C14.8864 22 15.0969 21.9298 15.27 21.8L17.33 20.25L19.4 21.8C19.5493 21.9113 19.7267 21.9786 19.9122 21.9945C20.0977 22.0104 20.284 21.9742 20.45 21.89C20.6149 21.8069 20.7536 21.6798 20.8507 21.5227C20.9478 21.3656 20.9994 21.1847 21 21V3C21 2.73478 20.8946 2.48043 20.7071 2.29289C20.5196 2.10536 20.2652 2 20 2ZM19 19L17.93 18.2C17.7569 18.0702 17.5464 18 17.33 18C17.1136 18 16.9031 18.0702 16.73 18.2L14.67 19.75L12.6 18.2C12.4269 18.0702 12.2164 18 12 18C11.7836 18 11.5731 18.0702 11.4 18.2L9.33 19.75L7.27 18.2C7.0969 18.0702 6.88637 18 6.67 18C6.45363 18 6.2431 18.0702 6.07 18.2L5 19V4H19V19Z" fill="currentColor"/>
                    </svg>
                    <span>SHARE</span>
                </button>
                <button id="gacha-tab-forum" class="gacha-tab-item" data-panel-id="forum-content-panel" data-title="FORUM">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M8.99175 7.69049C8.46132 7.69049 7.95261 7.9012 7.57754 8.27627C7.20247 8.65135 6.99175 9.16006 6.99175 9.69049C6.99175 10.2209 7.20247 10.7296 7.57754 11.1047C7.95261 11.4798 8.46132 11.6905 8.99175 11.6905L9.00689 11.689V12.1904C9.00663 12.323 8.95386 12.45 8.86015 12.5437C8.76644 12.6374 8.63942 12.6902 8.50689 12.6904C8.24167 12.6904 7.98732 12.7958 7.79978 12.9833C7.61225 13.1709 7.50689 13.4252 7.50689 13.6904C7.50689 13.9556 7.61225 14.21 7.79978 14.3975C7.98732 14.5851 8.24167 14.6904 8.50689 14.6904C9.16974 14.6898 9.80527 14.4262 10.274 13.9575C10.7427 13.4888 11.0063 12.8533 11.0069 12.1904V9.69043C11.0009 9.63954 10.9907 9.58923 10.9766 9.54C10.9402 9.03814 10.7154 8.56861 10.3473 8.22558C9.97914 7.88255 9.49492 7.6914 8.99175 7.69049ZM11.9913 1.00195C9.4822 1.002 7.06899 1.96564 5.25002 3.69386C3.43105 5.42207 2.34527 7.78286 2.21693 10.2886C2.08858 12.7944 2.92747 15.2538 4.56034 17.1588C6.19321 19.0638 8.49534 20.269 10.9913 20.5254V22.002C10.9911 22.1537 11.0255 22.3035 11.0919 22.4399C11.1583 22.5763 11.2548 22.6959 11.3743 22.7894C11.4937 22.883 11.6329 22.9481 11.7812 22.9799C11.9296 23.0116 12.0833 23.0092 12.2305 22.9727C14.7507 22.349 17.0151 20.9582 18.7109 18.9923C20.4067 17.0264 21.4502 14.5825 21.6973 11.998C21.8775 10.6203 21.7606 9.21995 21.3546 7.89116C20.9485 6.56236 20.2627 5.3359 19.3432 4.2942C18.4237 3.25251 17.2919 2.41973 16.0238 1.85186C14.7557 1.28398 13.3807 0.994169 11.9913 1.0019V1.00195ZM19.7091 11.7822C19.5255 13.7382 18.7994 15.604 17.6125 17.1695C16.4256 18.7349 14.8251 19.9378 12.9913 20.6426V19.5762C12.9914 19.4448 12.9655 19.3148 12.9153 19.1934C12.8651 19.072 12.7914 18.9618 12.6986 18.8689C12.6057 18.776 12.4954 18.7024 12.3741 18.6521C12.2527 18.6019 12.1226 18.5761 11.9913 18.5762C10.4512 18.576 8.94572 18.1191 7.66526 17.2633C6.38481 16.4075 5.38687 15.1913 4.79763 13.7684C4.20839 12.3455 4.05432 10.7798 4.3549 9.26927C4.65548 7.75878 5.3972 6.37134 6.48629 5.28239C7.57538 4.19344 8.96291 3.45189 10.4734 3.1515C11.984 2.85112 13.5496 3.00538 14.9725 3.5948C16.3953 4.18422 17.6115 5.18231 18.4671 6.46287C19.3227 7.74344 19.7794 9.24895 19.7794 10.7891C19.7767 11.1213 19.7532 11.453 19.7091 11.7822ZM14.9918 7.69049C14.4613 7.69049 13.9526 7.9012 13.5775 8.27627C13.2025 8.65135 12.9918 9.16006 12.9918 9.69049C12.9918 10.2209 13.2025 10.7296 13.5775 11.1047C13.9526 11.4798 14.4613 11.6905 14.9918 11.6905L15.0069 11.689V12.1904C15.0066 12.323 14.9539 12.45 14.8602 12.5437C14.7664 12.6374 14.6394 12.6902 14.5069 12.6904C14.2417 12.6904 13.9873 12.7958 13.7998 12.9833C13.6122 13.1709 13.5069 13.4252 13.5069 13.6904C13.5069 13.9556 13.6122 14.21 13.7998 14.3975C13.9873 14.5851 14.2417 14.6904 14.5069 14.6904C15.1697 14.6898 15.8053 14.4262 16.274 13.9575C16.7427 13.4888 17.0063 12.8533 17.0069 12.1904V9.69043C17.0009 9.63954 16.9907 9.58923 16.9766 9.54C16.9402 9.03814 16.7154 8.56861 16.3473 8.22558C15.9791 7.88255 15.4949 7.6914 14.9918 7.69049Z" fill="currentColor"/>
                    </svg>
                    <span>FORUM</span>
                </button>
               
            </div>
            <button id="gacha-new-post-btn" class="floating-action-button">
                <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path fill-rule="evenodd" clip-rule="evenodd" d="M4.5174 2.70926C2.88281 2.70926 1.55772 4.03435 1.55772 5.66893V15.0153C1.55772 16.6498 2.88281 17.9749 4.5174 17.9749H13.8637C15.4983 17.9749 16.8234 16.6498 16.8234 15.0153V10.3421C16.8234 9.91195 17.1721 9.56324 17.6023 9.56324C18.0324 9.56324 18.3811 9.91195 18.3811 10.3421V15.0153C18.3811 17.5102 16.3586 19.5327 13.8637 19.5327H4.5174C2.02251 19.5327 0 17.5102 0 15.0153V5.66893C0 3.17404 2.02251 1.15154 4.5174 1.15154H9.81365C10.2438 1.15154 10.5925 1.50024 10.5925 1.9304C10.5925 2.36055 10.2438 2.70926 9.81365 2.70926H4.5174Z" fill="white"/>
                    <path fill-rule="evenodd" clip-rule="evenodd" d="M5.02381 11.5474C5.0255 11.3431 5.10742 11.1476 5.2519 11.0031L15.484 0.771034C15.9098 0.345203 16.6002 0.345204 17.026 0.771034L19.229 2.97399C19.6548 3.39982 19.6548 4.09022 19.229 4.51605L8.99692 14.7481C8.85243 14.8926 8.65695 14.9745 8.45262 14.9762L5.78705 14.9982C5.57825 15 5.37751 14.9178 5.22987 14.7701C5.08223 14.6225 5.00005 14.4218 5.00177 14.213L5.02381 11.5474ZM6.57884 11.8791L6.56599 13.434L8.12091 13.4212L17.7971 3.74502L16.255 2.20295L6.57884 11.8791Z" fill="white"/>
                    </svg>
                    
                    
                    
            </button>
        </div>

    </div>

    <script>

        // =================================================
        // 第一部分：所有 const 和 let 变量声明，必须放在最前面
        // =================================================
        // === START: SHOPMALL 购物流程 JS (VARIABLES) ===

// ▼▼▼ START: GACHA App 帖子功能完整脚本 (V14 - 最终修复版) ▼▼▼
const lotteryModal = document.getElementById('lottery-modal');
const darkModeToggle = document.getElementById('toggle-dark-mode');
// --- 1. 变量声明 ---
const gachaAppIcon = document.getElementById('gacha-app-icon');
const gachaScreen = document.getElementById('gacha-screen');
const gachaBackButton = document.getElementById('gacha-back-button');
const gachaTabBar = document.querySelector('.gacha-tab-bar');
const gachaTitle = document.getElementById('gacha-title');
const shareContentPanel = document.getElementById('share-content-panel');
const postsContainer = document.getElementById('gacha-posts-container');
const gachaAvatarButton = document.getElementById('gacha-avatar-button');
const gachaAvatarImg = document.getElementById('gacha-avatar-img');
const newPostBtn = document.getElementById('gacha-new-post-btn');
const postModal = document.getElementById('gacha-post-modal');
const postModalCloseBtn = document.getElementById('gacha-post-modal-close-btn');
const postTextInput = document.getElementById('gacha-post-text-input');
const postImageDescInput = document.getElementById('gacha-post-image-desc-input');
const confirmPostBtn = document.getElementById('gacha-confirm-post-btn');
const visibilityModal = document.getElementById('visibility-settings-modal');
const visibilityModalCloseBtn = document.getElementById('visibility-modal-close-btn');
const worldbookVisibilityList = document.getElementById('worldbook-visibility-list');
const saveVisibilityBtn = document.getElementById('save-visibility-btn');
const summonAiModal = document.getElementById('summon-ai-modal');
const summonAiModalCloseBtn = document.getElementById('summon-ai-modal-close-btn');
const summonAiListContainer = document.getElementById('summon-ai-list-container');

let currentGachaIdentity = null;
let currentPostIdForVisibility = null;
let currentPostIdForSummoning = null;


const transactionHistoryCard = document.getElementById('transaction-history-card');
const transactionsScreen = document.getElementById('transactions-screen');
const transactionsBackButton = document.getElementById('transactions-back-button');
const transactionsListContainer = document.getElementById('transactions-list-container');
const blacklistModal = document.getElementById('blacklist-modal');
const goToSavingsBtn = document.getElementById('go-to-savings-btn');
const unlockModal = document.getElementById('unlock-modal');
const unlockModalCloseBtn = document.getElementById('unlock-modal-close-btn');
const applyUnlockBtn = document.getElementById('apply-unlock-btn');
const unlockCodeInput = document.getElementById('unlock-code-input');
const confirmUnlockBtn = document.getElementById('confirm-unlock-btn');
const numberGuessModal = document.getElementById('number-guess-modal');
const coinFlipModal = document.getElementById('coin-flip-modal');
const gamesGrid = document.getElementById('games-grid');
const balanceDisplay = document.getElementById('balance-display');
const slackingOffAppIcon = document.getElementById('GAME-app-icon');
const slackingOffScreen = document.getElementById('slacking-off-screen');
const slackingOffBackButton = document.getElementById('slacking-off-back-button');
const slackingOffTabBar = document.querySelector('.slacking-off-tab-bar');
const slackingOffTitle = document.getElementById('slacking-off-title');
// ▲▲▲ 摸鱼App变量声明粘贴结束 ▲▲▲
let shoppingCart = []; // 内存中的购物车数组
let currentRecipient = null; // 当前选中的收货人
const myOrdersButton = document.getElementById('my-orders-button');
const myCartButton = document.getElementById('my-cart-button');

const cartScreen = document.getElementById('cart-screen');
const cartBackButton = document.getElementById('cart-back-button');
const cartItemsContainer = document.getElementById('cart-items-container');
const selectRecipientBtn = document.getElementById('select-recipient-btn');
const recipientNameDisplay = document.getElementById('recipient-name-display');
const confirmPurchaseBtn = document.getElementById('confirm-purchase-btn');

const ordersScreen = document.getElementById('orders-screen');
const ordersBackButton = document.getElementById('orders-back-button');
const ordersListContainer = document.getElementById('orders-list-container');

const recipientSelectModal = document.getElementById('recipient-select-modal');
const recipientModalCloseBtn = document.getElementById('recipient-modal-close-btn');
const recipientListContainer = document.getElementById('recipient-list-container');
// === END: SHOPMALL 购物流程 JS (VARIABLES) ===
// === START: SHOPMALL 商品购物 JS (VARIABLES) ===
const categoryTabsContainer = document.querySelector('.category-tabs');
const productGrid = document.getElementById('product-grid');
// === END: SHOPMALL 商品购物 JS (VARIABLES) ===
        // === START: SHOPMALL SCRIPT (VARIABLES) ===
        const shopAppIcon = document.getElementById('SHOP-app-icon');
        const shopScreen = document.getElementById('shop-screen');
        const shopBackButton = document.getElementById('shop-back-button');
        // === END: SHOPMALL SCRIPT (VARIABLES) ===
        // === START: 七袋购物身份 JS (VARIABLES) ===
let currentShopper = null; // 用于存储当前选择的用户对象
const shopperAvatarButton = document.getElementById('shopper-avatar-button');
const shopperAvatarImg = document.getElementById('shopper-avatar-img');
const shopperSelectModal = document.getElementById('shopper-select-modal');
const shopperModalCloseBtn = document.getElementById('shopper-modal-close-btn');
const shopperListContainer = document.getElementById('shopper-list-container');
// === END: 七袋购物身份 JS (VARIABLES) ===
// === START: SHOPMALL 标签页 JS (VARIABLES) ===
const shopTabBar = document.querySelector('.shop-tab-bar');
const shopTabItems = document.querySelectorAll('.shop-tab-item');
const shopContentPanels = document.querySelectorAll('.shop-content-panel');
const shopTitle = document.getElementById('shop-title');
// === END: SHOPMALL 标签页 JS (VARIABLES) ===
        // === 新增：获取时钟高斯模糊开关和时钟容器 ===
const clockBlurToggle = document.getElementById('clock-blur-toggle');
const clockContainer = document.querySelector('.clock');
// === 新增：获取时钟设置相关元素 ===
const changeClockButton = document.getElementById('change-clock-button');
const clockSettingsScreen = document.getElementById('clock-settings-screen');
const clockSettingsBackButton = document.getElementById('clock-settings-back-button');
const clockColorInput = document.getElementById('clock-color-input');
const clockColorPicker = document.getElementById('clock-color-picker');
const clockElements = document.querySelectorAll('.clock span');
        // === 新增：获取美化App相关元素 ===
        const beautifyAppIcon = document.getElementById('beautify-app-icon');
        const beautifyScreen = document.getElementById('beautify-screen');
        const beautifyBackButton = document.getElementById('beautify-back-button');
        // === 新增：获取更换图标界面相关元素 ===
const changeIconButton = document.getElementById('change-icon-button');
const iconSettingsScreen = document.getElementById('icon-settings-screen');
const iconSettingsBackButton = document.getElementById('icon-settings-back-button');

        const multiselectEmojiBtn = document.getElementById('multiselect-emoji-btn');
        let isEmojiDeleteMode = false; // 新增：用于跟踪表情包是否处于删除模式
        // === 新增：页面导航的脚本 ===
        const audioPlayer = document.getElementById('audio-player');
        const wallpaperUploadInput = document.getElementById('wallpaper-upload-input');
        const phoneFrame = document.querySelector('.phone-frame');
        const homeScreen = document.getElementById('home-screen');
        const settingsScreen = document.getElementById('settings-screen');
        const settingsAppIcon = document.getElementById('settings-app-icon');
        const backButton = document.getElementById('back-button');
        const saveSettingsButton = document.getElementById('save-settings-button');
        const musicAppIcon = document.getElementById('music-app-icon');
        const musicScreen = document.getElementById('music-screen');
        const musicBackButton = document.getElementById('music-back-button');

        // === 新增：歌单多选功能所需元素 ===
        const playlistMultiselectBtn = document.getElementById('playlist-multiselect-btn');
        let isPlaylistDeleteMode = false; // 用于跟踪是否处于删除模式

        const messagesAppIcon = document.getElementById('messages-app-icon');
        const messagesScreen = document.getElementById('messages-screen');
        const messagesBackButton = document.getElementById('messages-back-button');


        // === 新增：添加联系人弹出层所需的所有元素 ===
        const addContactModal = document.getElementById('add-contact-modal');
        const messagesAddBtn = document.getElementById('messages-add-btn');
        const modalCloseBtn = document.getElementById('modal-close-btn');
        const roleSwitchCheckbox = document.getElementById('role-switch-checkbox');
        const switchLabels = document.querySelectorAll('.switch-label');
        const aiForm = document.getElementById('ai-form');
        const userForm = document.getElementById('user-form');
        const contactList = document.getElementById('contact-list');

        // 表单内部元素
        const aiAvatarPreview = document.getElementById('ai-avatar-preview');
        const aiAvatarInput = document.getElementById('ai-avatar-input');
        const aiNameInput = document.getElementById('ai-name-input');
        const aiPersonaInput = document.getElementById('ai-persona-input');

        const userAvatarPreview = document.getElementById('user-avatar-preview');
        const userAvatarInput = document.getElementById('user-avatar-input');
        const userNameInput = document.getElementById('user-name-input');
        const userPersonaInput = document.getElementById('user-persona-input');

        const contextMemoryInput = document.getElementById('context-memory-input');
        const saveContactBtn = document.getElementById('save-contact-btn');
        const messagesMultiselectBtn = document.getElementById('messages-multiselect-btn');
        const loadMoreMessagesBtn = document.getElementById('load-more-messages-btn');

        // === 新增：聊天界面所需的所有元素 ===
        const chatScreen = document.getElementById('chat-screen');
        const chatBackButton = document.getElementById('chat-back-button');
        const chatContactName = document.getElementById('chat-contact-name');
        const chatMessagesContainer = document.getElementById('chat-messages-container');
        const chatMessageInput = document.getElementById('chat-message-input');
        const chatSendButton = document.getElementById('chat-send-button');
        let isAiReplying = false;


        // === 新增：聊天设置弹出层所需的所有元素 ===
        const chatSettingsModal = document.getElementById('chat-settings-modal');
        const chatSettingsButton = document.getElementById('chat-settings-button');
        const chatSettingsCloseBtn = document.getElementById('chat-settings-close-btn');
        const saveChatSettingsBtn = document.getElementById('save-chat-settings-btn');

        // 角色编辑 (在设置弹窗内)
        const roleSwitchCheckboxSettings = document.getElementById('role-switch-checkbox-settings');
        const aiFormSettings = document.getElementById('ai-form-settings');
        const userFormSettings = document.getElementById('user-form-settings');
        const aiAvatarPreviewSettings = document.getElementById('ai-avatar-preview-settings');
        const aiAvatarInputSettings = document.getElementById('ai-avatar-input-settings');
        const aiNameInputSettings = document.getElementById('ai-name-input-settings');
        const aiPersonaInputSettings = document.getElementById('ai-persona-input-settings');
        const userAvatarPreviewSettings = document.getElementById('user-avatar-preview-settings');
        const userAvatarInputSettings = document.getElementById('user-avatar-input-settings');
        const userNameInputSettings = document.getElementById('user-name-input-settings');
        const userPersonaInputSettings = document.getElementById('user-persona-input-settings');
        const contextMemoryInputSettings = document.getElementById('context-memory-input-settings');

        // 个性化设置
        const bubbleCssInput = document.getElementById('bubble-css-input');
        const restoreBubbleCssBtn = document.getElementById('restore-bubble-css-btn');
        const uploadChatBgBtn = document.getElementById('upload-chat-bg-btn');
        const resetChatBgBtn = document.getElementById('reset-chat-bg-btn');
        const chatBgUploadInput = document.getElementById('chat-bg-upload-input');
        const clearHistoryBtn = document.getElementById('clear-history-btn');
        const customBubbleStyles = document.getElementById('custom-bubble-styles');

        const fullscreenToggle = document.getElementById('toggle-frame-visibility');
        const bodyElement = document.body; // 获取 body 元素


        const worldbookAppIcon = document.getElementById('worldbook-app-icon');
        const worldbookBackButton = document.getElementById('worldbook-back-button');
        const addWorldbookBtn = document.getElementById('add-worldbook-btn');
        const addWorldbookModal = document.getElementById('add-worldbook-modal');
        const worldbookModalCloseBtn = document.getElementById('worldbook-modal-close-btn');
        const saveWorldbookBtn = document.getElementById('save-worldbook-btn');
        const worldbookNameInput = document.getElementById('worldbook-name-input');
        const worldbookContentInput = document.getElementById('worldbook-content-input');
        const worldbookListContainer = document.getElementById('worldbook-list');
        const worldbookMultiselectBtn = document.getElementById('worldbook-multiselect-btn');
        let isWorldbookDeleteMode = false; // 删除模式的状态
        let currentEditingBookId = null; // null 表示新建，有值表示编辑

        const showAvatarsToggle = document.getElementById('show-avatars-toggle');
        const avatarRadiusInput = document.getElementById('avatar-radius-input');
        // === 新增：备份与恢复功能所需元素 ===
        const backupDataBtn = document.getElementById('backup-data-btn');
        const importDataBtn = document.getElementById('import-data-btn');
        const importFileInput = document.getElementById('import-file-input');
        // === 新增：字体更换功能所需元素 ===
        const customFontStyle = document.getElementById('custom-font-style');
        const changeFontBtn = document.getElementById('change-font-btn');
        const restoreFontBtn = document.getElementById('restore-font-btn');
        const fontImportInput = document.getElementById('font-import-input');
        const worldbookSelectSettings = document.getElementById('worldbook-select-settings');


        // 1. 获取需要的元素
        const chatEmojiButton = document.getElementById('chat-emoji-button');
        const chatScreenForPanel = document.getElementById('chat-screen'); // chat-screen 作为父容器
        const chatMessagesForPanel = document.getElementById('chat-messages-container'); // 消息容器



        // === 新增：API 设置所需的元素 ===

        const apiUrlInput = document.getElementById('api-url');
        const apiKeyInput = document.getElementById('api-key');
        const connectButton = document.getElementById('connect-api-button');
        const apiStatusSpan = document.getElementById('api-connection-status');
        const modelSelect = document.getElementById('api-model');
        const saveApiButton = document.getElementById('save-settings-button'); // 这个按钮是设置页顶部的保存按钮
        const tempSlider = document.getElementById('temperature-slider');
        const tempValueSpan = document.getElementById('temperature-value');
        // === 1. 获取所有需要操作的HTML元素 ===
        // 时钟元素
        const clockHoursElem = document.getElementById('clock-hours');
        const clockMinutesElem = document.getElementById('clock-minutes');
        // 语录元素
        const mottoElem = document.getElementById('motto');
        // 小组件元素
        const widgetContainer = document.getElementById('widgetContainer');
        const widgetVisibilityToggle = document.getElementById('toggle-widget-visibility');
        const imageUploader = document.getElementById('imageUploader');
        const widgetText = document.getElementById('widgetText');
        // === 新增：壁纸功能所需的元素 ===
        const wallpaperPreview = document.getElementById('wallpaper-preview');
        const resetWallpaperBtn = document.getElementById('reset-wallpaper-btn');
        const uploadWallpaperBtn = document.getElementById('upload-wallpaper-btn');
        const defaultBodyBg = '#f0f2f5'; // 一个柔和的淡粉色


        // --- 新增：灵动岛相关元素和状态管理 ---
        // Add this line with the other element declarations
        const collapsedSongTitle = document.getElementById('collapsed-song-title');
        const dynamicIsland = document.getElementById('dynamic-island');
        const islandSongTitle = document.getElementById('island-song-title');
        const islandSongArtist = document.getElementById('island-song-artist');
        const islandPlayPauseBtn = document.getElementById('island-play-pause-btn');
        const islandPrevBtn = document.getElementById('island-prev-btn');
        const islandNextBtn = document.getElementById('island-next-btn');
        const progressCurrentTime = document.getElementById('progress-current-time');
        const progressRemainingTime = document.getElementById('progress-remaining-time');
        const progressBarFill = document.getElementById('progress-bar-fill');


        const addPlaylistBtn = document.getElementById('add-playlist-btn');
        const playlistGrid = document.getElementById('playlist-grid');
        const playlistDetailScreen = document.getElementById('playlist-detail-screen');
        const playlistBackButton = document.getElementById('playlist-back-button');
        const playlistNameTitle = document.getElementById('playlist-name-title');
        const importMusicButton = document.getElementById('import-music-button');
        const musicFileInput = document.getElementById('music-file-input');
        const songList = document.getElementById('song-list');
        const uploadCoverBtn = document.getElementById('upload-cover-btn');
        const multiSelectBtn = document.getElementById('multi-select-btn');
        const coverUploadInput = document.getElementById('cover-upload-input');

        // === 新增：歌单名称编辑所需元素 ===
        const editPlaylistNameBtn = document.getElementById('edit-playlist-name-btn');




        // === 新增：表情包功能的核心JS逻辑 ===

        // 1. 获取所有新添加的HTML元素
        const addEmojiBtn = document.getElementById('add-emoji-btn');
        const addEmojiModal = document.getElementById('add-emoji-modal');
        const emojiModalCloseBtn = document.getElementById('emoji-modal-close-btn');
        const saveEmojiBtn = document.getElementById('save-emoji-btn');
        const emojiUrlInput = document.getElementById('emoji-urls-textarea');
        const emojiGridContainer = document.getElementById('emoji-grid-container');

// === 新增：处理图标URL输入的核心逻辑 ===

const iconListContainer = document.getElementById('icon-list-container');
// === 新增：AI可用表情包的描述与URL映射 ===
const stickerMap = new Map([
    ['可爱动漫小狗趴在手机旁边等消息', 'https://i.postimg.cc/TY5RfBw3/1755713422890.gif'],
    ['求求了', 'https://i.postimg.cc/SKRY4knt/1755749657526.jpg'],
    ['喝AD钙', 'https://i.postimg.cc/9XP7hxxT/1755749847793.gif'],
    ['无语', 'https://i.postimg.cc/5N0NRpDf/1755749922509.jpg'],
    ['摸摸小猫头', 'https://i.postimg.cc/rsTgpDX9/1755749920816.jpg'],
    ['你脑子进水了', 'https://i.postimg.cc/NF1X5D7y/1755750006013.jpg'],
    ['汗流浃背', 'https://i.postimg.cc/nh0DjTg5/1755750086388.gif'],
    ['小猫wink', 'https://i.postimg.cc/JndxNMFf/1755750145576.gif'],
    ['emo了', 'https://i.postimg.cc/Bn7764C1/006-APo-FYly8gtkjwbge8oj30hs0eut9p.jpg'],
    ['太美味了', 'https://i.postimg.cc/7Y5fdyLZ/47ee5e40ea31b7fe1e3b34de080f0568.jpg'],
    ['已老实', 'https://i.postimg.cc/zBDfksM5/3048e89d841be9618f1b4730867ab67a.jpg'],
    ['过去软弱的我已经死了！现在是更软弱的我', 'https://i.postimg.cc/RFbvLNKQ/ddbd366ce245f3e8f4ea9b119435c751.jpg'],
    ['哦？是吗？', 'https://i.postimg.cc/XJXbq4mZ/12207db77b0c4a7db2dc4e44aca91055.jpg'],
    ['这张卡你拿着，密码是0，余额也是', 'https://i.postimg.cc/KzVygCh0/5691afc7baf80877eb46bf4b155b6fa3.jpg'],
    ['强忍泪水', 'https://i.postimg.cc/qgHV1nRn/c43e7347b4bd240c7852e055dd12ac37.jpg'],
    ['想不想我', 'https://i.postimg.cc/sD5vs45k/b3ab2f36fa5013dc22112b639efbb199.jpg'],
    ['你是个二百五！', 'https://i.postimg.cc/J43494Lm/005-XSXm-Ngy1gvw48nmbc0j304602d0sl.jpg'],
    ['有一点骚', 'https://i.postimg.cc/Z5VY57nM/006-CXr-Ejly1gtavg3d53fg308s08swex.gif'],
    ['能好好爱我吗，emo了。', 'https://i.postimg.cc/gjWbD8rh/ceeb653ely8gtrqmsutcfj20hs0hsq44.jpg'],
    ['你单身！！', 'https://i.postimg.cc/gk7NbdqS/006-APo-FYly8gt9twjaud5j30hs0hs3zb.jpg'],
    ['恶心', 'https://i.postimg.cc/dQx8L6kD/005-L0-HLIgy1hcls43b180j30gn0gndgs.jpg'],
    ['无语了家人们', 'https://i.postimg.cc/tT75Y4bV/005-L0-HLIgy1hcls42ketdj30ar0ar74h.jpg'],
    ['哥帅不帅?', 'https://i.postimg.cc/mkyt47n3/005-L0-HLIgy1hcls3yaxl8j30k00k0wev.jpg'],
    ['好困呀', 'https://i.postimg.cc/9XnkPsNh/005-L0-HLIgy1hcls41ni15j30qv0pvdh3.jpg']
]);

        // === IndexedDB 帮助函数 START ===

 // === IndexedDB 帮助函数 (最终稳健版) ===
const dbHelper = {
            db: null,
            dbName: 'phoneDataDB',

            // 1. 初始化数据库 (V3 - Final Robust Version)
            async init() {
                // 如果连接已存在，直接返回一个已完成的Promise
                if (this.db) {
                    return Promise.resolve();
                }

                return new Promise((resolve, reject) => {
                    // 确保这里的版本号是您最新的版本号 (例如 6)
                    const request = indexedDB.open(this.dbName, 6);

                    request.onerror = (event) => {
                        // 如果打开失败，直接拒绝Promise
                        console.error("数据库打开时发生错误:", request.error);
                        reject(`数据库打开失败: ${request.error}`);
                    };

                    request.onupgradeneeded = (event) => {
                        console.log("数据库需要升级或首次创建...");
                        const db = event.target.result;
                        const transaction = event.target.transaction;

                        const objectStores = ['settingsStore', 'messageContacts', 'musicPlaylists', 'worldBooks', 'emojiStore', 'gachaPosts', 'gachaPostInteractions'];

                        try {
                            objectStores.forEach(name => {
                                if (!db.objectStoreNames.contains(name)) {
                                    console.log(`正在创建表: ${name}`);
                                    if (name === 'emojiStore') {
                                        db.createObjectStore(name, { keyPath: 'url' });
                                    } else {
                                        db.createObjectStore(name, { keyPath: 'id' });
                                    }
                                }
                            });
                            console.log("所有表结构检查/创建完毕。");
                        } catch (e) {
                             console.error("在 onupgradeneeded 事件中创建表失败:", e);
                             // 如果在创建过程中出错，拒绝Promise
                             reject("创建数据库表失败");
                             // 中断事务
                             if(transaction) transaction.abort();
                             return;
                        }
                    };

                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        console.log("数据库已成功连接并准备就绪。");
                        // 只有在 onsuccess 时才解决Promise，确保 onupgradeneeded 已完成
                        resolve();
                    };
                });
            },

            // ... 您其他的 dbHelper 函数 (saveData, loadData 等) 保持不变 ...
            // (请确保将此 init 函数粘贴到您现有的 dbHelper 对象中，替换掉旧的 init)
            async saveData(storeName, id, value) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.put({ id, value }); 

                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(`数据保存到 ${storeName} 失败: ` + event.target.error);
                });
            },
            async loadData(storeName, id) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.get(id);

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject(`从 ${storeName} 读取数据失败: ` + event.target.error);
                });
            },
            async deleteData(storeName, id) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.delete(id);

                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(`从 ${storeName} 删除数据失败: ` + event.target.error);
                });
            },
            async getAllDataFromStore(storeName) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.getAll();

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject(`从 ${storeName} 读取所有数据失败: ` + event.target.error);
                });
            },
            async clearStore(storeName) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.clear();

                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(`清空 ${storeName} 失败: ` + event.target.error);
                });
            },
            async updateRecord(storeName, record) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.put(record);

                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(`更新 ${storeName} 中的记录失败: ` + event.target.error);
                });
            }
        };



        // === IndexedDB 帮助函数 END ===



        // 2. 为表情按钮绑定点击事件
chatEmojiButton.addEventListener('click', () => {
    // 3. 切换父容器的激活类名，CSS会自动处理剩下的动画
    chatScreenForPanel.classList.toggle('emoji-panel-active');

    // 4. (优化体验) 每次打开或关闭面板后，都尝试将消息列表滚动到底部
    setTimeout(() => {
        chatMessagesForPanel.scrollTop = chatMessagesForPanel.scrollHeight;
    }, 300); // 延迟时间与CSS动画时间一致
});


        let playbackState = {
            playlist: [],       // 当前播放的整个歌单
            currentIndex: -1,   // 当前歌曲在歌单中的索引
            currentSong: null,  // 当前歌曲的对象
            isPlaying: false
        };
        // === 2. 时钟功能 ===
        function updateClock() {
            const now = new Date();
            // 使用padStart确保数字总是两位数 (例如 01, 02)
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');

            clockHoursElem.textContent = hours;
            clockMinutesElem.textContent = minutes;
        }

        // === 3. 数据存储功能 (使用 localStorage) ===

        // 功能A: 加载已保存的数据 (页面打开时执行)
        // 将 function loadData() 修改为 async function loadData()
        async function loadData() {

            // 加载语录
            // 原代码: const savedMotto = localStorage.getItem('savedMotto');
            const mottoData = await dbHelper.loadData('settingsStore', 'savedMotto');
            if (mottoData) {
                mottoElem.textContent = mottoData.value;
            }

            // 加载小组件图片
            // 原代码: const savedWidgetImage = localStorage.getItem('savedWidgetImage');
            const widgetImageData = await dbHelper.loadData('settingsStore', 'savedWidgetImage');
            if (widgetImageData) {
                widgetContainer.style.backgroundImage = `url('${widgetImageData.value}')`;
                widgetText.style.display = 'none';
                widgetContainer.style.border = 'none';
            }

            // 加载API设置
            // 原代码: const savedApiSettings = localStorage.getItem('apiSettings');
            const apiSettingsData = await dbHelper.loadData('settingsStore', 'apiSettings');
            if (apiSettingsData) {
                // IndexedDB可以直接存对象，所以无需JSON.parse
                const settings = apiSettingsData.value;
                apiUrlInput.value = settings.url || '';
                apiKeyInput.value = settings.key || '';
                if (settings.model) {
                    modelSelect.innerHTML = `<option value="${settings.model}">${settings.model}</option>`;
                    modelSelect.value = settings.model;
                    modelSelect.disabled = false;
                }
                tempSlider.value = settings.temperature || 1.0;
                updateSliderProgress();
            }

            // 加载壁纸
            // 原代码: const savedWallpaper = localStorage.getItem('homeWallpaper') || defaultBodyBg;
            const wallpaperData = await dbHelper.loadData('settingsStore', 'homeWallpaper');
            const savedWallpaper = wallpaperData ? wallpaperData.value : defaultBodyBg;
            homeScreen.style.backgroundImage = savedWallpaper;
            wallpaperPreview.style.backgroundImage = savedWallpaper;

            // 加载小组件可见性
            // 原代码: const isWidgetVisible = localStorage.getItem('isWidgetVisible') !== 'false';
            const widgetVisibleData = await dbHelper.loadData('settingsStore', 'isWidgetVisible');
            // 如果没存过 (null/undefined)，则默认为 true
            const isWidgetVisible = widgetVisibleData ? widgetVisibleData.value : true;
            widgetVisibilityToggle.checked = isWidgetVisible;
            if (!isWidgetVisible) {
                widgetContainer.classList.add('widget-hidden');
            }
            const fullscreenData = await dbHelper.loadData('settingsStore', 'isFullscreenEnabled');
            // 默认是关闭的 (false)
            const isFullscreenEnabled = fullscreenData ? fullscreenData.value : false;
            fullscreenToggle.checked = isFullscreenEnabled;
            applyFullscreenMode(isFullscreenEnabled); // 页面加载时应用一次
            
            // ▼▼▼ START: 在这里粘贴新的代码 ▼▼▼
    const darkModeData = await dbHelper.loadData('settingsStore', 'darkModeEnabled');
    // 如果没有保存的设置，则默认为 false (白天模式)
    const isDarkModeEnabled = darkModeData ? darkModeData.value : false;
    // 将开关的视觉状态与保存的设置同步
    darkModeToggle.checked = isDarkModeEnabled;
    // 在应用加载时应用主题
    applyDarkMode(isDarkModeEnabled);
    // ▲▲▲ END: 粘贴到这里结束 ▲▲▲
        }

        // 功能B: 保存语录 (当编辑完成时触发)
        // "blur"事件表示元素失去焦点，即用户编辑完成
        mottoElem.addEventListener('blur', async () => {
            // 原代码: localStorage.setItem('savedMotto', mottoElem.textContent);
            await dbHelper.saveData('settingsStore', 'savedMotto', mottoElem.textContent);
        });

        // === 4. 小组件图片上传功能 (已集成保存功能) ===
        widgetContainer.addEventListener('click', () => {
            imageUploader.click();
        });

        imageUploader.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const imageDataUrl = e.target.result;
                    widgetContainer.style.backgroundImage = `url('${imageDataUrl}')`;
                    widgetText.style.display = 'none';
                    widgetContainer.style.border = 'none';
                    await dbHelper.saveData('settingsStore', 'savedWidgetImage', imageDataUrl);
                };
                reader.readAsDataURL(file);
            }
            
        });




        // === 5. 初始化页面 ===
        async function initializeApp() {
            try {
                // 首先初始化数据库
                await dbHelper.init();
                // 数据库准备好后，再加载数据
                await loadData();

                await loadCustomIcons();
                await loadClockColor();
                await loadClockBlurSetting();

                await loadPlaylists();

                await loadContacts();

                await loadAndRenderEmojis();

                await loadCartFromDB();
                await updateBalanceDisplay();
    await loadOrdersFromDB();
    await initializeUnlockCodes();

                // 时钟功能不受影响
                updateClock();
                setInterval(updateClock, 30000);

                const fontData = await dbHelper.loadData('settingsStore', 'customFont');
                if (fontData && fontData.value) {
                    applyCustomFont(fontData.value);
                }

            } catch (error) {
                console.error("应用初始化失败:", error);
                alert("无法加载数据，请刷新页面重试。");
            }
        }

        // 将这段新代码添加到你的JS脚本区域
        // 用这个新版本替换旧的 emojiGridContainer.addEventListener
        // 用这个新版本替换旧的 emojiGridContainer 的点击事件
        // 用这个新版本，替换掉你原来的 emojiGridContainer.addEventListener('click', ...)
        emojiGridContainer.addEventListener('click', (event) => {

            // 判断当前是否处于“多选删除模式”
            if (isEmojiDeleteMode) {
                const container = event.target.closest('.emoji-item-container');
                if (container) {
                    const checkbox = container.querySelector('.emoji-checkbox');
                    if (checkbox) {
                        // 如果用户点击的不是复选框本身，我们才需要手动帮他勾选
                        // 这样可以避免用户直接点复选框时，我们的代码和他操作冲突
                        if (event.target !== checkbox) {
                            checkbox.checked = !checkbox.checked;
                        }

                        // === 核心修复在这里 ===
                        // 根据复选框的最新状态，来决定是否给容器添加 'selected' 类
                        container.classList.toggle('selected', checkbox.checked);
                    }
                }
                return; // 结束函数，不执行发送逻辑
            }

            // 如果不是删除模式，执行正常的“发送”逻辑
            if (event.target.tagName === 'IMG' && event.target.classList.contains('emoji-item')) {
                const imgElement = event.target;
                const remarkElement = imgElement.nextElementSibling;

                const remark = remarkElement ? remarkElement.textContent.trim() : "表情";
                const url = imgElement.dataset.url;

                if (url) {
                    const stickerMessage = {
                        type: 'sticker',
                        text: `[表情包：${remark}]`,
                        url: url
                    };

                    sendMessage(stickerMessage);

                    chatScreenForPanel.classList.remove('emoji-panel-active');
                }
            }
        });
        // 运行初始化函数
        initializeApp();


// === START: SHOPMALL SCRIPT (EVENT LISTENERS) ===

        // Click the SHOP App Icon: Add the class to the parent to trigger the animation
        shopAppIcon.addEventListener('click', () => {
            phoneFrame.classList.add('show-shop');
        });

        // Click the SHOP screen's "Back" button: Remove the class to go back
        shopBackButton.addEventListener('click', () => {
            phoneFrame.classList.remove('show-shop');
        });
        // === END: SHOPMALL SCRIPT (EVENT LISTENERS) ===

        // 点击“设置”App图标：给父容器添加类名来触发动画
        settingsAppIcon.addEventListener('click', () => {
            phoneFrame.classList.add('show-settings');
        });
// === 新增：时钟设置界面的导航事件 ===

// 点击“更换时钟”按钮：从美化页进入时钟设置页
changeClockButton.addEventListener('click', () => {
    phoneFrame.classList.add('show-clock-settings');
});

// 点击时钟设置页的“返回”按钮：返回到美化页
clockSettingsBackButton.addEventListener('click', () => {
    phoneFrame.classList.remove('show-clock-settings');
});
        // === 新增：更换图标界面的导航事件 ===

// 点击“更换图标”按钮：从美化页进入图标设置页
changeIconButton.addEventListener('click', () => {
    phoneFrame.classList.add('show-icon-settings');
    renderIconSettings(); 
});

// 点击图标设置页的“返回”按钮：返回到美化页
iconSettingsBackButton.addEventListener('click', () => {
    phoneFrame.classList.remove('show-icon-settings');
});

        // === 新增：美化App的导航事件 ===

        // 点击“美化”App图标：给父容器添加类名来触发动画
        beautifyAppIcon.addEventListener('click', () => {
            phoneFrame.classList.add('show-beautify');
        });

        // 点击美化App的“返回”按钮：从父容器移除类名来触发返回动画
        beautifyBackButton.addEventListener('click', () => {
            phoneFrame.classList.remove('show-beautify');
        });

        // 点击“返回”按钮：从父容器移除类名来触发返回动画
        backButton.addEventListener('click', () => {
            phoneFrame.classList.remove('show-settings');
        });

        // === 新增：连接按钮的事件监听 ===
        // === 新增：连接按钮的事件监听 (已增强错误提示) ===
        connectButton.addEventListener('click', async () => {
            const apiUrl = apiUrlInput.value.trim();
            const apiKey = apiKeyInput.value.trim();

            if (!apiUrl || !apiKey) {
                apiStatusSpan.textContent = "URL和Key不能为空";
                return;
            }

            connectButton.textContent = "连接中...";
            connectButton.disabled = true;
            apiStatusSpan.textContent = "";

            try {
                const response = await fetch(`${apiUrl}/v1/models`, {
                    headers: { 'Authorization': `Bearer ${apiKey}` }
                });

                // --- 变化从这里开始 ---

                if (!response.ok) {
                    // 如果响应状态不是 2xx，我们根据状态码抛出具体的错误
                    throw new Error(`HTTP Error: ${response.status}`);
                }

                // 如果请求成功...
                const data = await response.json();
                modelSelect.innerHTML = '<option value="" disabled selected>选择一个模型</option>';
                data.data.forEach(model => {
                    modelSelect.innerHTML += `<option value="${model.id}">${model.id}</option>`;
                });
                modelSelect.disabled = false;
                apiStatusSpan.textContent = "✓ 连接成功";
                apiStatusSpan.style.color = "green";

            } catch (error) {
                console.error("API 连接失败:", error); // 在控制台保留详细错误供开发者查看

                // 根据错误类型，显示不同的用户提示
                if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
                    // 这是最常见的网络或CORS错误
                    apiStatusSpan.textContent = "✗ 网络错误或跨域问题";
                    apiStatusSpan.style.color = "red";
                    alert("连接失败！最常见的原因是：\n\n1. API服务器未开启CORS跨域许可。\n2. 浏览器插件拦截了请求 (如广告拦截器)。\n3. 您的网络无法访问该URL地址。\n\n请按 F12 打开开发者工具，在“控制台(Console)”中查看详细的错误信息。");
                } else if (error.message.startsWith('HTTP Error:')) {
                    // 这是我们自己抛出的HTTP状态码错误
                    const status = error.message.split(':')[1].trim();
                    let tip = `(状态码: ${status})`;
                    if (status === '401') {
                        tip = "✗ 认证失败 (401)，请检查您的API Key是否正确。";
                    } else if (status === '404') {
                        tip = "✗ 未找到 (404)，请检查您的URL地址是否正确。";
                    } else if (status >= 500) {
                        tip = `✗ 服务器错误 (${status})，API服务可能暂时不可用。`;
                    } else {
                        tip = `✗ 请求失败 ${tip}，请检查API文档。`;
                    }
                    apiStatusSpan.textContent = tip;
                    apiStatusSpan.style.color = "red";
                } else {
                    // 其他未知错误
                    apiStatusSpan.textContent = "✗ 未知错误，请查看控制台";
                    apiStatusSpan.style.color = "red";
                }

                modelSelect.innerHTML = '<option value="" disabled selected>连接失败</option>';

                // --- 变化在这里结束 ---

            } finally {
                connectButton.textContent = "连接测试";
                connectButton.disabled = false;
            }
        });

        // === 新增：温度滑块的事件监听 ===
        function updateSliderProgress() {
            const value = parseFloat(tempSlider.value);
            const percentage = (value / 2) * 100; // 因为最大值是2
            tempSlider.style.setProperty('--progress-percent', `${percentage}%`);
            tempValueSpan.textContent = value.toFixed(1);
        }
        tempSlider.addEventListener('input', updateSliderProgress);
        // (新) 保存设置按钮的点击事件
        // (新) 保存设置按钮的点击事件 (已修复)
        saveSettingsButton.addEventListener('click', async () => {

            // --- 关键修复在这里 ---
            // 从各个输入框中读取当前的值，并组装成一个对象
            const apiSettings = {
                url: apiUrlInput.value.trim(),
                key: apiKeyInput.value.trim(),
                model: modelSelect.value,
                temperature: tempSlider.value
            };

            // 将组装好的、包含最新设置的对象存入数据库
            await dbHelper.saveData('settingsStore', 'apiSettings', apiSettings);

            alert('设置已保存！');
            phoneFrame.classList.remove('show-settings');
        });
        // === 新增：壁纸更换的事件监听 ===

        // 点击“选择图片”按钮，实际是触发隐藏的 input
        uploadWallpaperBtn.addEventListener('click', () => {
            wallpaperUploadInput.click();
        });

        // 当用户选择了图片文件后
        wallpaperUploadInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = async (e) => { // 改为 async
                    const imageDataUrl = `url(${e.target.result})`;
                    homeScreen.style.backgroundImage = imageDataUrl;
                    wallpaperPreview.style.backgroundImage = imageDataUrl;

                    // 原代码: localStorage.setItem('homeWallpaper', imageDataUrl);
                    await dbHelper.saveData('settingsStore', 'homeWallpaper', imageDataUrl);
                };
                reader.readAsDataURL(file);
            }
        });

        // 点击“恢复默认”按钮
        resetWallpaperBtn.addEventListener('click', async () => {
            // 1. 恢复主屏幕和预览区的壁纸为默认
            homeScreen.style.backgroundImage = 'none'; // 清除背景图片
            homeScreen.style.backgroundColor = defaultBodyBg; // 设置背景颜色
            wallpaperPreview.style.backgroundImage = 'none'; // 清除预览图
            wallpaperPreview.style.backgroundColor = defaultBodyBg; // 设置预览区背景色

            // 2. 从本地存储中移除自定义壁纸记录
            await dbHelper.deleteData('settingsStore', 'homeWallpaper');
        });
        widgetVisibilityToggle.addEventListener('change', async () => { // 改为 async
            if (widgetVisibilityToggle.checked) {
                widgetContainer.classList.remove('widget-hidden');
                await dbHelper.saveData('settingsStore', 'isWidgetVisible', true);
            } else {
                widgetContainer.classList.add('widget-hidden');
                await dbHelper.saveData('settingsStore', 'isWidgetVisible', false);
            }
        });

        // === 新增：世界书 App 的导航事件 ===
        worldbookAppIcon.addEventListener('click', () => {
            phoneFrame.classList.add('show-worldbook');
            loadAndRenderWorldBooks();
        });

        worldbookBackButton.addEventListener('click', () => {
            phoneFrame.classList.remove('show-worldbook');
        });

        // === 新增：消息 App 的导航事件 ===

        // 点击“消息”App图标：给父容器添加类名来触发动画
        messagesAppIcon.addEventListener('click', () => {
            phoneFrame.classList.add('show-messages');
        });

        // 点击消息App的“返回”按钮：从父容器移除类名来触发返回动画
        messagesBackButton.addEventListener('click', () => {
            phoneFrame.classList.remove('show-messages');
        });
        // === 新增：音乐App的导航事件 ===

        // 点击“音乐”App图标：给父容器添加类名来触发动画
        musicAppIcon.addEventListener('click', () => {
            phoneFrame.classList.add('show-music');
        });

        // 点击音乐App的“返回”按钮：从父容器移除类名来触发返回动画
        musicBackButton.addEventListener('click', () => {
            phoneFrame.classList.remove('show-music');
        });
        // === 音乐 App 歌单功能 ===

        // 1. 获取需要的 HTML 元素


        // 3. 定义一个函数，用于创建歌单卡片的 HTML 结构
        // === 这是 createPlaylistCard 函数的唯一正确版本 ===
        // 它创建卡片、异步更新歌曲数量，并为卡片绑定了正确的点击事件

        // === 更新 createPlaylistCard (增加复选框) ===
        function createPlaylistCard(name, playlistData) {
            const card = document.createElement('div');
            card.className = 'playlist-card';
            card.dataset.playlistName = name;

            // --- 新增：在卡片内部添加复选框 ---
            card.innerHTML = `
        <input type="checkbox" class="playlist-checkbox">
        <div class="playlist-cover"></div>
        <div class="playlist-name"></div>
        <div class="playlist-count"></div>
    `;

            // 获取刚刚创建的元素并填充内容
            const coverDiv = card.querySelector('.playlist-cover');
            if (playlistData && playlistData.coverUrl) {
                coverDiv.style.backgroundImage = `url(${playlistData.coverUrl})`;
            }

            card.querySelector('.playlist-name').textContent = name;

            const songCount = (playlistData && Array.isArray(playlistData.songs)) ? playlistData.songs.length : 0;
            card.querySelector('.playlist-count').textContent = `${songCount} 首歌曲`;

            playlistGrid.appendChild(card);

            card.addEventListener('click', (event) => {
                // 如果是删除模式，并且点击的不是复选框，则模拟点击复选框
                if (isPlaylistDeleteMode && event.target.type !== 'checkbox') {
                    const checkbox = card.querySelector('.playlist-checkbox');
                    checkbox.checked = !checkbox.checked;
                } else if (!isPlaylistDeleteMode) {
                    // 正常模式下才进入详情页
                    openPlaylistDetailView(name);
                }
            });
        }
        /// === 修改：从数据库加载并显示歌单（适配新数据结构） ===
        async function loadPlaylists() {
            const playlistData = await dbHelper.loadData('musicPlaylists', 'allPlaylists');
            if (playlistData && typeof playlistData.value === 'object') {
                const playlists = playlistData.value;
                playlistGrid.innerHTML = '';
                Object.keys(playlists).forEach(name => {
                    // 将整个歌单对象传入，而不仅仅是名字
                    createPlaylistCard(name, playlists[name]);
                });
            }
        }
        // === 新增：歌单详情页的全部交互逻辑 ===

        // 1. 获取新页面的所有元素


        let isDeleteMode = false; // 用于跟踪是否处于删除模式

        let currentOpenPlaylist = null; // 存储当前打开的歌单的名称


        // 3. 打开歌单详情页的函数
        // === 修改：打开歌单详情页的函数（增加健壮性检查） ===
        // === 替换为修复版：正确显示歌曲列表 ===
        async function openPlaylistDetailView(playlistName) {
            currentOpenPlaylist = playlistName;
            playlistNameTitle.textContent = playlistName;
            songList.innerHTML = '';

            const allPlaylistsData = await dbHelper.loadData('musicPlaylists', 'allPlaylists');

            // --- 关键修复在这里 ---
            // 检查新数据结构中的 .songs 属性是否是一个有效的数组
            if (allPlaylistsData && allPlaylistsData.value && allPlaylistsData.value[playlistName] && Array.isArray(allPlaylistsData.value[playlistName].songs)) {
                // 从 .songs 属性中获取歌曲列表
                const songs = allPlaylistsData.value[playlistName].songs;
                songs.forEach(song => {
                    appendSongToList(song);
                });
            } else {
                // 这段代码现在只会在数据确实为空或损坏时触发
                console.warn(`歌单 "${playlistName}" 的歌曲数据不是一个有效的数组，或者为空。`);
            }

            // 显示详情页
            phoneFrame.classList.add('show-playlist-detail');
        }

        // 4. 关闭歌单详情页
        playlistBackButton.addEventListener('click', () => {
            phoneFrame.classList.remove('show-playlist-detail');
            currentOpenPlaylist = null; // 清理当前歌单记录
        });

        // 5. "导入歌曲" 按钮的点击事件
        importMusicButton.addEventListener('click', () => {
            musicFileInput.click(); // 触发隐藏的文件选择框
        });

        // 6. 文件选择框检测到变化的事件
        // === 替换为修复版：向数据库存储文件对象本身 ===
        musicFileInput.addEventListener('change', async (event) => {
            const files = event.target.files;
            if (!files.length || !currentOpenPlaylist) return;

            try {
                const allPlaylistsData = await dbHelper.loadData('musicPlaylists', 'allPlaylists');
                let allPlaylists = allPlaylistsData.value;

                for (const file of files) {
                    let title = file.name.replace(/\.(mp3|wav|flac)$/i, '');
                    let artist = '未知艺术家';
                    if (/\s*-\s*/.test(title)) {
                        [title, artist] = title.split(/\s*-\s*/).map(s => s.trim());
                    }

                    // --- 关键修改在这里 ---
                    // 我们不再创建和存储临时的 blob URL
                    // 而是直接存储 file 对象
                    const song = {
                        title: title,
                        artist: artist,
                        file: file // <--- 修改点
                    };

                    allPlaylists[currentOpenPlaylist].songs.push(song);
                    appendSongToList(song);
                }

                // 更新歌曲数量
                const cardToUpdate = playlistGrid.querySelector(`.playlist-card[data-playlist-name="${currentOpenPlaylist}"]`);
                if (cardToUpdate) {
                    const countElement = cardToUpdate.querySelector('.playlist-count');
                    countElement.textContent = `${allPlaylists[currentOpenPlaylist].songs.length} 首歌曲`;
                }

                await dbHelper.saveData('musicPlaylists', 'allPlaylists', allPlaylists);

            } catch (error) {
                console.error("导入歌曲失败:", error);
            } finally {
                event.target.value = '';
            }
        });

        // 7. 一个辅助函数，用于将歌曲对象添加到 HTML 列表中
        function appendSongToList(song) {
            const li = document.createElement('li');
            li.className = 'song-item';
            const songId = song.file ? `${song.file.name}-${song.file.lastModified}` : song.url;
            li.dataset.songId = songId;
            li.innerHTML = `
        <input type="checkbox" class="song-checkbox">
        <div class="song-info">
            <div class="song-title">${song.title || '未知歌曲'}</div>
            <div class="song-artist">${song.artist || '未知艺术家'}</div>
        </div>
        <button class="play-button">
            <svg viewBox="0 0 100 100">
                <circle cx="50" cy="50" r="48" stroke="#ccc" stroke-width="4" fill="none"/>
                <polygon points="35,25 75,50 35,75" fill="#555"/>
            </svg>
        </button>
    `;
            songList.appendChild(li);

            const playButton = li.querySelector('.play-button');

            if (song.file) {
                // --- 关键修复：将事件处理函数标记为 async ---
                playButton.addEventListener('click', async (e) => {
                    e.stopPropagation();

                    try {
                        // --- 关键修复：在点击时，主动从数据库加载数据 ---
                        const allPlaylistsData = await dbHelper.loadData('musicPlaylists', 'allPlaylists');
                        if (!allPlaylistsData || !allPlaylistsData.value) {
                            throw new Error("无法加载播放列表数据。");
                        }
                        const allPlaylists = allPlaylistsData.value;

                        // 现在可以安全地获取歌曲列表和索引了
                        const currentPlaylistSongs = allPlaylists[currentOpenPlaylist].songs;
                        const songIndex = currentPlaylistSongs.findIndex(s =>
                            s.file && s.file.name === song.file.name && s.file.lastModified === song.file.lastModified
                        );

                        if (songIndex > -1) {
                            startPlayback(currentPlaylistSongs, songIndex);
                        } else {
                            throw new Error("在播放列表中找不到当前歌曲。");
                        }

                    } catch (error) {
                        console.error("播放时出错:", error);
                        alert("播放歌曲时出错，请查看控制台。");
                    }
                });
            } else {
                playButton.disabled = true;
                playButton.style.opacity = 0.3;
                playButton.style.cursor = 'not-allowed';
            }
        }
        // === 新增：上传封面和批量删除的事件逻辑 ===

        // --- 上传封面逻辑 ---
        uploadCoverBtn.addEventListener('click', () => {
            if (isDeleteMode) {
                // 如果在删除模式下，这个按钮会变成“删除所选”
                handleBatchDelete();
            } else {
                // 正常模式下，触发文件选择
                coverUploadInput.click();
            }
        });

        // === 替换为最终修复版：能够处理旧数据并成功保存封面 ===
        coverUploadInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file || !currentOpenPlaylist) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                const newCoverUrl = e.target.result;
                try {
                    const allPlaylistsData = await dbHelper.loadData('musicPlaylists', 'allPlaylists');
                    // 确保我们有一个对象可以操作，即使数据库是空的
                    let allPlaylists = (allPlaylistsData && allPlaylistsData.value) ? allPlaylistsData.value : {};

                    // --- 关键修复在这里 ---
                    // 检查当前歌单是否存在，或者是否为旧格式（即一个数组而不是对象）
                    if (!allPlaylists[currentOpenPlaylist] || Array.isArray(allPlaylists[currentOpenPlaylist])) {
                        // 如果是旧格式，我们在这里把它“升级”为新格式
                        console.log(`正在升级旧格式歌单: "${currentOpenPlaylist}"`);
                        const oldSongs = Array.isArray(allPlaylists[currentOpenPlaylist]) ? allPlaylists[currentOpenPlaylist] : [];
                        allPlaylists[currentOpenPlaylist] = { songs: oldSongs, coverUrl: null };
                    }

                    // 现在可以安全地更新封面URL了
                    allPlaylists[currentOpenPlaylist].coverUrl = newCoverUrl;
                    await dbHelper.saveData('musicPlaylists', 'allPlaylists', allPlaylists);

                    // 实时更新主界面的封面
                    const cardToUpdate = playlistGrid.querySelector(`.playlist-card[data-playlist-name="${currentOpenPlaylist}"]`);
                    if (cardToUpdate) {
                        const coverDiv = cardToUpdate.querySelector('.playlist-cover');
                        coverDiv.style.backgroundImage = `url(${newCoverUrl})`;
                    }
                    alert('封面已更新！');

                } catch (error) {
                    console.error('更新封面失败:', error);
                    alert('更新封面失败，请查看控制台获取详情。');
                }
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        });

        // --- 批量删除逻辑 ---
        multiSelectBtn.addEventListener('click', () => {
            isDeleteMode = !isDeleteMode; // 切换删除模式状态

            if (isDeleteMode) {
                songList.classList.add('delete-mode');
                multiSelectBtn.textContent = '取消';
                uploadCoverBtn.textContent = '删除所选';
                uploadCoverBtn.classList.add('delete'); // 添加红色样式
            } else {
                songList.classList.remove('delete-mode');
                multiSelectBtn.textContent = '批';
                uploadCoverBtn.textContent = '封';
                uploadCoverBtn.classList.remove('delete'); // 移除红色样式
                // 退出模式时，取消所有勾选
                songList.querySelectorAll('.song-checkbox').forEach(cb => cb.checked = false);
            }
        });
        // === 替换为最终修复版：兼容新旧数据格式的删除逻辑 ===
        async function handleBatchDelete() {
            const selectedCheckboxes = songList.querySelectorAll('.song-checkbox:checked');
            if (selectedCheckboxes.length === 0) {
                alert('请至少选择一首歌曲。');
                return;
            }

            if (!confirm(`确定要删除选中的 ${selectedCheckboxes.length} 首歌曲吗？`)) {
                return;
            }

            const idsToDelete = new Set();
            selectedCheckboxes.forEach(cb => {
                const li = cb.closest('.song-item');
                idsToDelete.add(li.dataset.songId);
            });

            try {
                const allPlaylistsData = await dbHelper.loadData('musicPlaylists', 'allPlaylists');
                if (!allPlaylistsData || !allPlaylistsData.value || !allPlaylistsData.value[currentOpenPlaylist]) {
                    alert('无法加载歌单数据，删除失败！');
                    return;
                }
                let allPlaylists = allPlaylistsData.value;
                if (!Array.isArray(allPlaylists[currentOpenPlaylist].songs)) {
                    alert('歌单数据格式不正确，无法删除歌曲！');
                    return;
                }

                // --- 关键修复在这里 ---
                // 在过滤时，对新旧两种数据分别生成ID进行匹配
                const originalSongs = allPlaylists[currentOpenPlaylist].songs;
                allPlaylists[currentOpenPlaylist].songs = originalSongs.filter(song => {
                    let songId;
                    if (song.file) {
                        // 如果是新数据，用文件名和修改日期生成ID
                        songId = `${song.file.name}-${song.file.lastModified}`;
                    } else if (song.url) {
                        // 如果是旧数据，用它自己的URL作为ID
                        songId = song.url;
                    } else {
                        // 如果是无效数据，默认不删除（保留）
                        return true;
                    }
                    // 如果生成的ID在我们待删除的集合中，则这首歌被过滤掉（不返回）
                    return !idsToDelete.has(songId);
                });

                await dbHelper.saveData('musicPlaylists', 'allPlaylists', allPlaylists);

                // 刷新UI
                await openPlaylistDetailView(currentOpenPlaylist);
                multiSelectBtn.click();
                const cardToUpdate = playlistGrid.querySelector(`.playlist-card[data-playlist-name="${currentOpenPlaylist}"]`);
                if (cardToUpdate) {
                    const countElement = cardToUpdate.querySelector('.playlist-count');
                    countElement.textContent = `${allPlaylists[currentOpenPlaylist].songs.length} 首歌曲`;
                }

            } catch (error) {
                console.error('删除歌曲失败:', error);
            }
        }

        // === 新增：灵动岛和播放控制的全部函数 ===
        /**
         * 更新灵动岛折叠状态下的歌曲标题。
         * 如果标题长度超过其容器宽度，则激活滚动动画。
         * @param {string} title - 要显示的歌曲标题。
         */
        function updateScrollingTitle(title) {
            const titleElement = document.getElementById('collapsed-song-title');
            // 获取父级元素，也就是我们的“窗口”
            const windowElement = titleElement.parentElement;

            // 1. 重置状态：移除可能存在的滚动类，以防上一首歌正在滚动
            titleElement.classList.remove('scrolling');

            // 2. 用新标题更新文本内容
            titleElement.textContent = "正在播放：" + title;

            // 3. 检查文本是否溢出（即文本的实际宽度 > 其容器的可见宽度）
            // 我们使用一个短暂的延时，以确保浏览器有时间在检查前完成新文本的渲染和尺寸计算
            setTimeout(() => {
                // scrollWidth 是元素内容的总宽度，clientWidth 是元素的可见宽度
                const isOverflowing = titleElement.scrollWidth > windowElement.clientWidth;

                if (isOverflowing) {
                    // 如果确实溢出了，就添加 'scrolling' 类来启动动画
                    titleElement.classList.add('scrolling');
                }
            }, 100); // 100毫秒的延迟足够了
        }
        // 统一的播放入口函数
        // --- 替换旧的 startPlayback 函数 ---
        async function startPlayback(playlist, index) {
            if (!playlist || index < 0 || index >= playlist.length) return;

            playbackState.playlist = playlist;
            playbackState.currentIndex = index;
            playbackState.currentSong = playlist[index];

            // ... 更新灵动岛UI的代码 ...
            islandSongTitle.textContent = playbackState.currentSong.title;
            islandSongArtist.textContent = playbackState.currentSong.artist;
            updateScrollingTitle(playbackState.currentSong.title);

            const songObjectUrl = URL.createObjectURL(playbackState.currentSong.file);
            audioPlayer.src = songObjectUrl;
            audioPlayer.play().catch(error => console.error("播放失败:", error));

            // 核心修改：当处于“一起听”模式时，调用新的函数来显示并保存“正在播放”提示
            if (sharedListeningState.active && sharedListeningState.contact) {
                const message = `正在播放: ${playbackState.currentSong.title} - ${playbackState.currentSong.artist}`;
                await showSystemNotification(message, sharedListeningState.contact.id);
            }
        }

        // --- 灵动岛 UI 控制 ---
        function showDynamicIsland() {
            dynamicIsland.classList.add('active');
            playbackState.isPlaying = true;
            islandPlayPauseBtn.classList.remove('play');
            islandPlayPauseBtn.classList.add('pause');
        }

        function hideDynamicIsland() {
            dynamicIsland.classList.remove('active', 'expanded');
            playbackState.isPlaying = false;
            islandPlayPauseBtn.classList.remove('pause');
            islandPlayPauseBtn.classList.add('play');
        }

        function formatTime(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${min}:${sec}`;
        }

        // --- 事件监听 ---

        // *** 在这里新增下面的代码 ***

        // === 新增：点击世界书列表项以进行编辑 ===
        worldbookListContainer.addEventListener('click', async (event) => {
            // 如果当前是删除模式，或者点击的是复选框，则不执行编辑操作
            if (isWorldbookDeleteMode || event.target.type === 'checkbox') {
                return;
            }

            const bookItem = event.target.closest('.contact-item');
            if (bookItem) {
                const bookId = parseInt(bookItem.dataset.bookId, 10);
                openWorldbookModal(bookId); // 调用弹窗函数，并传入书籍ID
            }
        });

        // *** 新增代码结束 ***

        // 监听音频播放器事件来控制灵动岛
        audioPlayer.addEventListener('play', showDynamicIsland);
        audioPlayer.addEventListener('pause', hideDynamicIsland);
        // 这是修改后的新代码
        audioPlayer.addEventListener('ended', () => {
            // 歌曲播放结束后，将播放时间重置为0
            audioPlayer.currentTime = 0;
            // 立即重新开始播放当前歌曲，实现单曲循环
            audioPlayer.play();
        });

        audioPlayer.addEventListener('timeupdate', () => {
            const { currentTime, duration } = audioPlayer;
            if (isNaN(duration)) return;

            // 更新进度条
            const progressPercent = (currentTime / duration) * 100;
            progressBarFill.style.width = `${progressPercent}%`;

            // 更新时间显示
            progressCurrentTime.textContent = formatTime(currentTime);
            progressRemainingTime.textContent = `-${formatTime(duration - currentTime)}`;
        });

        audioPlayer.addEventListener('ended', () => {
            islandNextBtn.click(); // 自动播放下一首
        });

        // 灵动岛自身的点击事件
        // === 用下面这个修复后的版本，替换掉您现有的代码 ===

        // 灵动岛自身的点击事件
        // === 最终修复版：灵动岛点击事件 (解决头像消失和歌名不滚动问题) ===

        // === 这是修正了滚动逻辑的最终版本 ===
        dynamicIsland.addEventListener('click', (e) => {
            // 如果点击的是功能按钮，则不触发展开/收起
            if (e.target.closest('.control-button')
                || e.target.closest('.island-action-button')
                || e.target.closest('.shared-avatars')) {
                return;
            }

            const isCurrentlyExpanded = dynamicIsland.classList.contains('expanded');

            // 切换展开/收起状态
            dynamicIsland.classList.toggle('expanded');

            // 根据切换后的状态来执行操作
            if (isCurrentlyExpanded) {
                // 如果是从“展开”变为“收起”
                // 关键修复：在UI切换动画开始后，再检查滚动。
                // 200毫秒的延迟足以让容器尺寸计算正确，且比总动画时间短。
                setTimeout(() => {
                    if (playbackState.currentSong) {
                        updateScrollingTitle(playbackState.currentSong.title);
                    }
                }, 200);

            } else {
                // 如果是从“收起”变为“展开”
                updateSharedListeningUI();
            }
        });
        // 灵动岛内部控制按钮的点击事件
        islandPlayPauseBtn.addEventListener('click', () => {
            if (audioPlayer.paused) {
                audioPlayer.play();
            } else {
                audioPlayer.pause();
            }
        });

        // === “下一首”按钮的最终版 (与上一回答中的代码一致) ===
 // === 灵动岛“下一首”按钮 (V2 - 健壮版) ===
islandNextBtn.addEventListener('click', async () => {
    // ▼▼▼ 核心修改：增加安全检查 ▼▼▼
    if (!playbackState.playlist || playbackState.playlist.length === 0) {
        console.warn("播放列表为空，无法切歌。");
        return; 
    }

    let nextIndex = playbackState.currentIndex + 1;
    if (nextIndex >= playbackState.playlist.length) {
        nextIndex = 0;
    }
    await startPlayback(playbackState.playlist, nextIndex);

    if (sharedListeningState.active && sharedListeningState.contact) {
        const song = playbackState.playlist[nextIndex];
        await callAI(`我刚刚把歌曲切换到了《${song.title}》 - ${song.artist}，请根据聊天记录和歌曲本身做出回应`, sharedListeningState.contact);
    }
});

// === 灵动岛“上一首”按钮 (V2 - 健壮版) ===
islandPrevBtn.addEventListener('click', async () => {
    // ▼▼▼ 核心修改：增加安全检查 ▼▼▼
    if (!playbackState.playlist || playbackState.playlist.length === 0) {
        console.warn("播放列表为空，无法切歌。");
        return;
    }

    let songChanged = false;
    let targetIndex;

    if (audioPlayer.currentTime > 3) {
        targetIndex = playbackState.currentIndex;
        audioPlayer.currentTime = 0;
        audioPlayer.play(); // 让歌曲从头播放
    } else {
        targetIndex = playbackState.currentIndex - 1;
        if (targetIndex < 0) {
            targetIndex = playbackState.playlist.length - 1;
        }
        await startPlayback(playbackState.playlist, targetIndex);
        songChanged = true;
    }

    if (songChanged && sharedListeningState.active && sharedListeningState.contact) {
        const song = playbackState.playlist[targetIndex];
        await callAI(`我刚刚把歌曲切换到了《${song.title}》 - ${song.artist}，请根据聊天记录和歌曲本身做出回应`, sharedListeningState.contact);
    }
});
        // === 新增：处理联系人弹出层的所有逻辑 ===

        // --- 功能 A: 打开和关闭弹出层 ---
        function openModal() {
            addContactModal.style.display = 'flex';
            // 使用一个短暂的延时来确保CSS动画能够触发
            setTimeout(() => {
                addContactModal.style.opacity = '1';
                addContactModal.querySelector('.modal-content').style.transform = 'scale(1)';
            }, 10);
        }

        function closeModal() {
            addContactModal.style.opacity = '0';
            addContactModal.querySelector('.modal-content').style.transform = 'scale(0.95)';
            // 等待动画结束后再隐藏元素
            setTimeout(() => {
                addContactModal.style.display = 'none';
                // 重置表单内容
                // 清空输入框和文本域
                aiNameInput.value = '';
                aiPersonaInput.value = '';
                userNameInput.value = '';
                userPersonaInput.value = '';
                aiAvatarPreview.src = 'https://placehold.co/100x100/EFEFEF/AAAAAA?text=AI';
                userAvatarPreview.src = 'https://placehold.co/100x100/EFEFEF/AAAAAA?text=User';
                // 重置上下文记忆
                contextMemoryInput.value = '10';

                // 恢复切换开关和表单的默认显示状态
                roleSwitchCheckbox.checked = false;
                aiForm.classList.add('active');
                userForm.classList.remove('active');
                switchLabels[0].classList.add('active');
                switchLabels[1].classList.remove('active');
                // --- 重置代码结束 ---
            }, 300);// 300ms 对应CSS中的动画时长
        }
        /**
        /**
                 * 功能：根据传入的布尔值，切换全屏模式
                 * @param {boolean} isEnabled - true为启用全屏, false为手机模式
                 */
        function applyFullscreenMode(isEnabled) {
            if (isEnabled) {
                bodyElement.classList.add('fullscreen-mode');
            } else {
                bodyElement.classList.remove('fullscreen-mode');
            }
        }
        fullscreenToggle.addEventListener('change', async () => {
            const isEnabled = fullscreenToggle.checked;
            applyFullscreenMode(isEnabled);
            // 使用新的键名保存状态
            await dbHelper.saveData('settingsStore', 'isFullscreenEnabled', isEnabled);
        });
        
        // ▼▼▼ Add this new event listener for the dark mode toggle ▼▼▼
darkModeToggle.addEventListener('change', async () => {
    const isEnabled = darkModeToggle.checked;
    applyDarkMode(isEnabled);
    // Save the user's preference to the database
    await dbHelper.saveData('settingsStore', 'darkModeEnabled', isEnabled);
});
        modalCloseBtn.addEventListener('click', closeModal);
        addContactModal.addEventListener('click', (event) => {
            // 如果点击的是遮罩背景本身，而不是对话框内容，则关闭
            if (event.target === addContactModal) {
                closeModal();
            }
        });


        // --- 功能 B: 处理AI/用户表单切换 ---
        roleSwitchCheckbox.addEventListener('change', () => {
            const isUser = roleSwitchCheckbox.checked;
            aiForm.classList.toggle('active', !isUser);
            userForm.classList.toggle('active', isUser);
            switchLabels[0].classList.toggle('active', !isUser);
            switchLabels[1].classList.toggle('active', isUser);
        });

        // --- 功能 C: 处理头像上传和预览 ---
        function handleAvatarUpload(inputElement, previewElement) {
            const file = inputElement.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    previewElement.src = e.target.result; // e.target.result 包含图片的Base64编码
                };
                reader.readAsDataURL(file);
            }
        }
        aiAvatarInput.addEventListener('change', () => handleAvatarUpload(aiAvatarInput, aiAvatarPreview));
        userAvatarInput.addEventListener('change', () => handleAvatarUpload(userAvatarInput, userAvatarPreview));


        // --- 功能 D: 保存联系人到数据库并更新UI ---
        saveContactBtn.addEventListener('click', async () => {
            // 1. 数据校验
            if (!aiNameInput.value.trim() || !userNameInput.value.trim()) {
                alert('AI角色名和你的名字不能为空！');
                return;
            }

            // 2. 收集所有数据
            const newContact = {
                id: Date.now(), // 使用时间戳作为唯一ID
                ai: {
                    name: aiNameInput.value.trim(),
                    persona: aiPersonaInput.value.trim(),
                    avatar: aiAvatarPreview.src // 直接保存Base64编码的图片
                },
                user: {
                    name: userNameInput.value.trim(),
                    persona: userPersonaInput.value.trim(),
                    avatar: userAvatarPreview.src
                },
                contextMemory: parseInt(contextMemoryInput.value, 10) || 10,
                lastMessage: "点击和我聊天吧！" // 默认的最后一条消息
            };

            // 3. 保存到数据库
            try {
                const existingData = await dbHelper.loadData('messageContacts', 'allContacts');
                let contacts = (existingData && Array.isArray(existingData.value)) ? existingData.value : [];
                contacts.push(newContact);
                await dbHelper.saveData('messageContacts', 'allContacts', contacts);

                // 4. 更新UI
                appendContactToList(newContact);

                // 5. 关闭并重置弹出层
                closeModal();

            } catch (error) {
                console.error("保存联系人失败:", error);
                alert("保存失败，请查看控制台日志。");
            }
        });


        // --- 功能 E: 将单个联系人数据显示在列表中 ---
        // --- 功能 E: 将单个联系人数据显示在列表中 (已更新，带复选框) ---
        function appendContactToList(contact) {
            const li = document.createElement('li');
            li.className = 'contact-item';
            li.dataset.contactId = contact.id; // 为以后可能用到的功能（如删除）做准备

            // --- 关键修改：在最前面加入了 input 复选框 ---
            li.innerHTML = `
        <input type="checkbox" class="contact-checkbox">
        <img src="${contact.ai.avatar}" alt="avatar" class="contact-avatar">
        <div class="contact-info">
            <div class="contact-name">${contact.ai.name}</div>
            <div class="contact-last-message">${contact.lastMessage}</div>
        </div>
    `;
            contactList.appendChild(li);
        }


        // --- 功能 F: 从数据库加载所有联系人 ---
            async function loadContacts() {
                const contactsData = await dbHelper.loadData('messageContacts', 'allContacts');
                if (contactsData && Array.isArray(contactsData.value)) {
                    contactList.innerHTML = ''; // 清空现有列表
                    contactsData.value.forEach(contact => {
                        appendContactToList(contact);
                    });
                    if (contactsData.value.length > 0) {
                        updateShopper(contactsData.value[0]);
                    }
                }
            }
        // === 新增：消息列表多选删除的全部逻辑 ===

        let isMessagesDeleteMode = false; // 用于跟踪是否处于删除模式

        // “多选删除”按钮的点击事件
        messagesMultiselectBtn.addEventListener('click', () => {
            isMessagesDeleteMode = !isMessagesDeleteMode; // 切换模式状态

            contactList.classList.toggle('delete-mode', isMessagesDeleteMode);

            if (isMessagesDeleteMode) {
                // 进入删除模式
                messagesMultiselectBtn.textContent = '取消';
                messagesAddBtn.textContent = '删除所选';
                messagesAddBtn.classList.add('delete'); // 添加红色样式
            } else {
                // 退出删除模式
                messagesMultiselectBtn.textContent = '多选';
                messagesAddBtn.textContent = '添加';
                messagesAddBtn.classList.remove('delete');
                // 确保退出时所有复选框都恢复未选中状态
                contactList.querySelectorAll('.contact-checkbox').forEach(cb => cb.checked = false);
            }
        });

        // 修改“添加”按钮的点击事件，使其在删除模式下有不同行为
        messagesAddBtn.addEventListener('click', () => {
            if (isMessagesDeleteMode) {
                handleBatchDeleteContacts(); // 如果在删除模式，就执行删除
            } else {
                openModal(); // 否则，打开添加联系人对话框
            }
        });

        // 真正执行删除操作的函数
        async function handleBatchDeleteContacts() {
            const selectedCheckboxes = contactList.querySelectorAll('.contact-checkbox:checked');
            if (selectedCheckboxes.length === 0) {
                alert('请至少选择一个要删除的对话。');
                return;
            }

            if (!confirm(`确定要删除选中的 ${selectedCheckboxes.length} 个对话吗？`)) {
                return;
            }

            const idsToDelete = new Set();
            selectedCheckboxes.forEach(cb => {
                // 从复选框向上找到父级 li 元素，并获取其 ID
                const contactId = cb.closest('.contact-item').dataset.contactId;
                idsToDelete.add(parseInt(contactId, 10)); // 将ID转为数字存入集合
            });

            try {
                const contactsData = await dbHelper.loadData('messageContacts', 'allContacts');
                if (!contactsData || !Array.isArray(contactsData.value)) {
                    alert('无法加载联系人数据，删除失败！');
                    return;
                }
                let currentContacts = contactsData.value;

                // 过滤掉需要删除的联系人
                const updatedContacts = currentContacts.filter(contact => !idsToDelete.has(contact.id));

                // 将更新后的联系人列表存回数据库
                await dbHelper.saveData('messageContacts', 'allContacts', updatedContacts);

                // 重新加载列表以刷新UI
                await loadContacts();

                // 操作完成后，主动退出删除模式
                messagesMultiselectBtn.click();

            } catch (error) {
                console.error("删除联系人失败:", error);
                alert("删除失败，请查看控制台日志。");
            }
        }

        // === 新增：聊天界面的所有交互逻辑 ===

        let currentOpenContact = null; // 用于存储当前打开的联系人对象
        let displayedMessageCount = 0; // 添加一个全局变量来跟踪加载更多消息的按钮状态

// === System Prompt (V3 - Tool Calling 专用) ===
// === NEW, SIMPLIFIED System Prompt ===
const systemPrompt = `
### 核心身份
你是一个专业的AI角色扮演引擎。你的任务是完全沉浸在指定的角色中，与用户进行自然、沉浸式的对话。

---

### 角色背景 (BACKGROUND)
// AI会在这里看到你为它设定的角色信息
{ai_persona}

### 用户的角色设定:
// AI会在这里看到你为用户设定的角色信息
{user_persona}

### 世界观/知识库:
// AI会在这里看到你关联的世界书内容
{world_book_content}

---

### 回复规则 (ABSOLUTE RULES)
1.  你必须完全以你扮演的角色的身份和口吻进行回复。
2.  **【至关重要】** 你的回复【绝不能】包含任何角色名前缀，例如 "角色名:" 或 "[角色：某某]"。直接说出角色的台词即可。
3.  **【绝对规则】** 你必须模仿真人的聊天风格。将一个完整的想法拆分成**多条（2-5条）**简短连贯的消息。这是强制性的，即使你的回复只有一个词，也要设法分成两部分来表达。你将通过 \`sendMessage\` 工具来发送这些消息。你可以，也应该，在合适的时机使用 **表情包 (\`sendSticker\`)** 或 **转账 (\`makeTransfer\`)** 来让对话更生动。
---

### 时间参考
// 如果开启了时间感知，AI会在这里看到当前时间
{time_info}
`;
        // === AI功能新增：调用AI的核心函数 ===

        /**
         * 解释：
         * 这是与AI交互的核心。它是一个异步函数（async），因为网络请求需要时间。
         * @param {string} triggerMessage - 触发本次AI调用的特定消息或指令。
         */
        //
// Replace your entire old callAI function with this new one.

async function callAI(triggerMessage, contact, contextData = {}) {
    if (!contact || !contact.ai || !contact.user) {
        console.error("callAI 收到了一个无效或不完整的contact对象:", contact);
        alert("AI回复失败: 角色数据不完整或丢失。");
        return;
    }
    if (isAiReplying) return;
    isAiReplying = true;
    const contactId = contact.id;
    let initialTypingIndicator = null;
    try {
        if (currentOpenContact && currentOpenContact.id === contactId) {
            initialTypingIndicator = showTypingIndicator(contact);
            // 确保初始动画可见
            setTimeout(() => chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'smooth' }), 10);
        }

        const settingsData = await dbHelper.loadData('settingsStore', 'apiSettings');
        if (!settingsData || !settingsData.value.url || !settingsData.value.key || !settingsData.value.model) {
            throw new Error("API未完整配置，请在设置中检查。");
        }
        const { url, key, model, temperature } = settingsData.value;
        let timeInfo = contact.timePerceptionEnabled ? `### 现实时间参考\n当前用户的现实时间是：${new Date().toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai', hour12: false, year: 'numeric', month: 'long', day: 'numeric', weekday: 'long', hour: '2-digit', minute: '2-digit' })}\n---\n\n` : "";
        let worldBookContent = "无特定世界观设定，请自由发挥。";
        if (contact.linkedWorldBookIds && contact.linkedWorldBookIds.length > 0) {
            const worldbookData = await dbHelper.loadData('worldBooks', 'allWorldBooks');
            if (worldbookData && Array.isArray(worldbookData.value)) {
                const linkedBooksContent = worldbookData.value.filter(book => contact.linkedWorldBookIds.includes(book.id)).map(book => book.content).join('\n\n---\n\n');
                if (linkedBooksContent) { worldBookContent = linkedBooksContent; }
            }
        }
        const finalSystemPrompt = systemPrompt.replace('{time_info}', timeInfo).replace('{ai_persona}', `姓名: ${contact.ai.name}\n人设: ${contact.ai.persona}`).replace('{user_persona}', `姓名: ${contact.user.name}\n人设: ${contact.user.persona}`).replace('{world_book_content}', worldBookContent);
        const history = contact.history || [];
        const recentHistory = (contact.contextMemory || 10) > 0 ? history.slice(-(contact.contextMemory || 10)) : [];
        const messages = [{ role: "system", content: finalSystemPrompt }];
        recentHistory.forEach(msg => { messages.push({ role: msg.sender === 'user' ? 'user' : 'assistant', content: msg.text }); });
        messages.push({ role: "user", content: triggerMessage });
        
        const tools = [
        {
    type: "function",
    function: {
        name: "sendMessage",
        // 【核心修改】重写描述，鼓励更多样化的行为
        description: "用于向用户发送聊天消息，进行自然、生动的对话。为了模仿真人的聊天习惯，你应该将一个完整的想法拆分成多条（通常是2到5条）简短、连续的消息来发送。在发送文本消息的同时，你也可以根据对话的氛围和你的角色性格，选择性地调用 `sendSticker` (发送表情包) 或 `makeTransfer` (转账) 工具来丰富你的回应。例如，一次完整的回复可以是：先调用 sendMessage(messages=[\"真的吗？\", \"那太棒了！\"])，紧接着再调用 sendSticker(description=\"可爱动漫小狗趴在手机旁边等消息\")。",
        parameters: {
            type: "object",
            properties: {
                messages: {
                    type: "array",
                    description: "一个包含多条消息文本的数组，用于模拟连续发送消息。",
                    items: { type: "string" }
                }
            },
            required: ["messages"] } } },
            { type: "function", function: { name: "sendSticker", description: "在说完话后，发送一个表情包来强化情感。", parameters: { type: "object", properties: { description: { type: "string", description: "从可用列表中选择表情包的准确文字描述。", enum: Array.from(stickerMap.keys()) } }, required: ["description"] } } },
            { type: "function", function: { name: "makeTransfer", description: "给用户转账。", parameters: { type: "object", properties: { remark: { type: "string", description: "转账备注" }, amount: { type: "number", description: "转账金额" } }, required: ["remark", "amount"] } } },
            { type: "function", function: { name: "acceptListenInvite", description: "当用户邀请你一起听歌，且你决定接受时，调用此工具，并附上你的回复。", parameters: { type: "object", properties: { message: { type: "string", description: "你同意一起听时，要对用户说的话。例如：'好呀，我们一起听吧！'" } }, required: ["message"] } } },
            { type: "function", function: { name: "addCommentToPost", description: "当你想参与讨论、发表看法或与评论区的人互动时，调用此工具在当前帖子下发表一条新评论。", parameters: { type: "object", properties: { postId: { type: "number" }, commentText: { type: "string" } }, required: ["postId", "commentText"] } } },
            { type: "function", function: { name: "likeComment", description: "当你看到一条你赞同、喜欢或觉得有趣的评论时，调用此工具为其点赞，以示支持。", parameters: { type: "object", properties: { postId: { type: "number" }, commentId: { type: "number" } }, required: ["postId", "commentId"] } } },
            { type: "function", function: { name: "createSocialPost", description: "当你认为时机合适，想要基于最近的聊天内容，发布一条新的朋友圈动态时，调用此工具。", parameters: { type: "object", properties: { postText: { type: "string", description: "朋友圈的正文内容。" }, imageDescription: { type: "string", description: "（可选）如果动态适合配图，为图片生成一段文字描述。" } }, required: ["postText"] } } }
        ];

        const response = await fetch(`${url}/v1/chat/completions`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` }, body: JSON.stringify({ model, messages, temperature: parseFloat(temperature) || 1.0, tools: tools, tool_choice: "auto" }) });
        if (!response.ok) throw new Error(`API请求失败: ${response.status}`);
        const data = await response.json();
        const aiResponse = data.choices[0].message;
        console.log('【AI 原始回复】:', aiResponse);
        
        if (aiResponse.tool_calls) {
            let typingRowForTransform = null;
            if (initialTypingIndicator) {
                typingRowForTransform = initialTypingIndicator;
                initialTypingIndicator = null;
            }

            for (const toolCall of aiResponse.tool_calls) {
                const functionName = toolCall.function.name;
                const args = JSON.parse(toolCall.function.arguments);
                
                // sendMessage 有特殊的分段动画逻辑，单独处理
                if (functionName === 'sendMessage') {
                    for (const [messageIndex, messageText] of args.messages.entries()) {
                        if (!messageText) continue;
                        const typingDelay = Math.min(Math.max(messageText.length * 800, 1000), 4000);
                        
                        let typingRow;
                        if (messageIndex === 0 && typingRowForTransform) {
                            typingRow = typingRowForTransform;
                            typingRowForTransform = null; // 消耗掉
                        } else {
                            typingRow = showTypingIndicator(contact);
                            setTimeout(() => chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'smooth' }), 10);
                        }

                        await new Promise(resolve => setTimeout(resolve, typingDelay));

                        if (typingRow) {
                            const bubble = typingRow.querySelector('.chat-bubble');
                            if (bubble) {
                                bubble.innerHTML = '';
                                bubble.textContent = messageText;
                            }
                            typingRow.classList.remove('typing-indicator');
                        }
                        
                        const aiMessage = { sender: 'ai', text: messageText, timestamp: new Date(), uuid: Date.now() + '-' + Math.random().toString(36).substr(2, 9) };
                        await saveMessageToHistory(aiMessage, contactId);
                    }
                    continue; // sendMessage 处理完后进入下一次循环
                }
                
                // 对于其他所有工具，如果存在初始动画，先移除它
                if (typingRowForTransform) {
                    typingRowForTransform.remove();
                    typingRowForTransform = null;
                }

                // 按照您指定的顺序处理其他工具
                switch (functionName) {
                    case 'sendSticker':
                        const stickerTypingIndicator = showTypingIndicator(contact);
                        setTimeout(() => chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'smooth' }), 10);
                        await new Promise(resolve => setTimeout(resolve, 1500));
                        if (stickerTypingIndicator) stickerTypingIndicator.remove();
                        
                        const stickerUrl = stickerMap.get(args.description);
                        if (stickerUrl) {
                            const stickerMessage = { sender: 'ai', type: 'sticker', url: stickerUrl, text: `[表情包：${args.description}]`, timestamp: new Date(), uuid: Date.now() + '-' + Math.random().toString(36).substr(2, 9) };
                            addMessageToView(stickerMessage, contact);
                            await saveMessageToHistory(stickerMessage, contactId);
                        }
                        break;

                    case 'createSocialPost':
                        await createAiPost(contact, args.postText, args.imageDescription);
                        renderAllPosts();
                        break;

                    case 'addCommentToPost':
                        const postIdForComment = contextData.postId || args.postId;
                        const replyToUsername = contextData.replyToUsername || null;
                        if (!postIdForComment) {
                            console.error("Tool call 'addCommentToPost' 失败: postId 缺失。");
                            break; 
                        }
                        await addComment(postIdForComment, args.commentText, replyToUsername, contact);
                        renderAllPosts();
                        break;
                    
                    case 'likeComment':
                        const postIdForLike = contextData.postId || args.postId;
                        if (!postIdForLike) {
                            console.error("Tool call 'likeComment' 失败: postId 缺失。");
                            break;
                        }
                        await likeCommentById(postIdForLike, args.commentId, contact.id);
                        renderAllPosts();
                        break;

                    case 'makeTransfer':
                        const transferTypingIndicator = showTypingIndicator(contact);
                        setTimeout(() => chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'smooth' }), 10);
                        await new Promise(resolve => setTimeout(resolve, 1500));
                        if (transferTypingIndicator) transferTypingIndicator.remove();

                        const transferMessage = { sender: 'ai', text: `[TRANSFER_START]${args.remark}-${args.amount}[TRANSFER_END]`, timestamp: new Date(), uuid: Date.now() + '-' + Math.random().toString(36).substr(2, 9) };
                        addMessageToView(transferMessage, contact);
                        await saveMessageToHistory(transferMessage, contactId);
                        break;

                    case 'acceptListenInvite':
                        const acceptMessageText = args.message;
                        if (acceptMessageText) {
                            const typingRow = showTypingIndicator(contact);
                            setTimeout(() => chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'smooth' }), 10);

                            const typingDelay = Math.min(Math.max(acceptMessageText.length * 800, 1000), 4000);
                            await new Promise(resolve => setTimeout(resolve, typingDelay));

                            if(typingRow) {
                                const bubble = typingRow.querySelector('.chat-bubble');
                                if(bubble) {
                                    bubble.innerHTML = '';
                                    bubble.textContent = acceptMessageText;
                                }
                                typingRow.classList.remove('typing-indicator');
                            }
                            const aiMessage = { sender: 'ai', text: acceptMessageText, timestamp: new Date(), uuid: Date.now() + '-' + Math.random().toString(36).substr(2, 9) };
                            await saveMessageToHistory(aiMessage, contactId);
                        }
                        if (sharedListeningState.active === false) {
                            sharedListeningState.active = true;
                            sharedListeningState.contact = currentOpenContact;
                            await showSystemNotification(`${currentOpenContact.ai.name} 加入了一起听`, currentOpenContact.id);
                            updateSharedListeningUI();
                        }
                        break;
                }
            }
        
        } else if (aiResponse.content) {
            if (initialTypingIndicator) {
                const bubble = initialTypingIndicator.querySelector('.chat-bubble');
                if (bubble) {
                    bubble.innerHTML = '';
                    bubble.textContent = aiResponse.content;
                }
                const fallbackMessage = { sender: 'ai', text: aiResponse.content, timestamp: new Date(), uuid: Date.now() + '-' + Math.random().toString(36).substr(2, 9) };
                await saveMessageToHistory(fallbackMessage, contactId);
                chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'smooth' });
            }
        } else {
            if (initialTypingIndicator) initialTypingIndicator.remove();
        }

    } catch (error) {
        console.error("调用AI失败:", error);
        if (initialTypingIndicator) initialTypingIndicator.remove();
        alert(`AI回复失败: ${error.message}`);
    } finally {
        isAiReplying = false;
    }
}
        // 你需要实现 saveMessageToHistory 函数，它应该像这样：
        // ===================================
        // 这是新的、简化的 saveMessageToHistory
        // ===================================
        async function saveMessageToHistory(message, contactId) {
            // 确保我们操作的是当前打开的联系人
            if (!currentOpenContact || currentOpenContact.id !== contactId) return;

            // 1. 确保 history 数组存在
            if (!Array.isArray(currentOpenContact.history)) {
                currentOpenContact.history = [];
            }

            // 2. 直接修改内存中的 currentOpenContact 对象
            currentOpenContact.history.push(message);
            currentOpenContact.lastMessage = cleanMessageForPreview(message.text);

            // 3. 调用新的主保存函数来处理数据库同步
            await saveCurrentContactToDatabase();

            // --- 【核心新增】在这里植入我们的触发器 ---
    const totalMessages = currentOpenContact.history.length;
    // 为方便测试，设置为5条。您可以后续将 5 改为 50
    if (totalMessages > 0 && totalMessages % 50 === 0) {
        // 调用新的触发函数
        triggerAiSocialPost(currentOpenContact);
    }

            // 4. (可选) 实时更新消息列表页的预览
            const contactItemInList = contactList.querySelector(`.contact-item[data-contact-id="${contactId}"]`);
            if (contactItemInList) {
                contactItemInList.querySelector('.contact-last-message').textContent = currentOpenContact.lastMessage;
            }
        }
        // === AI功能修改：发送消息的总控函数 ===
        // 用这个新版本替换旧的 sendMessage 函数
        async function sendMessage(messageData) {
            if (!currentOpenContact) return;

            let messageObject;

            // 判断传入的是纯文本还是一个带类型的对象
            if (typeof messageData === 'string') {
                if (!messageData.trim()) return; // 如果是空字符串，则不发送
                messageObject = { type: 'text', text: messageData.trim() };
            } else {
                messageObject = messageData;
            }

            // 组合成完整的用户消息，包含发送者、时间戳等信息
            const userMessage = {
                sender: 'user',
                timestamp: new Date(),
                uuid: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
                ...messageObject // 将 type, text, url 等属性合并进来
            };

            // 1. 立即在界面上显示（addMessageToView 稍后会升级）
            addMessageToView(userMessage);

            // 2. 将完整的消息对象存入数据库
            await saveMessageToHistory(userMessage, currentOpenContact.id);

            // 3. 将消息的 .text 属性发送给 AI
            if (messageObject.type !== 'sticker') {
                await callAI(userMessage.text, currentOpenContact);
            }


            // 清空输入框（如果是通过输入框发送的话）
            chatMessageInput.value = '';
        }


        // === AI功能新增：逐条延时显示AI消息的函数 ===

        /**
         * 解释：
         * 这个函数接收一个包含多条消息文本的数组，然后逐条显示它们。
         * 'async' 和 'await' 的使用让我们可以轻松地在循环中实现延时。
         * @param {string[]} messages - AI回复的纯文本消息数组
         */
        //
        // 粘贴这两个全新的函数
        //

        /**
         * 功能1：创建一个包含“正在输入”动画的AI气泡，并返回该气泡元素的引用
         */
        function createTypingBubble() {
            const row = document.createElement('div');
            row.className = 'message-row ai';

            const avatar = document.createElement('img');
            avatar.className = 'chat-avatar';
            avatar.src = currentOpenContact.ai.avatar;
            const avatarSettings = currentOpenContact.avatarSettings || { radius: '50%' };
            avatar.style.borderRadius = avatarSettings.radius;

            const bubble = document.createElement('div');
            bubble.className = 'chat-bubble ai-bubble';
            bubble.innerHTML = `
        <div class="typing-animation">
            <span class="typing-dot"></span>
            <span class="typing-dot"></span>
            <span class="typing-dot"></span>
        </div>
    `;

            row.appendChild(avatar);
            row.appendChild(bubble);
            chatMessagesContainer.appendChild(row);
            chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;

            return bubble; // 返回这个新创建的气泡元素，以便后续修改
        }

        /**
         * 功能2（全新版本）：逐条显示AI消息，并实现“先显示动画，再填充文字”的动态效果
         */

        // 这是 displayAiMessagesSequentially 函数的【新版】，能处理预先创建的加载动画
        //
        async function displayAiMessagesSequentially(messages, initialBubble) {
            // 使用 .entries() 来同时获取消息的索引和内容
            for (const [index, text] of messages.entries()) {
                if (!text) continue;

                let currentBubble;

                // 判断使用哪个气泡：
                // 如果是第一条消息 (index === 0)，就使用 callAI 预先创建的那个
                // 如果是后续消息，就新建一个
                if (index === 0) {
                    currentBubble = initialBubble;
                } else {
                    currentBubble = createTypingBubble();
                }

                // 模拟打字延迟
                const typingDelay = Math.min(Math.max(text.length * 800, 1000), 4000);
                await new Promise(resolve => setTimeout(resolve, typingDelay));

                // 将动画替换为真实的文字内容
                currentBubble.innerHTML = '';
                currentBubble.textContent = text;

                // 保存到历史记录
                const aiMessage = {
                    sender: 'ai',
                    text: text,
                    timestamp: new Date()
                };
                await saveMessageToHistory(aiMessage);
            }
        }
        // --- 功能 A: 打开聊天界面 (已更新，只加载最新的30条) ---
// === openChatView (V3 - 支持直接跳转定位) ===
// 用这个新版本替换你现有的 openChatView 函数

async function openChatView(contactId, options = {}) {
    setTimeout(() => {
        chatScreen.classList.remove('emoji-panel-active');
    }, 0);

    const contactsData = await dbHelper.loadData('messageContacts', 'allContacts');
    if (!contactsData || !Array.isArray(contactsData.value)) {
        console.error("无法加载联系人数据"); return;
    }
    currentOpenContact = contactsData.value.find(c => c.id === contactId);
    if (!currentOpenContact) {
        console.error(`找不到 ID 为 ${contactId} 的联系人`); return;
    }

    applyChatViewSettings(currentOpenContact);
    chatContactName.textContent = currentOpenContact.ai.name;
    
    // ▼▼▼ 优化开始 ▼▼▼

    // 1. 在开始渲染前，先将消息容器隐藏
    chatMessagesContainer.style.visibility = 'hidden';

    chatMessagesContainer.innerHTML = ''; // 清空旧消息

    const history = Array.isArray(currentOpenContact.history) ? currentOpenContact.history : [];

    if (options.targetMessageUuid) {
        // 跳转模式：一次性渲染所有历史记录（因为是隐藏的，所以用户看不到渲染过程）
        history.forEach(message => {
            addMessageToView(message);
        });
    } else {
        // 普通模式：加载最新消息和“加载更早”按钮
        if (history.length > 30) {
            const loadMoreBtn = document.createElement('button');
            loadMoreBtn.id = 'load-more-messages-btn';
            loadMoreBtn.className = 'header-text-button';
            loadMoreBtn.textContent = '查看更早的消息';
            loadMoreBtn.style.margin = '15px auto';
            loadMoreBtn.addEventListener('click', loadMoreMessages);
            chatMessagesContainer.appendChild(loadMoreBtn);
        }
        const initialMessages = history.slice(-30);
        initialMessages.forEach(message => { addMessageToView(message); });
    }
    
    phoneFrame.classList.add('show-chat');

    setTimeout(() => {
        if (options.targetMessageUuid) {
            const targetMessage = chatMessagesContainer.querySelector(`.message-row[data-uuid="${options.targetMessageUuid}"]`);
            if (targetMessage) {
                // 2. 在容器仍然隐藏的状态下，瞬间完成滚动定位
                targetMessage.scrollIntoView({ behavior: 'auto', block: 'center' });
                targetMessage.classList.add('message-highlight');
                setTimeout(() => {
                    targetMessage.classList.remove('message-highlight');
                }, 1500);
            }
        } else {
            chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'auto' });
        }

        // 3. 在一切都准备就绪后，再将容器设为可见
        chatMessagesContainer.style.visibility = 'visible';
        
    }, 50); 
    // ▲▲▲ 优化结束 ▲▲▲
}

        // 重新修改 loadMoreMessages 函数



// === loadMoreMessages (V3 - 调用统一渲染函数) ===
async function loadMoreMessages() {
    if (!currentOpenContact) return;
    const loadMoreBtn = document.getElementById('load-more-messages-btn');
    if (!loadMoreBtn) return;

    const oldScrollHeight = chatMessagesContainer.scrollHeight;
    const history = Array.isArray(currentOpenContact.history) ? currentOpenContact.history : [];
    const messagesInViewCount = chatMessagesContainer.querySelectorAll('.message-row').length;
    const endIndex = history.length - messagesInViewCount;
    if (endIndex <= 0) {
        loadMoreBtn.remove();
        return;
    }

    const startIndex = Math.max(0, endIndex - 30);
    const messagesToAdd = history.slice(startIndex, endIndex).reverse(); // 反转数组，以便从旧到新插入

    messagesToAdd.forEach(message => {
        const messageElement = addMessageToView(message); // 调用新的、功能完整的函数
        if (messageElement) {
            loadMoreBtn.after(messageElement); // 将新消息插入到按钮之后
        }
    });

    const newScrollHeight = chatMessagesContainer.scrollHeight;
    chatMessagesContainer.scrollTop += (newScrollHeight - oldScrollHeight);

    if (startIndex === 0) {
        loadMoreBtn.remove();
    }
}

// 请在您的代码中找到并【彻底删除】旧的 createMessageElement 函数


        // --- 功能 B: 关闭聊天界面 ---
        function closeChatView() {
            scrollToBottomBtn.classList.remove('visible');
            phoneFrame.classList.remove('show-chat');
            // 动画结束后清理数据，防止下次打开时闪烁旧内容
            setTimeout(() => {
                currentOpenContact = null;
            }, 350); // 动画时长为350ms
        }

        // --- 功能 C: 绑定事件 ---

        // 使用“事件委托”来处理联系人列表的点击事件。
        // 这样做的好处是，即使是动态添加的联系人，点击事件也同样有效。
        contactList.addEventListener('click', (event) => {
            // 如果当前处于删除模式，并且点击的是复选框，则不进入聊天
            if (contactList.classList.contains('delete-mode') && event.target.classList.contains('contact-checkbox')) {
                return;
            }

            // 查找被点击的、最接近的父级 .contact-item 元素
            const contactItem = event.target.closest('.contact-item');
            if (contactItem) {
                const contactId = parseInt(contactItem.dataset.contactId, 10);
                openChatView(contactId);
            }
        });

        // 为聊天界面的返回按钮绑定点击事件
        chatBackButton.addEventListener('click', closeChatView);

        // (可选) 为发送按钮添加一个简单的打印功能，为后续开发做准备
        // === 更新：“发送”按钮的点击事件 (最终版) ===
        // ===================================
        // THIS IS THE NEW, CORRECTED CODE
        // ===================================
        chatSendButton.addEventListener('click', async () => {
            const messageText = chatMessageInput.value.trim();
            if (!messageText || !currentOpenContact) {
                return;
            }

            // 1. 构造一个完整的消息对象
            const userMessage = {
                sender: 'user',
                text: messageText,
                timestamp: new Date(),
                uuid: Date.now() + '-' + Math.random().toString(36).substr(2, 9)
            };

            // 2. 清空输入框并立即在UI上显示
            chatMessageInput.value = '';
            addMessageToView(userMessage);
            // ▼▼▼ 在这里添加平滑滚动 ▼▼▼
    chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'smooth' });

            // 3. 调用唯一的、可靠的保存函数来处理数据库
            await saveMessageToHistory(userMessage, currentOpenContact.id);

        });
        // === 监听聊天输入框的回车键事件 ===
        chatMessageInput.addEventListener('keydown', (event) => {
            // 检查按下的键是否是 "Enter"
            if (event.key === 'Enter') {
                // 阻止 "Enter" 键的默认行为（例如换行或提交表单）
                event.preventDefault();

                // 模拟一次点击发送按钮的操作
                chatSendButton.click();
            }
        });
        // === 新增：聊天设置弹出层的全部逻辑 ===

        const defaultBubbleCss = `.user-bubble {
    background-color: #007AFF;
    color: white;
    border-bottom-right-radius: 4px;
    align-self: flex-end;
}
.ai-bubble {
    background-color: #E5E5EA;
    color: black;
    border-bottom-left-radius: 4px;
    align-self: flex-start;
}`;

        // --- 功能 A: 打开和关闭设置弹出层 ---
        // === 更新 openChatSettingsModal (支持世界书多选) ===
        async function openChatSettingsModal() {
            if (!currentOpenContact) return;

            // --- 加载角色信息等 (这部分不变) ---
            aiAvatarPreviewSettings.src = currentOpenContact.ai.avatar;
            aiNameInputSettings.value = currentOpenContact.ai.name;
            aiPersonaInputSettings.value = currentOpenContact.ai.persona;
            userAvatarPreviewSettings.src = currentOpenContact.user.avatar;
            userNameInputSettings.value = currentOpenContact.user.name;
            userPersonaInputSettings.value = currentOpenContact.user.persona;
            contextMemoryInputSettings.value = currentOpenContact.contextMemory || 10;
            bubbleCssInput.value = currentOpenContact.customBubbleCss || defaultBubbleCss;
            const avatarSettings = currentOpenContact.avatarSettings || { show: true, radius: '50%' };
            showAvatarsToggle.checked = avatarSettings.show;
            avatarRadiusInput.value = avatarSettings.radius;

            // --- 核心修改：加载并渲染世界书多选列表 ---
            const container = document.getElementById('worldbook-multiselect-container');
            container.innerHTML = ''; // 清空旧的选项

            try {
                const worldbookData = await dbHelper.loadData('worldBooks', 'allWorldBooks');
                const allBooks = (worldbookData && Array.isArray(worldbookData.value)) ? worldbookData.value : [];

                // 获取当前对话已关联的世界书ID数组
                const linkedBookIds = new Set(currentOpenContact.linkedWorldBookIds || []);

                if (allBooks.length > 0) {
                    allBooks.forEach(book => {
                        const item = document.createElement('div');
                        item.className = 'multiselect-item';

                        const isChecked = linkedBookIds.has(book.id); // 判断是否应该被勾选

                        item.innerHTML = `
                    <input type="checkbox" id="book-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}>
                    <label for="book-${book.id}">${book.name}</label>
                `;
                        container.appendChild(item);
                    });
                } else {
                    container.innerHTML = '<span style="color: #888; font-size: 13px;">暂无世界书</span>';
                }

            } catch (error) {
                console.error("加载世界书到设置失败:", error);
                container.innerHTML = '<span style="color: red; font-size: 13px;">加载失败</span>';
            }

            // --- 显示弹窗 (这部分不变) ---
            chatSettingsModal.style.display = 'flex';
            setTimeout(() => {
                chatSettingsModal.style.opacity = '1';
                chatSettingsModal.querySelector('.modal-content').style.transform = 'scale(1)';
            }, 10);
        }

        function closeChatSettingsModal() {
            chatSettingsModal.style.opacity = '0';
            chatSettingsModal.querySelector('.modal-content').style.transform = 'scale(0.95)';
            setTimeout(() => {
                chatSettingsModal.style.display = 'none';
            }, 300);
        }

        chatSettingsButton.addEventListener('click', openChatSettingsModal);
        chatSettingsCloseBtn.addEventListener('click', closeChatSettingsModal);

        // --- 功能 B: 绑定设置弹出层内部的各种交互 ---

        // 角色切换
        roleSwitchCheckboxSettings.addEventListener('change', () => {
            const isUser = roleSwitchCheckboxSettings.checked;
            aiFormSettings.classList.toggle('active', !isUser);
            userFormSettings.classList.toggle('active', isUser);
            const settingsSwitchLabels = chatSettingsModal.querySelectorAll('.switch-label');
            settingsSwitchLabels[0].classList.toggle('active', !isUser);
            settingsSwitchLabels[1].classList.toggle('active', isUser);
        });

        // 头像上传
        aiAvatarInputSettings.addEventListener('change', () => handleAvatarUpload(aiAvatarInputSettings, aiAvatarPreviewSettings));
        userAvatarInputSettings.addEventListener('change', () => handleAvatarUpload(userAvatarInputSettings, userAvatarPreviewSettings));

        // 恢复默认气泡样式
        restoreBubbleCssBtn.addEventListener('click', () => {
            bubbleCssInput.value = defaultBubbleCss;
        });

        // 聊天背景
        uploadChatBgBtn.addEventListener('click', () => chatBgUploadInput.click());
        chatBgUploadInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    // 这是一个临时预览，保存时才会真正生效
                    chatScreen.style.backgroundImage = `url(${e.target.result})`;
                };
                reader.readAsDataURL(file);
            }
        });
        resetChatBgBtn.addEventListener('click', () => {
            chatScreen.style.backgroundImage = 'none';
            chatScreen.style.backgroundColor = '#f0f2f5';
        });

        // === 修正版：清空聊天记录功能 (增加数据库操作) ===
        clearHistoryBtn.addEventListener('click', async () => {
            if (!currentOpenContact) return;

            if (confirm('警告：此操作将永久删除此对话的所有聊天记录，且无法恢复。确定要继续吗？')) {
                try {
                    // 1. **从数据库加载最新的完整联系人列表**
                    const allContactsData = await dbHelper.loadData('messageContacts', 'allContacts');
                    let allContacts = allContactsData.value || [];
                    const contactIndex = allContacts.findIndex(c => c.id === currentOpenContact.id);

                    if (contactIndex > -1) {
                        // 2. **清空该联系人的历史记录，并更新最后一条消息**
                        allContacts[contactIndex].history = [];
                        allContacts[contactIndex].lastMessage = "聊天记录已清空";

                        // 3. **将修改后的完整联系人列表，存回数据库**
                        await dbHelper.saveData('messageContacts', 'allContacts', allContacts);

                        // 4. **更新当前内存中的数据和UI**
                        currentOpenContact.history = [];
                        currentOpenContact.lastMessage = "聊天记录已清空";
                        chatMessagesContainer.innerHTML = ''; // 清空聊天界面

                        // 5. 更新消息列表页的预览
                        const contactItemInList = contactList.querySelector(`.contact-item[data-contact-id="${currentOpenContact.id}"]`);
                        if (contactItemInList) {
                            contactItemInList.querySelector('.contact-last-message').textContent = "聊天记录已清空";
                        }

                        alert('聊天记录已成功清除！');
                    } else {
                        throw new Error("在数据库中找不到当前联系人。");
                    }
                } catch (error) {
                    console.error("清除聊天记录失败:", error);
                    alert(`操作失败: ${error.message}`);
                }
            }
        });


        // 找到你已有的 saveChatSettingsBtn 事件监听器，并用下面的代码替换其内部逻辑：

        saveChatSettingsBtn.addEventListener('click', async () => {
            if (!currentOpenContact) return;

            try {
                // --- 修复开始 ---

                // 步骤 1: 从数据库加载完整的联系人数组。
                const allContactsData = await dbHelper.loadData('messageContacts', 'allContacts');
                let allContacts = (allContactsData && Array.isArray(allContactsData.value)) ? allContactsData.value : [];

                // 步骤 2: 在该数组中找到我们需要更新的那个联系人。
                const contactIndex = allContacts.findIndex(c => c.id === currentOpenContact.id);

                if (contactIndex > -1) {
                    // 步骤 3: 将设置弹窗中的所有新信息应用到那个联系人对象上。

                    // 更新 AI/用户信息
                    allContacts[contactIndex].ai.name = aiNameInputSettings.value.trim();
                    allContacts[contactIndex].ai.persona = aiPersonaInputSettings.value.trim();
                    allContacts[contactIndex].ai.avatar = aiAvatarPreviewSettings.src;
                    allContacts[contactIndex].user.name = userNameInputSettings.value.trim();
                    allContacts[contactIndex].user.persona = userPersonaInputSettings.value.trim();
                    allContacts[contactIndex].user.avatar = userAvatarPreviewSettings.src;
                    allContacts[contactIndex].contextMemory = parseInt(contextMemoryInputSettings.value, 10);

                    // 更新个性化设置
                    allContacts[contactIndex].customBubbleCss = bubbleCssInput.value;
                    allContacts[contactIndex].avatarSettings = {
                        show: showAvatarsToggle.checked,
                        radius: avatarRadiusInput.value.trim() || '50%'
                    };
                    const bgImage = chatScreen.style.backgroundImage;
                    allContacts[contactIndex].chatBackground = bgImage.includes('url') ? bgImage : null;



                    // 收集所有被勾选的世界书ID
                    const selectedWorldBookIds = [];
                    const checkedBooks = document.querySelectorAll('#worldbook-multiselect-container input:checked');
                    checkedBooks.forEach(checkbox => {
                        selectedWorldBookIds.push(parseInt(checkbox.value, 10));
                    });

                    // 将收集到的ID数组存入联系人对象
                    allContacts[contactIndex].linkedWorldBookIds = selectedWorldBookIds;



                    // 同时，也要更新内存中的 'currentOpenContact' 变量，这样UI可以立即正确刷新
                    currentOpenContact = allContacts[contactIndex];
                } else {
                    // 如果因为某些原因找不到联系人，就停止并报错。
                    throw new Error("在数据库中找不到要保存的联系人。");
                }

                // 步骤 4: 将整个修改后的 'allContacts' 数组完整地保存回数据库。
                await dbHelper.saveData('messageContacts', 'allContacts', allContacts);

                // --- 修复结束 ---


                // 现在，你其余的UI更新代码可以照常运行。
                // 它们会使用刚刚被更新过的 'currentOpenContact' 对象。
                applyChatViewSettings(currentOpenContact);
                chatContactName.textContent = currentOpenContact.ai.name;

                // 更新主消息列表中的名称和头像
                const contactItemInList = contactList.querySelector(`.contact-item[data-contact-id="${currentOpenContact.id}"]`);
                if (contactItemInList) {
                    contactItemInList.querySelector('.contact-name').textContent = currentOpenContact.ai.name;
                    contactItemInList.querySelector('.contact-avatar').src = currentOpenContact.ai.avatar;
                }

                closeChatSettingsModal();
                alert('设置已成功保存！');

            } catch (error) {
                console.error("保存聊天设置失败:", error);
                alert(`保存失败: ${error.message}`);
            }
        });
        // --- 功能 D: 应用所有聊天视图的个性化设置 (已更新) ---
        function applyChatViewSettings(contact) {
            // 应用气泡样式
            customBubbleStyles.innerHTML = contact.customBubbleCss || defaultBubbleCss;

            // 应用聊天背景
            if (contact.chatBackground) {
                chatScreen.style.backgroundImage = contact.chatBackground;
            } else {
                chatScreen.style.backgroundImage = 'none';
                chatScreen.style.backgroundColor = '#f0f2f5';
            }

            // 应用头像显示设置
            const avatarSettings = contact.avatarSettings || { show: true, radius: '50%' };
            chatMessagesContainer.classList.toggle('hide-avatars', !avatarSettings.show);

            // --- 新增的关键修复 ---
            // 实时更新当前屏幕上所有头像的圆角
            const allAvatars = document.querySelectorAll('#chat-messages-container .chat-avatar');
            allAvatars.forEach(avatar => {
                avatar.style.borderRadius = avatarSettings.radius;
            });
        }
        /**
         * 新增：净化消息文本，用于在联系人列表生成预览
         * @param {string} text - 原始消息文本
         * @returns {string} - 清理掉特殊标签后的预览文本
         */
        function cleanMessageForPreview(text) {
            if (typeof text !== 'string') return '';

            if (text.includes('[STICKER_START]')) {
        return '[AI表情包]';
    }

            // 优先匹配 [MESSAGE_START]...[MESSAGE_END] 格式，并提取中间的内容
            const messageMatch = text.match(/\[MESSAGE_START\]([\s\S]*?)\[MESSAGE_END\]/);
            if (messageMatch && messageMatch[1]) {
                return messageMatch[1].trim(); // 返回指令中间的纯文本
            }

            // 如果是转账指令，显示为 "[转账]"
            if (text.includes('[TRANSFER_START]')) {
                return '[转账]';
            }

            // 如果是一起听邀请，显示为 "[一起听邀请]"
            if (text.includes('[MUSIC_SHARE]')) {
                return '[一起听邀请]';
            }

            // 如果没有匹配到任何特殊指令（例如用户自己发的消息），则原样返回
            return text;
        }
        /**
        * 功能：将消息添加到视图中
        * (根据用户提供的最新设计蓝图更新转账卡片样式)
        */
 // === addMessageToView (V4 - 完整功能最终版) ===
function addMessageToView(message, contact = null) {
    if (!message || typeof message.text !== 'string') {
        console.warn("尝试渲染一个无效的消息对象，已跳过:", message);
        return null; // 返回 null，表示没有创建任何元素
    }

    // 系统消息是特殊的，它不使用标准的气泡结构
    if (message.type === 'system') {
        const notification = document.createElement('div');
        notification.className = 'system-notification';
        notification.textContent = message.text;
        chatMessagesContainer.appendChild(notification);
        return notification; // 创建后直接返回
    }

    // --- 标准消息气泡的创建流程 ---
    const activeContact = contact || currentOpenContact;
    const settings = (activeContact && activeContact.avatarSettings) || { show: true, radius: '50%' };
    const row = document.createElement('div');
    row.className = 'message-row';
    if (message.uuid) { row.dataset.uuid = message.uuid; }

    const indicator = document.createElement('div');
    indicator.className = 'selection-indicator';
    row.appendChild(indicator);

    const wrapper = document.createElement('div');
    wrapper.className = 'message-content-wrapper';

    const avatar = document.createElement('img');
    avatar.className = 'chat-avatar';
    avatar.style.borderRadius = settings.radius;

    if (message.sender === 'user') {
        wrapper.classList.add('user');
        avatar.src = (activeContact && activeContact.user) ? activeContact.user.avatar : '';
    } else if (message.sender === 'ai') {
        wrapper.classList.add('ai');
        avatar.src = (activeContact && activeContact.ai) ? activeContact.ai.avatar : '';
    }

    let contentElement; // 这个变量将用来存放最终显示的内容（气泡、卡片等）

    // --- 统一渲染逻辑判断 ---
    const transferRegex = /\[TRANSFER_START\]([\s\S]*?)-(\d*\.?\d+)\[TRANSFER_END\]/;
    const musicShareRegex = /\[MUSIC_SHARE\]/; // 为“一起听”定义正则表达式
    const transferMatch = message.text.match(transferRegex);

    if (message.type === 'sticker' && message.url) {
        contentElement = document.createElement('img');
        contentElement.src = message.url;
        contentElement.className = 'chat-bubble sticker-bubble';
    } 
    // ▼▼▼ START: 补回“一起听”卡片渲染逻辑 ▼▼▼
    else if (musicShareRegex.test(message.text)) {
        contentElement = document.createElement('div');
        contentElement.className = 'listen-invite-card';
        contentElement.innerHTML = `
            <div style="width: 200px; height: 100px; position: relative; background: white; box-shadow: 0px 4px 6.099999904632568px rgba(0, 0, 0, 0.05); overflow: hidden; border-radius: 24px">
                <div style="left: 46px; top: 18px; position: absolute"><span style="color: black; font-size: 13px; font-family: Inter; font-weight: 400; word-wrap: break-word">邀请你加入 </span><span style="color: black; font-size: 13px; font-family: Inter; font-weight: 700; word-wrap: break-word">一起听</span></div>
                <div style="left: 18px; top: 46px; position: absolute; color: #BDBDBD; font-size: 10px; font-family: Inter; font-weight: 400; word-wrap: break-word">我的耳机分你一半</div>
                <div style="width: 153px; height: 0px; left: 18px; top: 42px; position: absolute; outline: 1px var(--Miscellaneous-Button---Disabeld-BG, rgba(118, 118, 128, 0.12)) solid; outline-offset: -0.50px"></div>
                <svg width="16" height="19" viewBox="0 0 16 19" fill="none" xmlns="http://www.w3.org/2000/svg" style="position: absolute; left: 20px; top: 19px;"> 
                    <path d="M4.63158 18.5263C7.18953 18.5263 9.26316 16.4527 9.26316 13.8947C9.26316 11.3368 7.18953 9.26315 4.63158 9.26315C2.07363 9.26315 0 11.3368 0 13.8947C0 16.4527 2.07363 18.5263 4.63158 18.5263Z" fill="black"/> 
                    <rect x="6.73682" y="2.52631" width="2.52632" height="10.9474" fill="black"/> 
                    <rect x="6.73682" width="9.26316" height="5.05263" rx="2" fill="black"/> 
                </svg>
                <div style="width: 321px; height: 226px; left: 63px; top: -170px; position: absolute; opacity: 0.08; background: #007AFF; box-shadow: 10px 10px 10px; border-radius: 9999px; filter: blur(5px)"></div>
                <div style="left: 83px; top: 79px; position: absolute; color: #BDBDBD; font-size: 10px; font-family: Inter; font-weight: 300; word-wrap: break-word">FROM MUSIC APP</div>
            </div>
        `;
    }
    // ▲▲▲ END: 补回“一起听”卡片渲染逻辑 ▲▲▲
    else if (message.text.includes('[ORDER_SHARE_CARD]')) {
        contentElement = document.createElement('div');
        contentElement.innerHTML = `<div style="width: 200px; height: 100px; position: relative; background: white; box-shadow: 0px 4px 6.099999904632568px rgba(0, 0, 0, 0.05); overflow: hidden; border-radius: 24px"><div style="left: 18px; top: 18px; position: absolute; color: black; font-size: 13px; font-family: Inter; font-weight: 400; word-wrap: break-word">分享商品订单</div><div style="left: 18px; top: 46px; position: absolute; color: #BDBDBD; font-size: 10px; font-family: Inter; font-weight: 400; word-wrap: break-word">快看看是什么吧？</div><div style="width: 153px; height: 0px; left: 18px; top: 42px; position: absolute; outline: 1px var(--Miscellaneous-Button---Disabeld-BG, rgba(118, 118, 128, 0.12)) solid; outline-offset: -0.50px"></div><div style="left: 103px; top: 79px; position: absolute; color: #BDBDBD; font-size: 10px; font-family: Inter; font-weight: 300; word-wrap: break-word">FROM 7 SHOP</div></div>`;
    }
    else if (transferMatch) {
        const remark = transferMatch[1].trim();
        const amount = parseFloat(transferMatch[2]).toFixed(2);
        contentElement = document.createElement('div');
        contentElement.style.cssText = "width: 200px; height: 100px; position: relative; background: white; overflow: hidden; border-radius: 24px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);";
        contentElement.innerHTML = `<div style="left: 23px; top: 11px; position: absolute; color: black; font-size: 16px; font-family: sans-serif; font-weight: 500; word-wrap: break-word">转账</div><div style="left: 23px; top: 42px; position: absolute; color: #AFAFAF; font-size: 11px; font-family: sans-serif; font-weight: 400; word-wrap: break-word">${remark}</div><div style="width: 130px; height: 22px; left: 20px; top: 64px; position: absolute; color: black; font-size: 20px; font-family: sans-serif; font-weight: 500; word-wrap: break-word">¥ ${amount}</div><div style="width: 160px; height: 0px; left: 20px; top: 37px; position: absolute; border: 0.5px solid rgba(118, 118, 128, 0.12);"></div><div style="width: 24px; height: 24px; left: 156px; top: 8px; position: absolute;"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.295 16.705L12.585 12.415L8.295 8.125C8.1067 7.9367 8.00091 7.6813 8.00091 7.415C8.00091 7.1487 8.1067 6.89331 8.295 6.705C8.48331 6.5167 8.7387 6.41091 9.005 6.41091C9.2713 6.41091 9.5267 6.5167 9.715 6.705L14.715 11.705C14.8087 11.798 14.8831 11.9086 14.9339 12.0304C14.9847 12.1523 15.0108 12.283 15.0108 12.415C15.0108 12.547 14.9847 12.6777 14.9339 12.7996C14.8831 12.9214 14.8087 13.032 14.715 13.125L9.715 18.125C9.62204 18.2187 9.50144 18.2931 9.36958 18.3439C9.23772 18.3947 9.09699 18.4208 8.955 18.4208C8.81301 18.4208 8.67228 18.3947 8.54042 18.3439C8.40856 18.2931 8.28796 18.2187 8.195 18.125C8.0067 17.9367 7.90091 17.6813 7.90091 17.415C7.90091 17.1487 8.0067 16.8933 8.195 16.705L8.295 16.705Z" fill="#363636"/></svg></div>`;
    }
    else { // 默认渲染普通文本气泡
        contentElement = document.createElement('div');
        contentElement.className = 'chat-bubble';
        if (message.sender === 'user') contentElement.classList.add('user-bubble');
        else contentElement.classList.add('ai-bubble');
        
        let visibleText = message.text;
        const messageMatch = message.text.match(/\[MESSAGE_START\]([\s\S]*?)\[MESSAGE_END\]/);
        if (messageMatch && messageMatch[1]) {
            visibleText = messageMatch[1].trim();
        }
        contentElement.textContent = visibleText;
    }

    if (contentElement) {
         wrapper.appendChild(avatar);
         wrapper.appendChild(contentElement);
         row.appendChild(wrapper);
         chatMessagesContainer.appendChild(row);
    }
    
    return row;
}
        // === 新增：“正在输入”提示的JS函数 ===

        /**
         * 功能：在聊天窗口显示一个“正在输入”的动画气泡
         */
        /**
        * 功能：在聊天窗口显示“正在输入”动画，并返回该动画的DOM元素
        * (已修改：移除重复检查，并返回元素本身)
        */
 // 用这个新版本，完整替换你现有的 showTypingIndicator 函数

/**
 * 【已修复】功能：在聊天窗口显示“正在输入”动画，并返回该动画的DOM元素
 * @param {object} contact - 【新增】明确指定是哪个AI正在输入
 * @returns {HTMLElement}
 */
 function showTypingIndicator(contact) {
    if (!contact || !contact.ai) {
        console.error("showTypingIndicator 失败：传入了无效的contact对象。");
        return null;
    }
    // 只在对应的聊天窗口打开时才显示“正在输入”
    if (currentOpenContact && currentOpenContact.id === contact.id) {
        const row = document.createElement('div');
        row.className = 'message-row ai typing-indicator';
        const indicator = document.createElement('div');
        indicator.className = 'selection-indicator';
        row.appendChild(indicator);
        const wrapper = document.createElement('div');
        wrapper.className = 'message-content-wrapper ai';
        const avatar = document.createElement('img');
        avatar.className = 'chat-avatar';
        avatar.src = contact.ai.avatar;
        const avatarSettings = contact.avatarSettings || { radius: '50%' };
        avatar.style.borderRadius = avatarSettings.radius;
        const bubble = document.createElement('div');
        bubble.className = 'chat-bubble ai-bubble';
        bubble.innerHTML = `<div class="typing-animation"><span class="typing-dot"></span><span class="typing-dot"></span><span class="typing-dot"></span></div>`;
        wrapper.appendChild(avatar);
        wrapper.appendChild(bubble);
        row.appendChild(wrapper);

        chatMessagesContainer.appendChild(row);
        chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
        return row;
    }
    return null; // 如果聊天窗口没打开，则不创建任何元素
}
        const moreFeaturesButton = document.getElementById('chat-add-attachment-button');
        const moreFeaturesPanel = document.getElementById('more-features-panel');
        const timePerceptionButton = document.getElementById('time-perception-feature');
        const receiptFeatureButton = document.getElementById('receipt-feature');
        const transferFeatureButton = document.getElementById('transfer-feature');
        const chatMessageInputForReceipt = document.getElementById('chat-message-input'); // 复用聊天输入框的ID


        // === 新增：转账功能所需元素 ===
        const transferModal = document.getElementById('transfer-modal');
        const transferModalCloseBtn = document.getElementById('transfer-modal-close-btn');
        const confirmTransferBtn = document.getElementById('confirm-transfer-btn');
        const transferAmountInput = document.getElementById('transfer-amount-input');
        const transferRemarkInput = document.getElementById('transfer-remark-input');


        // === 最终修复：同时兼容桌面鼠标和移动端触摸 ===
        function toggleFeaturesPanel(event) {
            // 阻止默认行为，如链接跳转或表单提交
            event.preventDefault();
            // 阻止事件冒泡，防止触发父元素的事件
            event.stopPropagation();
            // 切换面板的显示/隐藏
            moreFeaturesPanel.classList.toggle('active');
        }

        // 为同一个函数绑定两个事件
        moreFeaturesButton.addEventListener('click', toggleFeaturesPanel);
        moreFeaturesButton.addEventListener('touchend', toggleFeaturesPanel);

        // 3. 为“回执”功能按钮添加点击事件
        // === 更新：“回执”功能按钮的事件监听 ===

        receiptFeatureButton.addEventListener('click', () => {
    if (!currentOpenContact) {
        alert("请先打开一个对话！");
        return;
    }

    const instructionForAI = "现在轮到你了，请根据我们的历史对话，以及我刚刚发送的所有消息，以你的角色身份进行一次1到6条消息的回复。";
    
    // Just call the AI function. It will handle the animation internally.
    callAI(instructionForAI, currentOpenContact); 
    
    moreFeaturesPanel.classList.remove('active');
});

        // *** 在这里新增下面的代码 ***

        // === 最终正确版：用户向AI转账功能的事件监听 ===
        // === 最新版：用户向AI转账功能的事件监听（使用超简化格式） ===
        // === 更新：“转账”功能按钮，使其打开新弹窗 ===
        transferFeatureButton.addEventListener('click', () => {
            openTransferModal();
            // 点击后立即关闭“更多功能”面板
            moreFeaturesPanel.classList.remove('active');
        });

        // *** 新增代码结束 ***

        // 4. (可选但推荐) 添加一个全局点击事件，用于在点击面板外部区域时关闭面板
        document.addEventListener('click', (event) => {
            // 检查点击的不是面板本身，也不是触发按钮
            if (!moreFeaturesPanel.contains(event.target) && !moreFeaturesButton.contains(event.target)) {
                if (moreFeaturesPanel.classList.contains('active')) {
                    moreFeaturesPanel.classList.remove('active');
                }
            }
        });

        // --- 新增：消息选择和删除功能的核心JS逻辑 ---

        // 1. 全局变量
        let isMessageSelectionMode = false;
        let longPressTimer = null;
        const chatScreenContainer = document.getElementById('chat-screen');

        // 2. 获取新添加的顶栏按钮
        const normalHeaderActions = document.getElementById('chat-header-actions-normal');
        const selectHeaderActions = document.getElementById('chat-header-actions-select');
        const deleteMessagesBtn = document.getElementById('delete-messages-btn');
        const cancelSelectionBtn = document.getElementById('cancel-selection-btn');


        // 3. 定义功能函数
        function enterMessageSelectionMode(targetMessageRow) {
            if (isMessageSelectionMode) return;
            isMessageSelectionMode = true;
            chatScreenContainer.classList.add('selection-mode-active');

            // 切换顶栏按钮
            normalHeaderActions.style.display = 'none';
            selectHeaderActions.style.display = 'flex';

            // // 选中长按的那条消息
            // toggleMessageSelection(targetMessageRow);
        }

        function exitMessageSelectionMode() {
            isMessageSelectionMode = false;
            chatScreenContainer.classList.remove('selection-mode-active');

            // 切换回正常的顶栏按钮
            normalHeaderActions.style.display = 'flex';
            selectHeaderActions.style.display = 'none';

            // 取消所有消息的选中状态
            document.querySelectorAll('.message-row.selected').forEach(row => {
                row.classList.remove('selected');
            });
        }

        function toggleMessageSelection(messageRow) {
            if (!messageRow) return;
            messageRow.classList.toggle('selected');
        }

        // ===================================
        // 这是新的、简化的 deleteSelectedMessages
        // ===================================
        // ===================================
        // 这是【最终正确版】的 deleteSelectedMessages 函数
        // ===================================
        async function deleteSelectedMessages() {
            const selectedRows = document.querySelectorAll('.message-row.selected');
            if (selectedRows.length === 0 || !currentOpenContact) {
                return;
            }

            if (!confirm(`确定要永久删除选中的 ${selectedRows.length} 条消息吗？`)) {
                return;
            }

            // 1. 【核心修改】从UI收集待删除消息的 UUID
            const uuidsToDelete = new Set();
            selectedRows.forEach(row => {
                // 读取 dataset.uuid 而不是 timestamp
                if (row.dataset.uuid) {
                    uuidsToDelete.add(row.dataset.uuid);
                }
            });

            // 2. 【核心修改】直接在内存中的 history 上根据 UUID 进行过滤
            if (Array.isArray(currentOpenContact.history)) {
                currentOpenContact.history = currentOpenContact.history.filter(
                    // 检查 message.uuid 而不是 message.timestamp
                    message => !uuidsToDelete.has(message.uuid)
                );
            }

            // 3. 更新内存中的 lastMessage (这部分逻辑不变)
            if (currentOpenContact.history.length > 0) {
                const newLastMessageText = currentOpenContact.history[currentOpenContact.history.length - 1].text;
                currentOpenContact.lastMessage = cleanMessageForPreview(newLastMessageText);
            } else {
                currentOpenContact.lastMessage = "对话已清空";
            }

            // 4. 调用主保存函数来同步数据库
            await saveCurrentContactToDatabase();

            // 5. 更新UI
            selectedRows.forEach(row => row.remove());
            const contactItemInList = contactList.querySelector(`.contact-item[data-contact-id="${currentOpenContact.id}"]`);
            if (contactItemInList) {
                contactItemInList.querySelector('.contact-last-message').textContent = currentOpenContact.lastMessage;
            }

            // 6. 退出选择模式
            exitMessageSelectionMode();
            alert('删除成功！');
        }
        // ===================================
        // 这是【最终正确版】的事件监听代码块
        // ===================================

        // 1. 取消和删除按钮的点击事件
        cancelSelectionBtn.addEventListener('click', exitMessageSelectionMode);
        deleteMessagesBtn.addEventListener('click', deleteSelectedMessages);

        // 2. 定义统一的事件处理函数
        function handlePressStart(e) {
            if (isAiReplying) return;
            if (isMessageSelectionMode) return;
            const targetRow = e.target.closest('.message-row');
            console.log('长按事件已触发! 寻找到的消息行:', targetRow);
            if (!targetRow) return;

            clearTimeout(longPressTimer);

            longPressTimer = setTimeout(() => {
                enterMessageSelectionMode(targetRow);
            }, 500); // 长按超过500毫秒触发
        }

        function handlePressEnd() {
            clearTimeout(longPressTimer);
        }

        // 3. 【核心】为聊天容器绑定所有必需的鼠标和触摸事件
        chatMessagesContainer.addEventListener('mousedown', handlePressStart);
        chatMessagesContainer.addEventListener('touchstart', handlePressStart, { passive: true });

        chatMessagesContainer.addEventListener('mouseup', handlePressEnd);
        chatMessagesContainer.addEventListener('touchend', handlePressEnd);
        chatMessagesContainer.addEventListener('mouseleave', handlePressEnd); // 鼠标移出也要取消
        chatMessagesContainer.addEventListener('touchmove', handlePressEnd); // 手指滑动（滚动）时也要取消长按

        // 4. 聊天容器的单击事件
        chatMessagesContainer.addEventListener('click', (e) => {
            // 只有在选择模式下，单击才是为了切换选中状态
            if (isMessageSelectionMode) {
                const targetRow = e.target.closest('.message-row');
                // 阻止事件传播，防止触发其他可能存在的点击效果
                e.stopPropagation();
                e.preventDefault();
                toggleMessageSelection(targetRow);
            }
        });



        // *** 在这里新增下面的代码 ***

        // === 新增：世界书对话框的控制函数 ===
        // === 升级版：世界书对话框控制函数（支持新建和编辑） ===
        async function openWorldbookModal(bookId = null) {
            const modalTitle = addWorldbookModal.querySelector('h2');

            if (bookId) {
                // --- 编辑模式 ---
                currentEditingBookId = bookId; // 记录正在编辑的ID
                modalTitle.textContent = '编辑世界书';

                // 从数据库加载并填充内容
                const existingData = await dbHelper.loadData('worldBooks', 'allWorldBooks');
                const book = existingData.value.find(b => b.id === bookId);
                if (book) {
                    worldbookNameInput.value = book.name;
                    worldbookContentInput.value = book.content;
                }
            } else {
                // --- 新建模式 ---
                currentEditingBookId = null; // 确保是null
                modalTitle.textContent = '新建世界书';
                // 清空输入框（虽然关闭时会清，但这里再清一次更保险）
                worldbookNameInput.value = '';
                worldbookContentInput.value = '';
            }

            // 显示弹窗
            addWorldbookModal.style.display = 'flex';
            setTimeout(() => {
                addWorldbookModal.style.opacity = '1';
                addWorldbookModal.querySelector('.modal-content').style.transform = 'scale(1)';
            }, 10);
        }

        function closeWorldbookModal() {
            addWorldbookModal.style.opacity = '0';
            addWorldbookModal.querySelector('.modal-content').style.transform = 'scale(0.95)';
            setTimeout(() => {
                addWorldbookModal.style.display = 'none';
                // 重置输入框内容
                worldbookNameInput.value = '';
                worldbookContentInput.value = '';
                currentEditingBookId = null;
            }, 300);
        }

        // --- 事件绑定 ---
        worldbookModalCloseBtn.addEventListener('click', closeWorldbookModal);

        // --- 保存世界书的逻辑 ---
        // === 升级版：保存世界书的逻辑（支持新建和编辑） ===
        saveWorldbookBtn.addEventListener('click', async () => {
            const name = worldbookNameInput.value.trim();
            const content = worldbookContentInput.value.trim();

            if (!name) {
                alert('世界书名称不能为空！');
                return;
            }

            try {
                const existingData = await dbHelper.loadData('worldBooks', 'allWorldBooks');
                let books = (existingData && Array.isArray(existingData.value)) ? existingData.value : [];

                if (currentEditingBookId) {
                    // --- 编辑逻辑 ---
                    const bookIndex = books.findIndex(b => b.id === currentEditingBookId);
                    if (bookIndex > -1) {
                        books[bookIndex].name = name;
                        books[bookIndex].content = content;
                    }
                } else {
                    // --- 新建逻辑 ---
                    const newBook = {
                        id: Date.now(),
                        name: name,
                        content: content,
                        createdAt: new Date()
                    };
                    books.push(newBook);
                }

                // 将更新后的整个数组存回数据库
                await dbHelper.saveData('worldBooks', 'allWorldBooks', books);

                alert('世界书已保存！');
                closeWorldbookModal();
                loadAndRenderWorldBooks(); // 刷新列表以显示更改

            } catch (error) {
                console.error("保存世界书失败:", error);
                alert("保存失败，请查看控制台日志。");
            }
        });

        // *** 新增代码结束 ***

        // *** 在这里新增下面的代码 ***

        // === 新增：世界书渲染与加载函数 ===

        /**
         * 渲染世界书列表到界面上
         * @param {Array} books - 从数据库读取的世界书对象数组
         */
        function renderWorldBooks(books) {
            worldbookListContainer.innerHTML = ''; // 先清空列表
            if (!books || books.length === 0) {
                worldbookListContainer.innerHTML = '<p style="text-align:center; color:#888;">还没有创建任何世界书。</p>';
                return;
            }

            books.forEach(book => {
                const bookItem = document.createElement('div');
                bookItem.className = 'contact-item'; // 复用联系人列表项的样式
                bookItem.dataset.bookId = book.id;
                bookItem.innerHTML = `
            <input type="checkbox" class="contact-checkbox">
            <div class="contact-info">
                <div class="contact-name">${book.name}</div>
                <div class="contact-last-message" style="white-space: normal;">${book.content.substring(0, 50)}...</div>
            </div>
        `;
                worldbookListContainer.appendChild(bookItem);
            });
        }

        /**
         * 从数据库加载数据并调用渲染函数
         */
        async function loadAndRenderWorldBooks() {
            const existingData = await dbHelper.loadData('worldBooks', 'allWorldBooks');
            const books = (existingData && Array.isArray(existingData.value)) ? existingData.value : [];
            renderWorldBooks(books);
        }

        // *** 新增代码结束 ***

        // *** 在这里新增下面的代码 ***

        // === 新增：世界书多选删除逻辑 ===
        worldbookMultiselectBtn.addEventListener('click', () => {
            isWorldbookDeleteMode = !isWorldbookDeleteMode; // 切换模式
            worldbookListContainer.classList.toggle('delete-mode', isWorldbookDeleteMode);

            if (isWorldbookDeleteMode) {
                worldbookMultiselectBtn.textContent = '取消';
                addWorldbookBtn.textContent = '删除所选';
                addWorldbookBtn.classList.add('delete');
            } else {
                worldbookMultiselectBtn.textContent = '多选';
                addWorldbookBtn.textContent = '新建世界书';
                addWorldbookBtn.classList.remove('delete');
                // 退出时取消所有勾选
                worldbookListContainer.querySelectorAll('.contact-checkbox').forEach(cb => cb.checked = false);
            }
        });

        // --- 修改“新建”按钮的行为，使其在删除模式下执行删除 ---
        addWorldbookBtn.addEventListener('click', () => {
            if (isWorldbookDeleteMode) {
                handleBatchDeleteWorldBooks();
            } else {
                openWorldbookModal();
            }
        });

        // --- 批量删除的执行函数 ---
        async function handleBatchDeleteWorldBooks() {
            const selectedCheckboxes = worldbookListContainer.querySelectorAll('.contact-checkbox:checked');
            if (selectedCheckboxes.length === 0) {
                alert('请至少选择一个要删除的世界书。');
                return;
            }

            if (!confirm(`确定要删除选中的 ${selectedCheckboxes.length} 个世界书吗？此操作无法撤销。`)) {
                return;
            }

            const idsToDelete = new Set();
            selectedCheckboxes.forEach(cb => {
                const bookId = cb.closest('.contact-item').dataset.bookId;
                idsToDelete.add(parseInt(bookId, 10));
            });

            try {
                const existingData = await dbHelper.loadData('worldBooks', 'allWorldBooks');
                let books = (existingData && Array.isArray(existingData.value)) ? existingData.value : [];

                // 过滤掉需要删除的书籍
                const updatedBooks = books.filter(book => !idsToDelete.has(book.id));

                // 将更新后的列表存回数据库
                await dbHelper.saveData('worldBooks', 'allWorldBooks', updatedBooks);

                // 重新加载列表并退出删除模式
                await loadAndRenderWorldBooks();
                worldbookMultiselectBtn.click(); // 模拟点击“取消”按钮

            } catch (error) {
                console.error("删除世界书失败:", error);
                alert("删除失败，请查看控制台日志。");
            }
        }
        // *** 新增代码结束 ***

        // === 更新：转账功能，使其打开弹窗并发送正确格式的消息 ===
        function openTransferModal() {
            transferModal.style.display = 'flex';
            setTimeout(() => {
                transferModal.style.opacity = '1';
                transferModal.querySelector('.modal-content').style.transform = 'scale(1)';
            }, 10);
        }

        function closeTransferModal() {
            transferModal.style.opacity = '0';
            transferModal.querySelector('.modal-content').style.transform = 'scale(0.95)';
            setTimeout(() => {
                transferModal.style.display = 'none';
                transferAmountInput.value = '';
                transferRemarkInput.value = '';
            }, 300);
        }

        transferFeatureButton.addEventListener('click', () => {
            openTransferModal();
            moreFeaturesPanel.classList.remove('active');
        });

        timePerceptionButton.addEventListener('click', handleTimePerceptionToggle);

        transferModalCloseBtn.addEventListener('click', closeTransferModal);

            confirmTransferBtn.addEventListener('click', async () => {
                const amount = parseFloat(transferAmountInput.value);
                const remark = transferRemarkInput.value.trim();

                if (isNaN(amount) || amount <= 0) {
                    alert("请输入有效的转账金额。");
                    return;
                }
                if (!remark) {
                    alert("备注不能为空。");
                    return;
                }

                const messageText = `[TRANSFER_START]${remark}-${amount}[TRANSFER_END]`;

                const userMessage = {
                    sender: 'user',
                    text: messageText,
                    timestamp: new Date(),
                    uuid: Date.now() + '-' + Math.random().toString(36).substr(2, 9) // <-- 核心修复：补上唯一的UUID
                };

                addMessageToView(userMessage);
                await saveMessageToHistory(userMessage, currentOpenContact.id);
                chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'smooth' });

                closeTransferModal();
            });
        /**
         * 最终确认版：处理AI回复的核心函数
         * 1. 严格恢复您最初设定的延迟时间计算公式。
         * 2. 包含所有已修正的错误和新增的功能。
         * @param {number} contactId - 对话的ID.
         * @param {Array} newMessages - AI返回的新消息对象数组.
         * @param {HTMLElement|null} initialIndicator - 为第一条消息预创建的“正在输入”动画元素.
         */
        async function updateChatViewWithAIResponse(contactId, newMessages, initialIndicator) {
            if (currentOpenContact && currentOpenContact.id === contactId) {
                let acceptedInvite = false;

                for (const [index, message] of newMessages.entries()) {

                    if (message.text.includes('[ACCEPT_INVITE]')) {
                        acceptedInvite = true;
                    }

                    let currentTypingIndicator;

                    if (index === 0 && initialIndicator) {
                        currentTypingIndicator = initialIndicator;
                    } else {
                        currentTypingIndicator = showTypingIndicator();
                    }

                    const messageRegex = /\[MESSAGE_START\]([\s\S]*?)\[MESSAGE_END\]/;
                    let visibleText = message.text.replace('[ACCEPT_INVITE]', '').trim();
                    const match = visibleText.match(messageRegex);
                    if (match && match[1]) {
                        visibleText = match[1].trim();
                    }

                    // --- 核心修正：严格恢复为您原来的延迟时间公式 ---
                    const typingDelay = Math.min(visibleText.length * 800 + 1000, 4000);

                    await new Promise(resolve => setTimeout(resolve, typingDelay));

                    currentTypingIndicator.remove();

                    if (visibleText) {
                        addMessageToView({ ...message, text: visibleText });
                        chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'smooth' });
                    }
                }

                if (acceptedInvite && sharedListeningState.active === false) {
                    console.log(`AI "${currentOpenContact.ai.name}" 接受了邀请！`);

                    sharedListeningState.active = true;
                    sharedListeningState.contact = currentOpenContact;

                    const message = `${currentOpenContact.ai.name} 加入了一起听`;
                    // 确保调用了新的 showSystemNotification 函数
                    showSystemNotification(message, currentOpenContact.id);

                    if (dynamicIsland.classList.contains('expanded')) {
                        updateSharedListeningUI();
                    }
                }
            }
        }
        // === 备份与恢复功能的核心逻辑 ===

        // 定义我们数据库中所有的“表”名
        const objectStoreNames = ['settingsStore', 'messageContacts', 'musicPlaylists', 'worldBooks'];

        /**
         * 备份功能：读取所有数据并下载为JSON文件
         */
        async function backupData() {
            try {
                const fullBackup = {};
                for (const storeName of objectStoreNames) {
                    // 从每个“表”中读取所有数据
                    const data = await dbHelper.getAllDataFromStore(storeName);
                    fullBackup[storeName] = data;
                }

                // 将数据转换为JSON字符串
                const jsonString = JSON.stringify(fullBackup, null, 2);
                // 创建一个Blob对象
                const blob = new Blob([jsonString], { type: 'application/json' });
                // 创建一个下载链接
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');

                // 设置下载文件名，包含日期
                const date = new Date();
                const dateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
                a.download = `phone_backup_${dateString}.json`;
                a.href = url;

                // 触发下载
                a.click();

                // 清理
                URL.revokeObjectURL(url);
                alert('备份文件已开始下载！');

            } catch (error) {
                console.error("备份失败:", error);
                alert(`备份失败: ${error.message}`);
            }
        }

        /**
         * 导入功能：读取JSON文件并覆盖现有数据
         */
        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            // 警告用户这是一个危险操作
            if (!confirm("警告：导入备份将覆盖所有当前数据，此操作不可撤销。您确定要继续吗？")) {
                // 清空文件输入，以便下次还能选择同一个文件
                importFileInput.value = '';
                return;
            }

            const reader = new FileReader();

            reader.onload = async (e) => {
                try {
                    const backupObject = JSON.parse(e.target.result);

                    // 恢复数据
                    for (const storeName of objectStoreNames) {
                        if (backupObject[storeName]) {
                            // 1. 清空旧数据
                            await dbHelper.clearStore(storeName);
                            // 2. 写入备份中的新数据
                            for (const record of backupObject[storeName]) {
                                // 我们的saveData需要id和value分开
                                await dbHelper.saveData(storeName, record.id, record.value);
                            }
                        }
                    }

                    alert("数据恢复成功！页面即将刷新以应用更改。");
                    // 刷新页面以加载新数据
                    location.reload();

                } catch (error) {
                    console.error("导入失败:", error);
                    alert(`导入失败: ${error.message}\n\n请确保您选择的是一个有效的备份文件。`);
                } finally {
                    importFileInput.value = '';
                }
            };

            reader.readAsText(file);
        }

        // 为按钮绑定事件
        backupDataBtn.addEventListener('click', backupData);
        importDataBtn.addEventListener('click', () => importFileInput.click()); // 点击“导入”按钮，实际是触发隐藏的文件选择框
        importFileInput.addEventListener('change', handleFileImport);

        // === 新增：歌单名称编辑功能 ===
        // === 最终修正版：歌单名称编辑功能 (采用重新渲染策略，确保状态同步) ===
        editPlaylistNameBtn.addEventListener('click', async () => {
            if (!currentOpenPlaylist) return;

            const newName = prompt("请输入新的歌单名称：", currentOpenPlaylist);

            if (newName === null || newName.trim() === "") return;

            const trimmedNewName = newName.trim();
            if (trimmedNewName === currentOpenPlaylist) return;

            try {
                // 1. 从数据库加载最新的完整歌单列表
                const allPlaylistsData = await dbHelper.loadData('musicPlaylists', 'allPlaylists');
                if (!allPlaylistsData || typeof allPlaylistsData.value !== 'object') {
                    throw new Error("无法加载歌单数据库。");
                }
                let allPlaylists = allPlaylistsData.value;

                // 2. 检查新名称是否冲突
                if (allPlaylists[trimmedNewName]) {
                    alert("错误：该歌单名称已存在！");
                    return;
                }

                // 3. 在内存中执行重命名操作
                allPlaylists[trimmedNewName] = allPlaylists[currentOpenPlaylist];
                delete allPlaylists[currentOpenPlaylist];

                // 4. 将修改后的完整歌单列表，一次性存回数据库
                await dbHelper.saveData('musicPlaylists', 'allPlaylists', allPlaylists);

                // --- 5. 核心修复：不再手动修改UI，而是直接调用加载函数来重新渲染 ---
                await loadPlaylists(); // 这会根据最新的数据库数据，重新绘制整个歌单列表

                // 6. 更新详情页的标题和全局状态变量
                const titleElement = document.getElementById('playlist-name-title');
                if (titleElement) {
                    titleElement.textContent = trimmedNewName;
                }
                currentOpenPlaylist = trimmedNewName;

                alert("歌单名称已更新！");

            } catch (error) {
                console.error("编辑歌单名称失败:", error);
                alert(`编辑失败: ${error.message}`);
            }
        });

        // === 新增：歌单多选与删除的全部逻辑 ===

        // --- “多选”按钮的点击事件 ---
        playlistMultiselectBtn.addEventListener('click', () => {
            isPlaylistDeleteMode = !isPlaylistDeleteMode; // 切换模式
            playlistGrid.classList.toggle('delete-mode', isPlaylistDeleteMode);

            if (isPlaylistDeleteMode) {
                playlistMultiselectBtn.textContent = '取消';
                addPlaylistBtn.textContent = '删除所选';
                addPlaylistBtn.classList.add('delete');
            } else {
                playlistMultiselectBtn.textContent = '多选';
                addPlaylistBtn.textContent = '新建歌单';
                addPlaylistBtn.classList.remove('delete');
                // 退出时取消所有勾选
                playlistGrid.querySelectorAll('.playlist-checkbox').forEach(cb => cb.checked = false);
            }
        });

        // --- 修改“新建歌单”按钮的行为，使其在删除模式下执行删除 ---
        addPlaylistBtn.addEventListener('click', () => {
            if (isPlaylistDeleteMode) {
                // 如果是删除模式，则执行删除
                handleBatchDeletePlaylists();
            } else {
                // 否则，执行新建
                createNewPlaylist();
            }
        });
        // 将原有的新建逻辑封装成一个函数
        async function createNewPlaylist() {
            const playlistName = prompt("请输入新的歌单名称：");
            if (playlistName && playlistName.trim() !== "") {
                const newName = playlistName.trim();
                try {
                    const existingData = await dbHelper.loadData('musicPlaylists', 'allPlaylists');
                    let playlists = (existingData && typeof existingData.value === 'object') ? existingData.value : {};
                    if (playlists[newName]) {
                        alert("歌单名称已存在！");
                        return;
                    }
                    playlists[newName] = { songs: [], coverUrl: null };
                    await dbHelper.saveData('musicPlaylists', 'allPlaylists', playlists);
                    createPlaylistCard(newName, playlists[newName]);
                } catch (error) {
                    console.error("保存歌单失败:", error);
                }
            }
        }

        // --- 批量删除的执行函数 ---
        async function handleBatchDeletePlaylists() {
            const selectedCheckboxes = playlistGrid.querySelectorAll('.playlist-checkbox:checked');
            if (selectedCheckboxes.length === 0) {
                alert('请至少选择一个要删除的歌单。');
                return;
            }

            if (!confirm(`确定要删除选中的 ${selectedCheckboxes.length} 个歌单吗？此操作无法撤销。`)) {
                return;
            }

            const namesToDelete = new Set();
            selectedCheckboxes.forEach(cb => {
                const card = cb.closest('.playlist-card');
                namesToDelete.add(card.dataset.playlistName);
            });

            try {
                const existingData = await dbHelper.loadData('musicPlaylists', 'allPlaylists');
                let playlists = existingData.value;

                namesToDelete.forEach(name => {
                    delete playlists[name];
                });

                await dbHelper.saveData('musicPlaylists', 'allPlaylists', playlists);

                await loadPlaylists();
                playlistMultiselectBtn.click(); // 操作完成后自动退出多选模式

            } catch (error) {
                console.error("删除歌单失败:", error);
                alert("删除失败，请查看控制台日志。");
            }
        }
        // === 新增：全局字体更换的全部逻辑 ===

        const defaultFontFamily = "sans-serif"; // 定义一个默认字体

        /**
         * 应用自定义字体或恢复默认字体的核心函数
         * @param {string | null} fontDataUrl - Base64格式的字体数据URL，或 null 以恢复默认
         */
        function applyCustomFont(fontDataUrl) {
            if (fontDataUrl) {
                // 如果有自定义字体数据，则创建 @font-face 规则并应用
                const fontFaceRule = `
            @font-face {
                font-family: 'CustomGlobalFont';
                src: url(${fontDataUrl});
            }
        `;
                customFontStyle.innerHTML = fontFaceRule;
                phoneFrame.style.fontFamily = "'CustomGlobalFont', " + defaultFontFamily;
            } else {
                // 如果没有数据，则清空规则并恢复默认字体
                customFontStyle.innerHTML = '';
                phoneFrame.style.fontFamily = defaultFontFamily;
            }
        }

        // --- 事件监听 ---

        // 1. 点击“更换字体”按钮
        changeFontBtn.addEventListener('click', () => {
            fontImportInput.click(); // 触发隐藏的文件选择框
        });

        // 2. 当用户选择了字体文件后
        fontImportInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                const fontDataUrl = e.target.result;
                try {
                    // a. 将字体数据保存到数据库
                    await dbHelper.saveData('settingsStore', 'customFont', fontDataUrl);
                    // b. 立即应用新字体
                    applyCustomFont(fontDataUrl);
                    alert('字体已成功应用！');
                } catch (error) {
                    console.error("保存或应用字体失败:", error);
                    alert("字体应用失败，请查看控制台。");
                }
            };
            // 将字体文件读取为Base64 Data URL
            reader.readAsDataURL(file);
            event.target.value = ''; // 清空输入，以便下次能选择同一个文件
        });

        // 3. 点击“恢复默认”按钮
        restoreFontBtn.addEventListener('click', async () => {
            if (confirm("确定要恢复为默认字体吗？")) {
                try {
                    // a. 从数据库删除自定义字体记录
                    await dbHelper.deleteData('settingsStore', 'customFont');
                    // b. 立即恢复默认字体
                    applyCustomFont(null);
                    alert('已恢复默认字体！');
                } catch (error) {
                    console.error("恢复默认字体失败:", error);
                    alert("恢复失败，请查看控制台。");
                }
            }
        });

        // === 新增：聊天记录搜索功能的全部逻辑 ===

        // 1. 获取新添加的HTML元素
        const chatSearchButton = document.getElementById('chat-search-button');
        const searchModal = document.getElementById('search-modal');
        const searchModalCloseBtn = document.getElementById('search-modal-close-btn');
        const searchInput = document.getElementById('search-input');
        const searchResultsContainer = document.getElementById('search-results-container');
        let searchDebounceTimer;

        // 2. 打开和关闭搜索对话框的函数
        function openSearchModal() {
            searchModal.style.display = 'flex';
            setTimeout(() => {
                searchModal.style.opacity = '1';
                searchModal.querySelector('.modal-content').style.transform = 'scale(1)';
                searchInput.focus(); // 自动聚焦到输入框
            }, 10);
        }

        function closeSearchModal() {
            searchInput.blur();
            searchModal.style.opacity = '0';
            searchModal.querySelector('.modal-content').style.transform = 'scale(0.95)';
            setTimeout(() => {
                searchModal.style.display = 'none';
                searchInput.value = ''; // 清空输入
                searchResultsContainer.innerHTML = ''; // 清空结果
            }, 300);
        }

        // 3. 绑定打开/关闭事件
        chatSearchButton.addEventListener('click', openSearchModal);
        searchModalCloseBtn.addEventListener('click', closeSearchModal);


        /**
         * 【最终版】根据关键词创建居中、带省略号的消息摘要
         * (已集成移除换行符功能，确保单行显示)
         */
        /**
         * 【最终版 V2】根据关键词创建居中、带省略号的消息摘要
         * (截取长度已根据要求调整为3)
         */
        function createSnippet(fullText, keyword, contextLength = 3) { // <--- 核心修改在这里
            // 首先，移除原始文本中的所有换行符，将其替换为空格
            const cleanText = fullText.replace(/(\r\n|\n|\r)/gm, " ");

            const keywordIndex = cleanText.toLowerCase().indexOf(keyword.toLowerCase());

            if (keywordIndex === -1) {
                let snippet = cleanText.substring(0, contextLength * 2 + keyword.length);
                return snippet + '...';
            }

            const startIndex = Math.max(0, keywordIndex - contextLength);
            const endIndex = Math.min(cleanText.length, keywordIndex + keyword.length + contextLength);

            let snippet = cleanText.substring(startIndex, endIndex);

            if (startIndex > 0) {
                snippet = '...' + snippet;
            }

            if (endIndex < cleanText.length) {
                snippet = snippet + '...';
            }

            return snippet;
        }

        /**
         * 【最终版】渲染搜索结果的函数
         * (使用专属类名 chatsearch-content)
         */
        /**
        * 【最终版】渲染搜索结果的函数
        * (使用正确的两行式HTML结构，并包含 data-uuid)
        */
        function renderSearchResults(results, keyword, regex) {
            if (results.length === 0) {
                searchResultsContainer.innerHTML = '<p style="text-align:center; color:#888;">在此对话中未找到相关记录</p>';
                return;
            }

            searchResultsContainer.innerHTML = results.map(result => {
                const messageDate = new Date(result.message.timestamp);
                const formattedTime = `${String(messageDate.getMonth() + 1).padStart(2, '0')}-${String(messageDate.getDate()).padStart(2, '0')} ${String(messageDate.getHours()).padStart(2, '0')}:${String(messageDate.getMinutes()).padStart(2, '0')}`;

                const snippet = createSnippet(result.message.text, keyword);
                const highlightedSnippet = snippet.replace(regex, `<span class="highlight">$&</span>`);

                // 这个 return 语句会生成带有 data-uuid 的正确 HTML
                return `
            <div class="search-result-item" data-contact-id="${currentOpenContact.id}" data-uuid="${result.message.uuid}">
                <div class="result-header">
                    <div class="sender-name">${result.senderName}:</div>
                    <div class="time">${formattedTime}</div>
                </div>
                <div class="chatsearch-content">${highlightedSnippet}</div>
            </div>
        `;
            }).join('');
        }

        // 4. 核心：执行搜索并渲染结果
        // 替换为新版 performSearch 函数
        async function performSearch(keyword) {
            // 检查是否有关键词或当前联系人
            if (!keyword || keyword.length < 1 || !currentOpenContact) {
                searchResultsContainer.innerHTML = '';
                return;
            }

            // 搜索范围限定为当前联系人的 history
            const history = Array.isArray(currentOpenContact.history) ? currentOpenContact.history : [];
            const results = [];

            // 在当前联系人历史记录中查找
            for (const message of history) {
                if (message.uuid && message.text.toLowerCase().includes(keyword.toLowerCase())) {
                    results.push({
                        message: message,
                        senderName: message.sender === 'user' ? currentOpenContact.user.name : currentOpenContact.ai.name
                    });
                }
            }

            // 将关键词和正则表达式一起传递给渲染函数
            const searchRegex = new RegExp(keyword.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'gi');
            renderSearchResults(results, keyword, searchRegex);
        }


        // 5. 监听搜索框的输入事件 (使用防抖优化性能)
        searchInput.addEventListener('input', () => {
            clearTimeout(searchDebounceTimer);
            searchDebounceTimer = setTimeout(() => {
                performSearch(searchInput.value.trim());
            }, 300); // 停止输入300毫秒后执行搜索
        });

        // 用这个新版本替换你现有的 searchResultsContainer 点击事件监听器

searchResultsContainer.addEventListener('click', (event) => {
    const resultItem = event.target.closest('.search-result-item');
    if (resultItem) {
        event.preventDefault();
        event.stopPropagation();

        // ▼▼▼ 新增的核心修复逻辑 ▼▼▼
        const shield = document.getElementById('click-shield');
        
        // 1. 立即激活“护盾”，拦截即将到来的“穿透点击”
        shield.style.display = 'block';

        // 2. 正常执行跳转逻辑
        const contactId = parseInt(resultItem.dataset.contactId, 10);
        const uuid = resultItem.dataset.uuid;
        if (contactId && uuid) {
            closeSearchModal();
            jumpToMessage(contactId, uuid);
        }

        // 3. 在400毫秒后（比弹窗关闭动画稍长），撤掉“护盾”
        setTimeout(() => {
            shield.style.display = 'none';
        }, 400); 
        // ▲▲▲ 修复逻辑结束 ▲▲▲
    }
});

        // 7. 核心：跳转到指定消息的函数
// 用这个新版本替换现有的 jumpToMessage 函数

async function jumpToMessage(contactId, uuid) {
    // 正常关闭搜索框
    closeSearchModal();
    
    // 正常打开聊天视图并等待它完成
    await openChatView(contactId, { targetMessageUuid: uuid });

    // ▼▼▼ 第二道防线：“清除”任何残留的焦点 ▼▼▼
    // 这是最关键的一步。在所有跳转和渲染完成后，
    // 我们强制让聊天输入框失去焦点，从而防止底栏被抬起。
    chatMessageInput.blur();
    // ▲▲▲ 修复代码结束 ▲▲▲
}
        /**
         * 【新增】处理时间感知功能开启/关闭的函数
         */
        async function handleTimePerceptionToggle() {
            if (!currentOpenContact) {
                alert("请先打开一个对话。");
                return;
            }

            // 检查当前状态 (如果属性不存在，则默认为false)
            const isEnabled = currentOpenContact.timePerceptionEnabled || false;

            const message = isEnabled ?
                "要关闭此AI的时间感知功能吗？关闭后它将不再知晓现实时间。" :
                "要为此AI开启感知现实时间的功能吗？开启后AI的回复会结合当前时间。";

            if (confirm(message)) {
                try {
                    // 切换状态
                    currentOpenContact.timePerceptionEnabled = !isEnabled;

                    // 使用“加载-修改-保存”模式安全地更新数据库
                    const allContactsData = await dbHelper.loadData('messageContacts', 'allContacts');
                    let allContacts = allContactsData.value || [];
                    const contactIndex = allContacts.findIndex(c => c.id === currentOpenContact.id);

                    if (contactIndex > -1) {
                        allContacts[contactIndex] = currentOpenContact;
                        await dbHelper.saveData('messageContacts', 'allContacts', allContacts);
                        alert(`时间感知功能已成功${currentOpenContact.timePerceptionEnabled ? '开启' : '关闭'}！`);
                    } else {
                        throw new Error("在数据库中找不到当前联系人。");
                    }

                } catch (error) {
                    console.error("更新时间感知状态失败:", error);
                    alert(`操作失败: ${error.message}`);
                } finally {
                    // 操作完成后关闭面板
                    moreFeaturesPanel.classList.remove('active');
                }
            }
        }

        // === 新增：邀请联系人功能的核心逻辑 ===

        // 1. 获取新添加的HTML元素
        const inviteContactBtn = document.getElementById('island-invite-button');
        const inviteModal = document.getElementById('invite-modal');
        const inviteModalCloseBtn = document.getElementById('invite-modal-close-btn');
        const inviteContactListContainer = document.getElementById('invite-contact-list-container');

        // 2. 打开和关闭对话框的函数
        function openInviteModal() {
            inviteModal.style.display = 'flex';
            // 动态加载并显示联系人列表
            loadAndDisplayContactsForInvite();
            setTimeout(() => {
                inviteModal.style.opacity = '1';
                inviteModal.querySelector('.modal-content').style.transform = 'scale(1)';
            }, 10);
        }

        function closeInviteModal() {
            inviteModal.style.opacity = '0';
            inviteModal.querySelector('.modal-content').style.transform = 'scale(0.95)';
            setTimeout(() => {
                inviteModal.style.display = 'none';
            }, 300);
        }

        // 3. 从数据库加载联系人并显示在对话框中的函数
        async function loadAndDisplayContactsForInvite() {
            // 清空旧列表，防止重复加载
            inviteContactListContainer.innerHTML = '<p style="text-align:center; color:#888;">正在加载联系人...</p>';

            try {
                const contactsData = await dbHelper.loadData('messageContacts', 'allContacts');
                if (contactsData && Array.isArray(contactsData.value) && contactsData.value.length > 0) {
                    inviteContactListContainer.innerHTML = ''; // 加载成功后清空提示
                    contactsData.value.forEach(contact => {
                        const contactItem = document.createElement('div');
                        contactItem.className = 'invite-contact-item';

                        contactItem.innerHTML = `
                    <img src="${contact.ai.avatar}" alt="avatar" class="invite-contact-avatar">
                    <span class="invite-contact-name">${contact.ai.name}</span>
                    <button class="invite-button" data-contact-id="${contact.id}">邀请</button>
                `;

                        inviteContactListContainer.appendChild(contactItem);
                    });
                } else {
                    inviteContactListContainer.innerHTML = '<p style="text-align:center; color:#888;">你还没有任何联系人。</p>';
                }
            } catch (error) {
                console.error("加载联系人列表失败:", error);
                inviteContactListContainer.innerHTML = '<p style="text-align:center; color:red;">加载失败，请重试。</p>';
            }
        }

        // 4. 绑定事件监听器
        // 点击SVG图标，打开对话框
        inviteContactBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            openInviteModal();
        });

        // 点击关闭按钮或遮罩背景，关闭对话框
        inviteModalCloseBtn.addEventListener('click', closeInviteModal);
        inviteModal.addEventListener('click', (event) => {
            if (event.target === inviteModal) {
                closeInviteModal();
            }
        });

        // 使用事件委托来处理所有“邀请”按钮的点击事件
// === “邀请一起听”按钮点击事件 (V4 - 修复卡片不显示问题) ===
// === “邀请一起听”按钮点击事件 (V5 - 最终修复版) ===
inviteContactListContainer.addEventListener('click', async (event) => {
    if (event.target.classList.contains('invite-button') && !event.target.disabled) {
        if (!playbackState.currentSong) {
            alert("请先播放一首歌曲再邀请！");
            return;
        }

        const button = event.target;
        const contactId = parseInt(button.dataset.contactId, 10);

        button.textContent = '已邀请';
        button.disabled = true;
        button.classList.add('invited');

        try {
            // 1. 构造邀请消息 (带UUID)
            const songTitle = playbackState.currentSong.title;
            const artistName = playbackState.currentSong.artist;
            const inviteMessageText = `[MUSIC_SHARE]对方邀请你收听-${songTitle}-${artistName}[MUSIC_SHARE]`;
            const userMessage = {
                sender: 'user',
                text: inviteMessageText,
                timestamp: new Date(),
                uuid: Date.now() + '-' + Math.random().toString(36).substr(2, 9)
            };

            // 2. 检查当前聊天窗口是否正好是邀请对象的窗口，如果是，则立即显示邀请卡片
            if (currentOpenContact && currentOpenContact.id === contactId) {
                addMessageToView(userMessage);
            }

            // 3. 将消息正确地保存到后台数据库
            const contactsData = await dbHelper.loadData('messageContacts', 'allContacts');
            let allContacts = contactsData.value || [];
            const contactIndex = allContacts.findIndex(c => c.id === contactId);
            if (contactIndex > -1) {
                const targetContact = allContacts[contactIndex];
                if (!Array.isArray(targetContact.history)) {
                    targetContact.history = [];
                }
                targetContact.history.push(userMessage);
                targetContact.lastMessage = "分享了一起听邀请";
                await dbHelper.saveData('messageContacts', 'allContacts', allContacts);

                // 4. 关闭弹窗并使用更新后的联系人数据来调用AI
                closeInviteModal();
                const aiTriggerMessage = `(我给你分享了一起听的邀请，歌曲是《${songTitle}》 - ${artistName}，请根据我们的聊天记录和你的人设，自然地决定是否接受。)`;
                await callAI(aiTriggerMessage, targetContact);

            } else {
                throw new Error("在数据库中找不到目标联系人。");
            }

        } catch (error) {
            console.error("发送邀请卡片失败:", error);
            alert("发送邀请失败，请查看控制台。");
            button.textContent = '邀请';
            button.disabled = false;
            button.classList.remove('invited');
        }
    }
});

        // === “一起听”功能最终修复版 (包含变量声明) ===

        // 1. 定义一个全局变量来管理“一起听”的状态 (这是缺失的部分)
        let sharedListeningState = {
            active: false,
            contact: null
        };

        // 2. 获取我们新添加的HTML头像容器
        const sharedAvatarsContainer = document.getElementById('shared-listening-avatars');
        const avatarImageContainer = document.getElementById('avatar-image-container');

        // 3. 编写一个函数，根据状态来更新UI
        // === 这是修正了UI更新逻辑的最终版本 ===
        function updateSharedListeningUI() {
            if (sharedListeningState.active && sharedListeningState.contact) {
                // 如果是激活状态，就获取对应的头像并显示
                const userAvatar = sharedListeningState.contact.user.avatar;
                const aiAvatar = sharedListeningState.contact.ai.avatar;

                // 关键修复：将头像插入到专用的图片容器中，而不是覆盖整个父容器
                avatarImageContainer.innerHTML = `
            <img src="${userAvatar}" class="shared-avatar-img" title="${sharedListeningState.contact.user.name}">
            <img src="${aiAvatar}" class="shared-avatar-img" title="${sharedListeningState.contact.ai.name}">
        `;
                // 父容器只负责控制整体的显示和隐藏
                sharedAvatarsContainer.classList.add('active');

            } else {
                // 否则，只清空图片容器并隐藏父容器
                avatarImageContainer.innerHTML = '';
                sharedAvatarsContainer.classList.remove('active');
            }
        }

        // 4. 定义一个函数，用于结束“一起听”状态
        function stopSharedListening() {
            sharedListeningState.active = false;
            sharedListeningState.contact = null;
            updateSharedListeningUI(); // 调用UI更新函数来隐藏头像
        }

        // === “一起听”功能最终交互逻辑 ===

        // 1. 获取新增的气泡和按钮元素
        const endSessionBubble = document.getElementById('end-session-bubble');
        const endListeningSessionBtn = document.getElementById('end-listening-session-btn');

        // 2. 为头像容器绑定新的点击事件，用于显示/隐藏气泡
        sharedAvatarsContainer.addEventListener('click', (event) => {
            // 确保只有在“一起听”模式激活时才响应
            if (sharedListeningState.active) {
                // 如果点击的不是“结束”按钮本身，则切换气泡的显示状态
                if (!event.target.closest('#end-listening-session-btn')) {
                    endSessionBubble.classList.toggle('active');
                }
            }
        });

        // 3. 为气泡内的“结束”按钮绑定点击事件
        endListeningSessionBtn.addEventListener('click', async (event) => {
            event.stopPropagation();
            endSessionBubble.classList.remove('active');

            try {
                // --- 关键的执行顺序在这里 ---

                // 步骤 1：先调用并“等待”系统提示函数完成。
                // 这个 await 关键字会强制程序在此暂停，直到消息被保存并且显示出来。
                // 这会确保“已经结束一起听”的灰色提示先出现在界面上。
                await showSystemNotification('已经结束一起听', sharedListeningState.contact.id);

                // 步骤 2：在系统提示显示完毕后，再调用并“等待”AI回应。
                // 只有在上面一行代码完全结束后，这一行才会开始执行。
                // AI的“...”输入气泡会在这里才出现。
                // This is the new, context-aware line
                await callAI("(我已经结束了一起听模式，我们继续聊吧)", sharedListeningState.contact);

            } catch (error) {
                // (可选) 如果在通知AI时出错，可以在控制台打印错误，方便排查问题
                console.error("在结束“一起听”并通知AI时发生错误:", error);
            } finally {
                // 步骤 3：无论上面的操作成功与否，最后都更新UI，隐藏头像。
                stopSharedListening();
            }
        });

        // 4. (可选但推荐) 添加一个全局点击事件，用于在点击页面其他地方时，自动隐藏气泡
        document.addEventListener('click', (event) => {
            // 如果气泡是显示的，并且点击的区域不在头像容器内
            if (endSessionBubble.classList.contains('active') && !sharedAvatarsContainer.contains(event.target)) {
                endSessionBubble.classList.remove('active');
            }
        }, true); // 使用捕获阶段确保它优先执行

        /**
         * 新增：在聊天界面显示一个系统级别的提示消息
         * @param {string} text - 要显示的提示文本
         */
        async function showSystemNotification(text, contactId) {
            if (!contactId) return;

            // 1. 构造一个带有 type: 'system' 的消息对象
            const systemMessage = {
                sender: 'system',
                type: 'system',
                text: text,
                timestamp: new Date(),
                uuid: Date.now() + '-' + Math.random().toString(36).substr(2, 9)
            };

            // 2. 将这条系统消息永久保存到数据库
            await saveMessageToHistory(systemMessage, contactId);

            // 3. 如果用户正打开着这个对话，则立即在界面上显示出来
            if (currentOpenContact && currentOpenContact.id === contactId) {
                addMessageToView(systemMessage);
                chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'smooth' });
            }
        }



        // 2. 控制“添加表情”对话框显示和隐藏的函数
        function openAddEmojiModal() {

            const urlsTextarea = document.getElementById('emoji-urls-textarea');
            if (urlsTextarea) {
                urlsTextarea.value = '';
            }
            addEmojiModal.style.display = 'flex';
            setTimeout(() => {
                addEmojiModal.style.opacity = '1';
                addEmojiModal.querySelector('.modal-content').style.transform = 'scale(1)';
            }, 10);
        }

        function closeAddEmojiModal() {
            addEmojiModal.style.opacity = '0';
            addEmojiModal.querySelector('.modal-content').style.transform = 'scale(0.95)';
            setTimeout(() => {
                addEmojiModal.style.display = 'none';
                emojiUrlInput.value = ''; // 关闭时清空输入框
            }, 300);
        }

        // 3. 从数据库加载并渲染所有表情到网格中
        // 新版本：在渲染时加入了复选框
        async function loadAndRenderEmojis() {
            try {
                const emojis = await dbHelper.getAllDataFromStore('emojiStore');
                emojiGridContainer.innerHTML = '';
                if (emojis && emojis.length > 0) {
                    emojis.forEach(emoji => {
                        const container = document.createElement('div');
                        container.className = 'emoji-item-container';

                        // === 核心修改：在 HTML 结构中加入 input[type=checkbox] ===
                        container.innerHTML = `
                    <input type="checkbox" class="emoji-checkbox" value="${emoji.url}">
                    <img src="${emoji.url}" class="emoji-item" title="点击发送" data-url="${emoji.url}">
                    <p class="emoji-remark" contenteditable="true">${emoji.remark}</p>
                `;

                        // 为新创建的备注元素重新绑定"失去焦点"事件
                        const remarkElement = container.querySelector('.emoji-remark');
                        remarkElement.addEventListener('blur', async (event) => {
                            const newRemark = event.target.textContent.trim();
                            const urlToUpdate = container.querySelector('.emoji-item').dataset.url;

                            if (newRemark) {
                                try {
                                    await dbHelper.updateRecord('emojiStore', { url: urlToUpdate, remark: newRemark });
                                } catch (dbError) {
                                    console.error("更新备注失败:", dbError);
                                }
                            } else {
                                event.target.textContent = "点击修改备注";
                            }
                        });

                        emojiGridContainer.appendChild(container);
                    });
                } else {
                    emojiGridContainer.innerHTML = '<p style="color:#aaa; font-size:14px; text-align:center; grid-column: 1 / -1;">快来添加表情包包吧！</p>';
                }
            } catch (error) {
                console.error("加载表情失败:", error);
            }
        }

        // 4. “确认添加”按钮的点击处理函数
        // 用这个新版本替换旧的 handleSaveEmojis 函数
        // 用这个新版本替换旧的 handleSaveEmojis 函数
// 用这个功能更强大的新版本，完整替换你旧的 handleSaveEmojis 函数

async function handleSaveEmojis() {
    const urlsTextarea = document.getElementById('emoji-urls-textarea');
    const inputText = urlsTextarea.value.trim();
    if (!inputText) {
        alert('请输入表情包数据！');
        return;
    }

    // --- 全新的解析逻辑 ---

    // 1. 使用正则表达式查找所有符合 [任意字符:任意字符] 格式的条目
    //    这比简单的逗号分割更健壮，可以避免URL中包含逗号等问题
    const entries = inputText.match(/\[.*?:\s*.*?\]/g);

    if (!entries || entries.length === 0) {
        alert('未找到有效格式的数据。\n\n请确保使用格式: [备注1:url1],[备注2:url2]');
        return;
    }

    const emojisToSave = [];

    // 2. 遍历每个找到的条目
    for (const entry of entries) {
        try {
            // 移除前后的方括号 -> "[备注:url]" 变成 "备注:url"
            const content = entry.slice(1, -1);
            
            // 找到第一个冒号的位置
            const colonIndex = content.indexOf(':');
            
            if (colonIndex === -1) {
                console.warn(`格式错误，跳过此条目 (缺少冒号): ${entry}`);
                continue; // 如果没有冒号，跳过这个条目
            }

            // 3. 根据冒号位置，精确地分离出备注和URL
            const remark = content.substring(0, colonIndex).trim();
            const url = content.substring(colonIndex + 1).trim();

            // 4. 进行简单验证，确保备注不为空，URL以http开头
            if (remark && url.startsWith('http')) {
                emojisToSave.push({ url, remark });
            } else {
                console.warn(`格式错误，跳过此条目 (备注为空或URL无效): ${entry}`);
            }
        } catch (e) {
            console.error(`解析条目时出错: ${entry}`, e);
        }
    }

    if (emojisToSave.length === 0) {
        alert('解析后未发现有效的表情包数据，请检查您的格式。');
        return;
    }

    // --- 保存到数据库的逻辑（与之前类似） ---
    try {
        let successCount = 0;
        for (const emoji of emojisToSave) {
            // 使用我们刚刚解析出的自定义备注
            const newEmoji = {
                url: emoji.url,
                remark: emoji.remark
            };
            await dbHelper.updateRecord('emojiStore', newEmoji);
            successCount++;
        }

        alert(`成功处理了 ${entries.length} 条数据，有效添加/更新了 ${successCount} 个表情！`);
        closeAddEmojiModal();
        loadAndRenderEmojis(); // 重新加载以显示新表情

    } catch (error) {
        console.error("保存表情失败:", error);
        alert("添加失败，请检查URL格式或数据库。");
    }
}

        // 5. 绑定所有事件监听器
        addEmojiBtn.addEventListener('click', () => {
            if (isEmojiDeleteMode) {
                handleBatchDeleteEmojis(); // 如果在删除模式，就执行删除
            } else {
                openAddEmojiModal(); // 否则，打开添加表情对话框
            }
        });
        emojiModalCloseBtn.addEventListener('click', closeAddEmojiModal);
        saveEmojiBtn.addEventListener('click', handleSaveEmojis);
        // 点击对话框外部的灰色区域也可以关闭
        addEmojiModal.addEventListener('click', (event) => {
            if (event.target === addEmojiModal) {
                closeAddEmojiModal();
            }
        });
        multiselectEmojiBtn.addEventListener('click', () => {
            isEmojiDeleteMode = !isEmojiDeleteMode; // 切换删除模式状态

            // 根据状态切换UI
            emojiGridContainer.classList.toggle('delete-mode', isEmojiDeleteMode);

            if (isEmojiDeleteMode) {
                // 进入删除模式
                multiselectEmojiBtn.textContent = '取消';
                addEmojiBtn.textContent = '删除所选';
            } else {
                // 退出删除模式
                multiselectEmojiBtn.textContent = '多选';
                addEmojiBtn.textContent = '添加';
                // 退出时，取消所有复选框的勾选
                emojiGridContainer.querySelectorAll('.emoji-checkbox').forEach(cb => cb.checked = false);
            }
        });
        async function handleBatchDeleteEmojis() {
            const selectedCheckboxes = emojiGridContainer.querySelectorAll('.emoji-checkbox:checked');

            if (selectedCheckboxes.length === 0) {
                alert('请至少选择一个要删除的表情。');
                return;
            }

            if (!confirm(`确定要删除选中的 ${selectedCheckboxes.length} 个表情吗？`)) {
                return;
            }

            try {
                let deletedCount = 0;
                // 遍历所有被选中的复选框
                for (const checkbox of selectedCheckboxes) {
                    const urlToDelete = checkbox.value; // 复选框的 value 就是图片的 URL
                    // 从 IndexedDB 中删除
                    await dbHelper.deleteData('emojiStore', urlToDelete);
                    deletedCount++;
                }

                alert(`成功删除了 ${deletedCount} 个表情！`);

                // 操作完成后，重新加载表情列表以刷新UI
                await loadAndRenderEmojis();

                // 主动“点击”取消按钮，退出删除模式
                multiselectEmojiBtn.click();

            } catch (error) {
                console.error("删除表情失败:", error);
                alert("删除失败，请查看控制台日志。");
            }
        }
        /**
         * 新增：主保存函数
         * 这是唯一一个负责将 currentOpenContact 的当前状态写入数据库的函数。
         * 任何需要保存的操作都应该调用它。
         */
        async function saveCurrentContactToDatabase() {
            if (!currentOpenContact) return;

            try {
                // 1. 从数据库加载最新的完整联系人列表
                const allContactsData = await dbHelper.loadData('messageContacts', 'allContacts');
                let allContacts = (allContactsData && Array.isArray(allContactsData.value)) ? allContactsData.value : [];

                // 2. 找到当前联系人在列表中的索引
                const contactIndex = allContacts.findIndex(c => c.id === currentOpenContact.id);

                if (contactIndex > -1) {
                    // 3. 用内存中最新的 currentOpenContact 对象，替换掉数组中的旧版本
                    allContacts[contactIndex] = currentOpenContact;
                } else {
                    // 如果在列表中找不到（例如，这是一个全新的对话），则添加到数组末尾
                    allContacts.push(currentOpenContact);
                }

                // 4. 将修改后的完整列表存回数据库
                await dbHelper.saveData('messageContacts', 'allContacts', allContacts);

            } catch (error) {
                console.error("Master save function failed:", error);
                // 在实际应用中，这里可能需要一个更友好的错误提示
            }
        }

            // === 新增：渲染图标设置列表的核心函数 ===
            async function renderIconSettings() {
                const container = document.getElementById('icon-list-container');
                if (!container) return;

                // 1. 获取主屏幕上所有带ID的App容器
                const appElements = document.querySelectorAll('#home-screen .app-container[id]');

                // 2. 从数据库加载已保存的自定义图标设置
                const savedIconsData = await dbHelper.loadData('settingsStore', 'customAppIcons');
                const savedIcons = (savedIconsData && savedIconsData.value) ? savedIconsData.value : {};

                container.innerHTML = ''; // 清空旧内容，防止重复

                // 3. 遍历每个App元素，生成对应的设置项
                appElements.forEach(app => {
                    const appId = app.id;
                    const appName = app.querySelector('.app-name').textContent;
                    const currentIconSrc = app.querySelector('.app-icon img').src;

                    // 获取为此App保存的URL，如果没有则为空字符串
                    const savedUrl = savedIcons[appId] || '';

                    const itemHTML = `
            <div class="icon-setting-item">
                <img src="${currentIconSrc}" class="icon-preview" data-app-id="${appId}">
                <div class="icon-details">
                    <span class="app-name-setting">${appName}</span>
                    <input type="text" class="icon-url-input" placeholder="输入新的图标URL" value="${savedUrl}" data-app-id="${appId}">
                </div>
            </div>
        `;
                    container.innerHTML += itemHTML;
                });
            }
// 监听整个列表容器的 'change' 事件 (当输入框失去焦点且内容改变时触发)
iconListContainer.addEventListener('change', async (event) => {
    // 检查事件是否由我们的URL输入框触发
    if (event.target.classList.contains('icon-url-input')) {
        const input = event.target;
        const appId = input.dataset.appId;
        const newUrl = input.value.trim();

        await updateAppIcon(appId, newUrl);
    }
});

// 负责更新UI和数据库的函数
async function updateAppIcon(appId, newUrl) {
    // 1. 更新主屏幕的图标
    const appIconOnHomeScreen = document.querySelector(`#${appId} .app-icon img`);
    // 2. 更新设置页的预览图标
    const iconPreviewInSettings = document.querySelector(`.icon-preview[data-app-id="${appId}"]`);

    if (!appIconOnHomeScreen || !iconPreviewInSettings) return;

    if (newUrl) {
        // 如果有新URL，则更新
        appIconOnHomeScreen.src = newUrl;
        iconPreviewInSettings.src = newUrl;
    } else {
        // 如果输入框被清空，则恢复为默认图标
        // 我们从HTML中读取默认值 (需要您确保img标签里有data-default-src属性)
        // 为了简单起见，我们这里先硬编码一个逻辑，更好的做法是在初始化时存储默认值
        // 这里我们重新加载页面来恢复默认值，更简单直接
        location.reload(); 
        return;
    }

    // 3. 保存到数据库
    try {
        const savedIconsData = await dbHelper.loadData('settingsStore', 'customAppIcons');
        let savedIcons = (savedIconsData && savedIconsData.value) ? savedIconsData.value : {};
        
        if (newUrl) {
            savedIcons[appId] = newUrl;
        } else {
            delete savedIcons[appId]; // 如果URL为空，则从保存记录中删除
        }

        await dbHelper.saveData('settingsStore', 'customAppIcons', savedIcons);
        
    } catch (error) {
        console.error("保存自定义图标失败:", error);
    }
}
// === 新增：页面加载时应用已保存的图标 ===
async function loadCustomIcons() {
    const savedIconsData = await dbHelper.loadData('settingsStore', 'customAppIcons');
    if (savedIconsData && savedIconsData.value) {
        const savedIcons = savedIconsData.value;
        for (const appId in savedIcons) {
            const iconUrl = savedIcons[appId];
            const appIconOnHomeScreen = document.querySelector(`#${appId} .app-icon img`);
            if (appIconOnHomeScreen && iconUrl) {
                appIconOnHomeScreen.src = iconUrl;
            }
        }
    }
}
// === 新增：时钟颜色更换的核心逻辑 ===

// 核心函数：更新所有时钟元素的颜色
function updateClockColor(color) {
    clockElements.forEach(span => {
        span.style.color = color;
    });
}

// 监听文本输入框的变化
clockColorInput.addEventListener('input', (event) => {
    const newColor = event.target.value;
    clockColorPicker.value = newColor; // 同步更新颜色选择器
    updateClockColor(newColor);
    dbHelper.saveData('settingsStore', 'clockColor', newColor); // 保存到数据库
});

// 监听颜色选择器的变化
clockColorPicker.addEventListener('input', (event) => {
    const newColor = event.target.value;
    clockColorInput.value = newColor; // 同步更新文本输入框
    updateClockColor(newColor);
    dbHelper.saveData('settingsStore', 'clockColor', newColor); // 保存到数据库
});
// === 新增：页面加载时应用已保存的时钟颜色 ===
async function loadClockColor() {
    const colorData = await dbHelper.loadData('settingsStore', 'clockColor');
    if (colorData && colorData.value) {
        const savedColor = colorData.value;
        updateClockColor(savedColor);
        // 同步更新设置页的输入框默认值
        clockColorInput.value = savedColor;
        clockColorPicker.value = savedColor;
    }
}
// === 新增：时钟高斯模糊功能的核心逻辑 ===

// 函数：根据传入的布尔值应用或移除模糊效果
function applyClockBlur(isEnabled) {
    if (isEnabled) {
        clockContainer.classList.add('clock-blur-enabled');
    } else {
        clockContainer.classList.remove('clock-blur-enabled');
    }
}

// 监听开关状态的变化
clockBlurToggle.addEventListener('change', async () => {
    const isEnabled = clockBlurToggle.checked;
    applyClockBlur(isEnabled); // 实时应用效果
    await dbHelper.saveData('settingsStore', 'clockBlurEffect', isEnabled); // 保存设置到数据库
});

// === 新增：页面加载时应用已保存的时钟模糊设置 ===
async function loadClockBlurSetting() {
    const blurData = await dbHelper.loadData('settingsStore', 'clockBlurEffect');
    // 如果数据库里有记录，则使用该记录的值；否则默认为 false (关闭)
    const isEnabled = blurData ? blurData.value : false;
    
    clockBlurToggle.checked = isEnabled; // 同步开关的状态
    applyClockBlur(isEnabled); // 应用效果
}

// --- 新增：快速回到底部按钮功能 ---

// 1. 获取需要的HTML元素
const scrollToBottomBtn = document.getElementById('scroll-to-bottom-btn');
// chatMessagesContainer 变量在之前的代码中已经获取，这里无需重复

// 2. 监听聊天窗口的滚动事件
chatMessagesContainer.addEventListener('scroll', () => {
    // 计算当前滚动条离底部的距离
    const scrollOffset = chatMessagesContainer.scrollHeight - chatMessagesContainer.scrollTop - chatMessagesContainer.clientHeight;
    
    // 设置一个阈值，比如滚动超过 300px 才显示按钮
    const threshold = 300; 

    if (scrollOffset > threshold) {
        // 如果离底部距离大于阈值，则显示按钮
        scrollToBottomBtn.classList.add('visible');
    } else {
        // 否则，隐藏按钮
        scrollToBottomBtn.classList.remove('visible');
    }
});

// 3. 监听按钮的点击事件
scrollToBottomBtn.addEventListener('click', () => {
    // 使用 smooth behavior 实现平滑滚动效果
    chatMessagesContainer.scrollTo({
        top: chatMessagesContainer.scrollHeight,
        behavior: 'smooth'
    });
});

// --- 新增（最终权威版）：点击(聚焦于)输入框时，自动滚动到聊天底部 ---

document.addEventListener('DOMContentLoaded', function() {
    
    const chatMessageInput = document.getElementById('chat-message-input');
    const chatContainer = document.getElementById('chat-messages-container');

    if (chatMessageInput && chatContainer) {
        
        // 检查浏览器是否支持 visualViewport API，这是处理虚拟键盘最现代、最可靠的方式
        if (window.visualViewport) {
            
            // 为 visualViewport 添加一个 'resize' 事件监听器
            window.visualViewport.addEventListener('resize', () => {
                // 这个事件会在键盘弹出或收起、导致可视区域变化时触发
                
                // 我们检查此时页面上获得焦点的元素是否就是我们的聊天输入框
                // 这样做可以避免在其他不相关的操作（如旋转屏幕）时也触发滚动
                if (document.activeElement === chatMessageInput) {
                    
                    // 如果是，我们就执行平滑滚动。
                    // 此时执行是100%准确的，因为我们是在浏览器完成布局调整后才操作的。
                    chatContainer.scrollTo({
                        top: chatContainer.scrollHeight,
                        behavior: 'smooth'
                    });
                }
            });

        } else {
            // 如果是不支持新API的老旧浏览器，我们保留一个基于延时的降级方案
            chatMessageInput.addEventListener('focus', () => {
                setTimeout(() => {
                    chatContainer.scrollTo({
                        top: chatContainer.scrollHeight,
                        behavior: 'smooth'
                    });
                }, 300); // 使用一个更长的延迟作为后备方案
            });
        }
    }
});

// === START: 七袋购物身份 JS (FUNCTIONS & EVENTS) ===

/**
 * 更新当前购物者信息，并刷新顶栏头像
 * @param {object} contact - 完整的联系人对象
 */
 function updateShopper(contact) {
    if (contact && contact.user) {
        currentShopper = contact.user; // 存储用户部分的信息
        shopperAvatarImg.src = currentShopper.avatar;
        console.log(`当前购物身份已切换为: ${currentShopper.name}`);
    }
}

/**
 * 打开选择用户的对话框
 */
async function openShopperSelectModal() {
    shopperListContainer.innerHTML = '<p style="text-align:center; color:#888;">正在加载...</p>';

    try {
        const contactsData = await dbHelper.loadData('messageContacts', 'allContacts');
        if (contactsData && Array.isArray(contactsData.value) && contactsData.value.length > 0) {
            shopperListContainer.innerHTML = ''; // 清空
            contactsData.value.forEach(contact => {
                // 我们只显示用户身份
                const user = contact.user;
                const contactItem = document.createElement('div');
                // 复用邀请列表的样式
                contactItem.className = 'invite-contact-item'; 
                contactItem.style.cursor = 'pointer';
                contactItem.dataset.contactId = contact.id;

                contactItem.innerHTML = `
                    <img src="${user.avatar}" alt="avatar" class="invite-contact-avatar">
                    <span class="invite-contact-name">${user.name}</span>
                `;
                shopperListContainer.appendChild(contactItem);
            });
        } else {
            shopperListContainer.innerHTML = '<p style="text-align:center; color:#888;">没有可用的用户身份</p>';
        }
    } catch (error) {
        console.error("加载用户列表失败:", error);
        shopperListContainer.innerHTML = '<p style="text-align:center; color:red;">加载失败</p>';
    }

    shopperSelectModal.style.display = 'flex';
    setTimeout(() => {
        shopperSelectModal.style.opacity = '1';
        shopperSelectModal.querySelector('.modal-content').style.transform = 'scale(1)';
    }, 10);
}

/**
 * 关闭选择用户的对话框
 */
function closeShopperSelectModal() {
    shopperSelectModal.style.opacity = '0';
    shopperSelectModal.querySelector('.modal-content').style.transform = 'scale(0.95)';
    setTimeout(() => {
        shopperSelectModal.style.display = 'none';
    }, 300);
}

// --- 事件监听 ---

// 点击顶栏头像，打开Modal
shopperAvatarButton.addEventListener('click', openShopperSelectModal);

// 点击Modal的关闭按钮
shopperModalCloseBtn.addEventListener('click', closeShopperSelectModal);

// 点击Modal中的用户列表项
shopperListContainer.addEventListener('click', async (event) => {
    const item = event.target.closest('.invite-contact-item');
    if (item) {
        const contactId = parseInt(item.dataset.contactId, 10);

        // 从数据库中找到完整的联系人对象
        const contactsData = await dbHelper.loadData('messageContacts', 'allContacts');
        const selectedContact = contactsData.value.find(c => c.id === contactId);

        if (selectedContact) {
            updateShopper(selectedContact); // 更新身份
            closeShopperSelectModal();   // 关闭Modal
        }
    }
});

// === END: 七袋购物身份 JS (FUNCTIONS & EVENTS) ===
// === START: SHOPMALL 标签页 JS (EVENTS) ===
// === START: SHOPMALL 标签页 JS (EVENTS) - V2 最终修复版 ===
shopTabBar.addEventListener('click', (event) => {
    const targetTab = event.target.closest('.shop-tab-item');
    if (!targetTab) return; 

    const panelIdToShow = targetTab.dataset.panelId;
    const newTitle = targetTab.dataset.title;

    // 1. 更新所有标签和面板的激活状态
    shopTabItems.forEach(tab => {
        tab.classList.toggle('active', tab === targetTab);
    });

    shopContentPanels.forEach(panel => {
        panel.classList.toggle('active', panel.id === panelIdToShow);
    });

    // 2. 更新顶栏标题
    shopTitle.textContent = newTitle;

    // 3. 【核心修复】检查当前是否切换到了购物面板
    if (panelIdToShow === 'shopping-content-panel') {
        
        // 4. 【核心修复】找到当前激活的分类按钮
        const activeCategoryTab = categoryTabsContainer.querySelector('.category-tab.active');
        
        // 5. 【核心修复】获取其类别，并重新调用 renderProducts 函数来绘制商品
        const currentCategory = activeCategoryTab ? activeCategoryTab.dataset.category : 'takeout';
        renderProducts(currentCategory);
    }
});
// === END: SHOPMALL 标签页 JS (EVENTS) - V2 最终修复版 ===


// === START: SHOPMALL 商品购物 JS (DATA & FUNCTIONS) ===

// 1. 示例商品数据
const productData = {
    takeout: [
        { name: '豪华牛肉汉堡', description: '精选安格斯牛肉，搭配新鲜生菜和秘制酱料，多汁美味。', price: 28.50 },
        { name: '日式豚骨拉面', description: '浓郁猪骨汤底，配上溏心蛋和叉烧，温暖你的胃。', price: 35.00 },
        { name: '麻辣小龙虾', description: '夏日必备，鲜活小龙虾配以独家麻辣调料，香辣过瘾。', price: 88.00 },
        { name: '水果缤纷沙拉', description: '多种新鲜时令水果，低卡健康，是轻食主义者的最爱。', price: 22.00 },
        { name: '意式番茄肉酱面', description: '经典意式风味，慢炖番茄肉酱搭配筋道意面，回味无穷。', price: 32.00 },
        { name: '奥尔良烤鸡翅', description: '秘制奥尔良酱料腌制，外焦里嫩，香气四溢。', price: 26.00 },
        { name: '海鲜披萨', description: '薄脆饼底，铺满虾仁、鱿鱼和芝士，海鲜爱好者首选。', price: 58.00 },
        { name: '宫保鸡丁饭', description: '鲜嫩鸡丁搭配花生和辣椒，麻辣鲜香，下饭神器。', price: 25.00 },
        { name: '韩式部队火锅', description: '芝士年糕、午餐肉和泡菜的完美融合，韩式风味十足。', price: 68.00 },
        { name: '泰式冬阴功汤', description: '酸辣开胃，大虾、蘑菇等食材丰富，异国风味浓郁。', price: 42.00 },
        { name: '香煎三文鱼套餐', description: '挪威三文鱼煎至金黄，搭配时蔬和土豆泥，营养均衡。', price: 78.00 },
        { name: '兰州牛肉拉面', description: '一清二白三红四绿，传统工艺制作，汤鲜味美。', price: 28.00 },
        { name: '墨西哥鸡肉卷', description: '嫩煎鸡肉配以莎莎酱和蔬菜，卷在薄饼中，风味独特。', price: 30.00 },
        { name: '招牌红烧肉', description: '精选五花肉，慢火炖至酥烂，肥而不腻，入口即化。', price: 45.00 },
        { name: '鲜虾云吞面', description: '手工云吞包裹大颗虾仁，搭配竹升面，汤清味鲜。', price: 36.00 },
        { name: '法式香煎鹅肝', description: '进口鹅肝煎至两面金黄，搭配无花果酱，奢华享受。', price: 98.00 },
        { name: '咖喱牛肉饭', description: '浓郁咖喱汁包裹鲜嫩牛肉和土豆，拌饭绝佳。', price: 32.00 },
        { name: '越南牛肉河粉', description: '清爽牛骨汤底，鲜嫩牛肉片，搭配香草，清新爽口。', price: 38.00 },
        { name: '黑松露蘑菇意面', description: '黑松露与蘑菇的鲜香融合，口感丰富，香气独特。', price: 56.00 },
        { name: '滋补乌鸡汤', description: '老火慢炖乌鸡汤，加入党参、枸杞，滋补养生。', price: 48.00 }
    ],
    electronics: [
        { name: '超静音机械键盘', description: '采用茶轴设计，既有段落感又保持安静，办公游戏两相宜。', price: 399.00 },
        { name: '高清降噪耳机', description: '主动降噪技术，让你在嘈杂环境中也能享受纯净音乐。', price: 799.00 },
        { name: '便携式充电宝', description: '20000mAh大容量，支持快充，告别电量焦虑。', price: 129.00 },
        { name: '智能运动手环', description: '实时监测心率、步数和睡眠，你的腕上健康管家。', price: 199.00 },
        { name: '4K超高清显示器', description: '27英寸大屏，4K分辨率，色彩精准，适合设计和观影。', price: 1499.00 },
        { name: '无线蓝牙耳机', description: '半入耳式设计，佩戴舒适，续航长达24小时。', price: 299.00 },
        { name: '超薄笔记本电脑', description: '14英寸全面屏，轻薄便携，性能强劲，办公首选。', price: 5999.00 },
        { name: '智能手表', description: '支持通话、支付和多种运动模式，功能全面。', price: 1599.00 },
        { name: '高清摄像头', description: '1080P分辨率，自动对焦，视频通话清晰流畅。', price: 199.00 },
        { name: '游戏手柄', description: '适配多平台，手感舒适，按键灵敏，游戏体验升级。', price: 299.00 },
        { name: '迷你投影仪', description: '便携设计，支持1080P投影，打造私人影院。', price: 2499.00 },
        { name: '智能音箱', description: '语音控制，智能家居中控，音质出色。', price: 399.00 },
        { name: '移动硬盘', description: '2TB大容量，高速传输，数据存储安全可靠。', price: 599.00 },
        { name: '氮化镓充电器', description: '65W大功率，小巧便携，多设备兼容。', price: 149.00 },
        { name: '蓝牙音箱', description: '防水设计，360°环绕音效，户外聚会必备。', price: 499.00 },
        { name: '机械鼠标', description: '高精度传感器，自定义按键，游戏办公皆宜。', price: 249.00 },
        { name: 'VR眼镜', description: '沉浸式体验，支持多种VR游戏和影视内容。', price: 1999.00 },
        { name: '行车记录仪', description: '4K高清夜视，停车监控，保障行车安全。', price: 399.00 },
        { name: '无线充电器', description: '15W快充，支持多设备兼容，桌面整洁神器。', price: 89.00 },
        { name: '智能门锁', description: '指纹识别，手机远程控制，安全便捷。', price: 1299.00 }
    ],
    daily: [
        { name: '进口无芯卷纸', description: '原生木浆制造，四层加厚，亲肤柔软，一包12卷。', price: 19.90 },
        { name: '自动感应洗手液机', description: '红外感应，免接触出泡，有效避免交叉感染，守护家人健康。', price: 69.00 },
        { name: '懒人桌面吸尘器', description: '强力吸除桌面灰尘、橡皮屑和零食碎屑，一键开启，轻松洁净。', price: 45.00 },
        { name: '分类收纳盒套装', description: '一套三件，不同尺寸满足各种收纳需求，让你的桌面井井有条。', price: 38.00 },
        { name: '天然竹纤维毛巾', description: '吸水性强，柔软亲肤，抗菌防霉，三条装。', price: 29.90 },
        { name: '多功能厨房剪刀', description: '锋利耐用，可剪骨头、蔬菜和肉类，还能开瓶和刮鱼鳞。', price: 39.00 },
        { name: '可降解垃圾袋', description: '环保材料制作，承重强不易破，100只装。', price: 12.90 },
        { name: '便携式折叠晾衣架', description: '外出旅行必备，折叠设计不占空间，承重能力强。', price: 49.00 },
        { name: '超声波香薰机', description: '静音运行，加湿香薰二合一，营造舒适环境。', price: 79.00 },
        { name: '多功能切菜器', description: '多种刀片可选，切丝切片切丁一键搞定，省时省力。', price: 59.00 },
        { name: '记忆棉枕头', description: '慢回弹材质，贴合颈椎曲线，改善睡眠质量。', price: 129.00 },
        { name: '不锈钢保温杯', description: '316不锈钢材质，保温保冷24小时，500ml容量。', price: 89.00 },
        { name: '厨房油污清洁剂', description: '强效去污，天然成分不伤手，轻松去除重油污。', price: 29.90 },
        { name: '防滑浴室地垫', description: '吸水速干，防滑设计，柔软舒适，多种图案可选。', price: 35.00 },
        { name: 'LED小夜灯', description: '光感自动开关，柔光不刺眼，呵护宝宝睡眠。', price: 19.90 },
        { name: '多功能数据线', description: '一拖三设计，支持快充，适用于手机、平板等设备。', price: 29.00 },
        { name: '天然植物洗衣液', description: '温和配方，深层洁净，不含荧光剂，适合母婴衣物。', price: 45.00 },
        { name: '便携式餐具套装', description: '包含筷子、勺子和叉子，食品级材质，环保卫生。', price: 25.00 },
        { name: '桌面加湿器', description: '迷你设计不占空间，静音运行，缓解空气干燥。', price: 59.00 },
        { name: '多功能笔记本支架', description: '可调节高度角度，散热透气，保护颈椎。', price: 79.00 }
    ],
    sports: [
        { name: '专业防滑瑜伽垫', description: '8mm加厚天然橡胶材质，防滑性能优异，环保无异味，附带绑带方便携带。', price: 129.00 },
        { name: '折叠露营帐篷', description: '3-4人全自动速开帐篷，防水防晒面料，通风设计，适合家庭户外露营。', price: 459.00 },
        { name: '轻量徒步登山鞋', description: '防水透气鞋面，防滑Vibram大底，减震鞋垫，适合中低难度徒步。', price: 699.00 },
        { name: '智能运动手表', description: '支持100+运动模式，心率血氧监测，50米防水，续航可达14天。', price: 899.00 },
        { name: '可折叠山地自行车', description: '27速变速系统，铝合金车架，折叠后可放入汽车后备箱，方便携带。', price: 1599.00 },
        { name: '多功能户外背包', description: '45L大容量，防水面料，背负系统舒适，适合2-3天户外徒步旅行。', price: 399.00 },
        { name: '专业羽毛球拍套装', description: '全碳素纤维材质，轻量化设计，含2支球拍、3个羽毛球和便携包。', price: 259.00 },
        { name: '自动充气防潮垫', description: '3cm加厚海绵，自动充气设计，防潮隔温，适合露营野餐使用。', price: 199.00 },
        { name: '速干运动套装', description: '男女同款，吸湿排汗面料，透气不闷汗，适合跑步健身等运动。', price: 159.00 },
        { name: '高强度拉力绳', description: '5根不同阻力绳组合，可调节长度，适合居家力量训练，附带收纳袋。', price: 89.00 },
        { name: '户外便携式水壶', description: '1L大容量，食品级不锈钢材质，保温保冷24小时，带登山扣设计。', price: 129.00 },
        { name: '专业潜水游泳镜', description: '防雾防紫外线镜片，硅胶密封圈，贴合不漏水，可调节头带。', price: 159.00 },
        { name: '折叠式太阳能充电宝', description: '20000mAh大容量，支持太阳能充电，双USB输出，户外应急必备。', price: 299.00 },
        { name: '室内健身动感单车', description: '静音磁控系统，可调节阻力和座椅高度，带心率监测功能。', price: 1899.00 },
        { name: '户外野营炉具套装', description: '便携式气炉+锅具组合，火力调节精准，适合野外烹饪。', price: 259.00 },
        { name: '专业跑步运动鞋', description: '缓震中底，透气网面，耐磨橡胶大底，适合长距离跑步。', price: 799.00 },
        { name: '多功能战术手电筒', description: '强光远射，支持爆闪和SOS模式，防水防尘，可充电设计。', price: 199.00 },
        { name: '瑜伽球健身球', description: '防爆材质，直径75cm，适合瑜伽练习和核心力量训练，附带打气筒。', price: 69.00 },
        { name: '户外保温野餐篮', description: '容量20L，保温层设计，可容纳4人份餐具，适合郊外野餐。', price: 299.00 },
        { name: '专业滑雪板套装', description: '全能型滑雪板+固定器+雪杖组合，适合初中级滑雪爱好者。', price: 2599.00 }
    ],
    beautyCare: [
        { name: '氨基酸洁面乳', description: '温和清洁配方，含氨基酸成分，洗完不紧绷，适合所有肤质', price: 89.00 },
        { name: '玻尿酸补水面膜', description: '高浓度玻尿酸精华，深层补水锁水，一盒10片装', price: 129.00 },
        { name: '烟酰胺亮肤精华液', description: '5%烟酰胺浓度，提亮肤色改善暗沉，淡化痘印', price: 159.00 },
        { name: '神经酰胺修护面霜', description: '三重神经酰胺配方，修复肌肤屏障，敏感肌适用', price: 219.00 },
        { name: '氨基酸泡泡沐浴露', description: '丰富细腻泡沫，温和清洁不假滑，持久留香', price: 59.00 },
        { name: '乳木果护手霜套装', description: '含乳木果油和维生素E，滋润保湿，3支装不同香型', price: 45.00 },
        { name: '芦荟胶舒缓凝胶', description: '99%芦荟原汁提取，舒缓晒后修护，可做睡眠面膜', price: 39.00 },
        { name: '化妆刷套装12支', description: '柔软人造纤维毛，含散粉刷、眼影刷等，送收纳包', price: 139.00 },
        { name: '天然植物洗发水', description: '无硅油配方，控油去屑，适合油性发质', price: 79.00 },
        { name: '防水睫毛膏', description: '浓密纤长效果，防水防汗不晕染，易卸妆', price: 69.00 },
        { name: '保湿粉底液', description: '轻薄服帖，自然遮瑕，持妆8小时不脱妆', price: 189.00 },
        { name: '去角质死皮膏', description: '温和去除面部老废角质，每周使用1-2次', price: 49.00 },
        { name: '防晒霜SPF50+', description: '高倍防晒，防水防汗，清爽不油腻', price: 99.00 },
        { name: '玫瑰纯露爽肤水', description: '天然玫瑰提取，补水保湿，可做水膜', price: 65.00 },
        { name: '卸妆水敏感肌用', description: '温和无刺激，眼唇脸三合一，深层清洁', price: 55.00 },
        { name: '维生素E润唇膏', description: '持久滋润保湿，淡化唇纹，无色透明', price: 25.00 },
        { name: '茶树精油祛痘凝胶', description: '快速消炎祛痘，淡化痘印，不刺激皮肤', price: 35.00 },
        { name: '压缩面膜纸100粒', description: '纯棉材质，吸水性强，搭配爽肤水使用', price: 29.00 },
        { name: '身体磨砂膏', description: '海盐颗粒，温和去角质，使肌肤光滑细腻', price: 69.00 },
        { name: '眉笔眉粉套装', description: '防水防汗，易上色不晕染，含眉笔、眉粉和眉刷', price: 59.00 }
    ],
    foodSnacks: [
        { name: '混合坚果礼盒', description: '包含巴旦木、腰果、核桃等6种坚果，独立小包装，每日一包补充营养', price: 159.00 },
        { name: '无蔗糖全麦饼干', description: '高纤维低热量，无蔗糖添加，口感酥脆，适合代餐或下午茶', price: 39.90 },
        { name: '冻干水果脆片', description: '草莓、芒果、香蕉多种口味组合，非油炸保留营养，儿童零食首选', price: 45.00 },
        { name: '纯黑巧克力', description: '85%可可含量，微苦醇厚，无添加蔗糖，独立小块装', price: 59.00 },
        { name: '日式拉面组合装', description: '豚骨、酱油、味噌三种口味，含独立汤包和叉烧，5包装', price: 69.00 },
        { name: '即食燕麦片', description: '澳洲纯燕麦，免煮即食，可搭配牛奶水果，营养早餐选择', price: 29.90 },
        { name: '牛肉干礼盒', description: '内蒙古风干工艺，原味和香辣两种口味，肉质紧实有嚼劲', price: 89.00 },
        { name: '速溶黑咖啡', description: '哥伦比亚进口咖啡豆，冻干技术保留风味，40条装', price: 65.00 },
        { name: '蜂蜜柚子茶', description: '韩国进口原料，蜂蜜与柚子黄金配比，冲水饮用酸甜可口', price: 45.00 },
        { name: '薯片大礼包', description: '原味、番茄、烧烤多种口味混合，独立小包装，分享装', price: 39.00 },
        { name: '五常稻花香大米', description: '5kg真空包装，黑龙江五常产区，米粒饱满口感香糯', price: 99.00 },
        { name: '特级初榨橄榄油', description: '2L装，西班牙进口，适合凉拌和低温烹饪，健康食用油', price: 129.00 },
        { name: '冻干银耳羹', description: '免煮即食，添加枸杞和冰糖，开水冲泡3分钟即可食用', price: 55.00 },
        { name: '鱿鱼丝海味零食', description: '深海鱿鱼制作，鲜嫩有嚼劲，独立包装方便携带', price: 35.00 },
        { name: '抹茶味曲奇饼干', description: '进口抹茶粉制作，茶香浓郁，口感酥脆，礼盒装', price: 49.00 },
        { name: '红豆薏米粉', description: '祛湿代餐粉，独立小包装，开水冲调即可食用，30条装', price: 59.00 },
        { name: '巴旦木夹心枣', description: '新疆灰枣夹巴旦木，无添加蔗糖，香甜可口，补血益气', price: 45.00 },
        { name: '意大利面套装', description: '含螺旋面、番茄酱和意式香草，4人份，简单易做', price: 39.00 },
        { name: '黄桃罐头', description: '砀山黄桃制作，无防腐剂，果肉饱满，糖水清甜', price: 35.00 },
        { name: '坚果燕麦能量棒', description: '代餐零食，含多种坚果和燕麦，抗饿4小时，12条装', price: 69.00 }
    ]


};

/**
 * 根据指定的商品类别，渲染商品列表
 * @param {string} category - 商品类别 (例如 'takeout', 'electronics')
 */
function renderProducts(category) {
    productGrid.innerHTML = ''; // 清空现有商品
    const items = productData[category] || []; // 获取对应类别的商品数组

    if (items.length === 0) {
        productGrid.innerHTML = '<p>该分类下暂无商品</p>';
        return;
    }

    items.forEach(item => {
        const card = document.createElement('div');
        card.className = 'product-card';
        card.innerHTML = `
            <div class="product-name">${item.name}</div>
            <div class="product-description">${item.description}</div>
            <div class="product-footer">
                <span class="product-price">¥${item.price.toFixed(2)}</span>
                <button class="add-to-cart-btn">+</button>
            </div>
        `;
        productGrid.appendChild(card);
    });
}

// --- 事件监听 ---

// 监听分类按钮的点击事件 (使用事件委托)
categoryTabsContainer.addEventListener('click', (event) => {
    const targetTab = event.target.closest('.category-tab');
    if (!targetTab) return;

    // 移除所有按钮的 'active' 状态
    categoryTabsContainer.querySelectorAll('.category-tab').forEach(tab => {
        tab.classList.remove('active');
    });

    // 为被点击的按钮添加 'active' 状态
    targetTab.classList.add('active');

    // 获取要显示的类别
    const categoryToShow = targetTab.dataset.category;
    // 重新渲染商品列表
    renderProducts(categoryToShow);
});

// 初始化时，默认加载第一个分类的商品
renderProducts('takeout');

// === END: SHOPMALL 商品购物 JS (DATA & FUNCTIONS) ===

// === START: SHOPMALL 购物流程 JS (FUNCTIONS & EVENTS) ===

// --- 数据库操作 ---
async function saveCartToDB() {
    await dbHelper.saveData('settingsStore', 'shoppingCart', shoppingCart);
}

async function loadCartFromDB() {
    const cartData = await dbHelper.loadData('settingsStore', 'shoppingCart');
    if (cartData && Array.isArray(cartData.value)) {
        shoppingCart = cartData.value;
    }
}

async function loadOrdersFromDB() {
    const ordersData = await dbHelper.loadData('settingsStore', 'myOrders');
    if (ordersData && Array.isArray(ordersData.value)) {
        renderOrders(ordersData.value);
    }
}

// --- 页面导航 ---
myCartButton.addEventListener('click', () => {
    renderCart(); // 打开前先渲染
    phoneFrame.classList.add('show-cart');
});
cartBackButton.addEventListener('click', () => {
    phoneFrame.classList.remove('show-cart');
});
myOrdersButton.addEventListener('click', () => {
    phoneFrame.classList.add('show-orders');
});
ordersBackButton.addEventListener('click', () => {
    phoneFrame.classList.remove('show-orders');
});

// --- “加入购物车” 功能 ---
productGrid.addEventListener('click', async (event) => {
    if (event.target.classList.contains('add-to-cart-btn')) {
        const card = event.target.closest('.product-card');
        const name = card.querySelector('.product-name').textContent;
        const priceText = card.querySelector('.product-price').textContent;
        const price = parseFloat(priceText.replace('¥', ''));

        const product = { id: Date.now(), name, price };
        shoppingCart.push(product);
        await saveCartToDB();

        // 添加一个简单的视觉反馈
        const originalText = event.target.textContent;
        event.target.textContent = '已添加!';
        setTimeout(() => {
            event.target.textContent = originalText;
        }, 1000);
    }
});

// --- 购物车渲染和操作 ---
function renderCart() {
    cartItemsContainer.innerHTML = '';
    if (shoppingCart.length === 0) {
        cartItemsContainer.innerHTML = '<p style="text-align:center; color:#888;">购物车是空的哦</p>';
        confirmPurchaseBtn.disabled = true;
        return;
    }

    confirmPurchaseBtn.disabled = false;
    shoppingCart.forEach(item => {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'cart-item';
        itemDiv.innerHTML = `
            <div class="cart-item-details">
                <div class="cart-item-name">${item.name}</div>
                <div class="cart-item-price">¥${item.price.toFixed(2)}</div>
            </div>
            <button class="cart-item-delete-btn" data-item-id="${item.id}">
                <svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M7.62211 7.47819L3.35254 3.20862" stroke="#FF0505" stroke-width="0.609939" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M7.62211 3.20862L3.35254 7.47819" stroke="#FF0000" stroke-width="0.609939" stroke-linecap="round" stroke-linejoin="round"/>
</svg>


            </button>
        `;
        cartItemsContainer.appendChild(itemDiv);
    });
}

cartItemsContainer.addEventListener('click', async (event) => {
    const deleteBtn = event.target.closest('.cart-item-delete-btn');
    if (deleteBtn) {
        const itemId = parseInt(deleteBtn.dataset.itemId, 10);
        shoppingCart = shoppingCart.filter(item => item.id !== itemId);
        await saveCartToDB();
        renderCart(); // 重新渲染购物车
    }
});

// === START: 收货人选择 JS (V2 - 已修复冻结问题) ===

/**
 * 打开选择收货人对话框 (带有动画效果)
 */
 function openRecipientSelectModal() {
    recipientSelectModal.style.display = 'flex';
    // 使用一个短暂的延时来确保CSS动画能够触发
    setTimeout(() => {
        recipientSelectModal.style.opacity = '1';
        recipientSelectModal.querySelector('.modal-content').style.transform = 'scale(1)';
    }, 10);
}

/**
 * 关闭选择收货人对话框 (带有动画效果)
 */
function closeRecipientSelectModal() {
    recipientSelectModal.style.opacity = '0';
    recipientSelectModal.querySelector('.modal-content').style.transform = 'scale(0.95)';
    // 等待动画结束后再隐藏元素
    setTimeout(() => {
        recipientSelectModal.style.display = 'none';
    }, 300);
}

// --- 事件监听 (替换旧的) ---
selectRecipientBtn.addEventListener('click', async () => {
    recipientListContainer.innerHTML = '<p style="text-align:center; color:#888;">正在加载...</p>';
    try {
        const contactsData = await dbHelper.loadData('messageContacts', 'allContacts');
        if (contactsData && Array.isArray(contactsData.value) && contactsData.value.length > 0) {
            recipientListContainer.innerHTML = '';
            contactsData.value.forEach(contact => {
                const ai = contact.ai;
                const item = document.createElement('div');
                item.className = 'invite-contact-item';
                item.style.cursor = 'pointer';
                item.dataset.recipient = JSON.stringify(ai);
                item.innerHTML = `
                    <img src="${ai.avatar}" alt="avatar" class="invite-contact-avatar">
                    <span class="invite-contact-name">${ai.name}</span>
                `;
                recipientListContainer.appendChild(item);
            });
        } else {
            recipientListContainer.innerHTML = '<p>没有可用的收货人</p>';
        }
    } catch (error) {
        console.error(error);
        recipientListContainer.innerHTML = '<p style="color:red;">加载失败</p>';
    }

    // 调用我们新的、带动画的打开函数
    openRecipientSelectModal(); 
});

// 关闭按钮调用新的关闭函数
recipientModalCloseBtn.addEventListener('click', closeRecipientSelectModal);

// 选择收货人后调用新的关闭函数
recipientListContainer.addEventListener('click', (event) => {
    const item = event.target.closest('.invite-contact-item');
    if (item) {
        currentRecipient = JSON.parse(item.dataset.recipient);
        recipientNameDisplay.textContent = currentRecipient.name;
        closeRecipientSelectModal(); // 调用新的关闭函数
    }
});

// === END: 收货人选择 JS (V2 - 已修复冻结问题) ===
// --- 确认购买 ---
confirmPurchaseBtn.addEventListener('click', async () => {

    if (shoppingCart.length === 0) {
        alert("购物车是空的！");
        return;
    }
    if (!currentRecipient) {
        alert("请先选择收货人！");
        return;
    }

    const totalAmount = shoppingCart.reduce((sum, item) => sum + item.price, 0);
    const currentBalance = await getBalance();
    if (currentBalance < totalAmount) {
        alert(`余额不足！需要 ¥${totalAmount.toFixed(2)}，当前只有 ¥${currentBalance.toFixed(2)}。`);
        return;
    }
    
    await logTransactionAndUpdateBalance({
        description: `在七袋购物消费`,
        amount: -totalAmount
    });
    
    const newOrder = {
        id: Date.now(),
        items: [...shoppingCart],
        totalAmount: totalAmount,
        recipient: currentRecipient,
        purchaseDate: new Date()
    };

    const ordersData = await dbHelper.loadData('settingsStore', 'myOrders');
    let allOrders = (ordersData && Array.isArray(ordersData.value)) ? ordersData.value : [];
    allOrders.unshift(newOrder);
    await dbHelper.saveData('settingsStore', 'myOrders', allOrders);

    shoppingCart = [];
    await saveCartToDB();

    alert(`购买成功！消费了 ¥${totalAmount.toFixed(2)}。`);
    renderCart();
    renderOrders(allOrders);
    phoneFrame.classList.remove('show-cart');
    phoneFrame.classList.add('show-orders');
});

// --- 订单渲染 ---
// 用这个更健壮的新版本，替换旧的 renderOrders 函数

async function renderOrders(orders) {
    ordersListContainer.innerHTML = '';
    
    // 增加一个检查，确保 orders 本身是一个有效的数组
    if (!orders || orders.length === 0) {
        ordersListContainer.innerHTML = '<p style="text-align:center; color:#888;">还没有任何订单</p>';
        return;
    }

    orders.forEach(order => {
        const orderCard = document.createElement('div');
        orderCard.className = 'order-card';

        // ▼▼▼ 核心修复在这里 ▼▼▼
        // 在使用 .map() 之前，先检查 order.items 是否为一个数组，如果不是，则使用一个空数组代替
        const itemsToRender = Array.isArray(order.items) ? order.items : [];
        const itemsHtml = itemsToRender.map(item => `<li>${item.name} - ¥${(item.price || 0).toFixed(2)}</li>`).join('');
        const totalAmountHtml = `¥${(order.totalAmount || 0).toFixed(2)}`;

        
        // ▲▲▲ 修复结束 ▲▲▲

        orderCard.innerHTML = `
            <button class="order-share-btn" data-order-id="${order.id}">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <g clip-path="url(#clip0_50_22)">
                    <path d="M4 5H6" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M5 4V6" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M11.5 4L11 6" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M18 5H20" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M19 4V6" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M15 9L14 10" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M18 13L20 12.5" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M18 19H20" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M19 18V20" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M14 16.518L7.48196 10L3.09196 19.58C3.00703 19.766 2.98098 19.9735 3.01728 20.1747C3.05359 20.3759 3.15053 20.5613 3.29512 20.7058C3.4397 20.8504 3.62501 20.9474 3.82624 20.9837C4.02746 21.02 4.23497 20.9939 4.42096 20.909L14 16.519V16.518Z" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </g>
                    <defs><clipPath id="clip0_50_22"><rect width="24" height="24" fill="white"/></clipPath></defs>
                </svg>
            </button>
            <div class="order-details">
                <div class="order-title">订单商品</div>
                <ul style="padding-left: 20px; margin: 5px 0 0; font-size: 15px;">${itemsHtml}</ul>
            </div>
            <div class="order-header">
                <div class="order-title">订单总额</div>
                <div class="order-value">¥${(order.totalAmount || 0).toFixed(2)}</div>
            </div>
            <div class="order-recipient">
                <div class="order-title">收货人</div>
                <div class="order-value">${order.recipient ? order.recipient.name : '未知'}</div>
            </div>
            <div class="order-date">
                 <div class="order-title">下单时间</div>
                <div class="order-value">${new Date(order.purchaseDate).toLocaleString('zh-CN')}</div>
            </div>
        `;
        ordersListContainer.appendChild(orderCard);
    });
}
// === END: SHOPMALL 购物流程 JS (FUNCTIONS & EVENTS) ===

// === START: 订单分享功能 JS (V3 - 按正确顺序执行) ===
// === START: 订单分享功能 JS (V4 - 修正导航逻辑) ===
ordersListContainer.addEventListener('click', async (event) => {
    const shareBtn = event.target.closest('.order-share-btn');
    if (!shareBtn) return;

    const orderId = parseInt(shareBtn.dataset.orderId, 10);

    try {
        // --- 1. 准备工作：获取订单和收件人信息 (这部分不变) ---
        const ordersData = await dbHelper.loadData('settingsStore', 'myOrders');
        const orderToShare = ordersData.value.find(o => o.id === orderId);
        if (!orderToShare) throw new Error("找不到该订单");

        const contactsData = await dbHelper.loadData('messageContacts', 'allContacts');
        const recipientContact = contactsData.value.find(c => c.ai.name === orderToShare.recipient.name);
        if (!recipientContact) throw new Error("找不到收件人对应的聊天对话");

        // --- 2. 保存消息 (这部分不变) ---
        const messageText = `[ORDER_SHARE_CARD]${JSON.stringify(orderToShare)}`;
        const userMessage = {
            sender: 'user', text: messageText, timestamp: new Date(),
            uuid: Date.now() + '-' + Math.random().toString(36).substr(2, 9)
        };
        // 手动更新并保存联系人数据
        if (!Array.isArray(recipientContact.history)) recipientContact.history = [];
        recipientContact.history.push(userMessage);
        recipientContact.lastMessage = "分享了一个订单";
        const allContacts = contactsData.value;
        const contactIndex = allContacts.findIndex(c => c.id === recipientContact.id);
        if (contactIndex > -1) {
            allContacts[contactIndex] = recipientContact;
            await dbHelper.saveData('messageContacts', 'allContacts', allContacts);
        }
        
        // ▼▼▼ START: 核心导航逻辑修改 ▼▼▼

        // 3. 设置正确的导航层级
        // 首先，将“消息App”设为底层显示的界面
        phoneFrame.classList.add('show-messages');
        // 然后，移除所有可能存在的“七袋”相关界面的显示类
        phoneFrame.classList.remove('show-cart');
        phoneFrame.classList.remove('show-orders');
        
        // 4. 最后，打开聊天界面并触发AI回复
        await openChatView(recipientContact.id);
        
        const aiTriggerMessage = `(我给你分享了一个订单，商品是“${orderToShare.items.map(i => i.name).join(', ')}”，请根据你的人设和我们的关系对此作出回应。)`;
        await callAI(aiTriggerMessage, recipientContact);

        // ▲▲▲ END: 核心导航逻辑修改 ▲▲▲

    } catch (error) {
        console.error("分享订单失败:", error);
        alert(`分享失败: ${error.message}`);
    }
});
// === END: 订单分享功能 JS (V4 - 修正导航逻辑) ===
// === END: 订单分享功能 JS (V3 - 按正确顺序执行) ===

// ▼▼▼ START: 在这里粘贴新的摸鱼App交互逻辑 ▼▼▼

// --- 1. 导航逻辑：进入和退出App ---

// 点击“摸鱼”App图标，显示App界面
slackingOffAppIcon.addEventListener('click', () => {
    phoneFrame.classList.add('show-slacking-off');
    renderGames();
});

// 点击返回按钮，回到主屏幕
slackingOffBackButton.addEventListener('click', () => {
    phoneFrame.classList.remove('show-slacking-off');
});


// --- 2. 标签页切换逻辑 ---

slackingOffTabBar.addEventListener('click', (event) => {
    const targetTab = event.target.closest('.slacking-off-tab-item');
    if (!targetTab) return;

    const panelIdToShow = targetTab.dataset.panelId;
    const newTitle = targetTab.dataset.title;

    // 更新顶栏标题
    slackingOffTitle.textContent = newTitle;

    // 更新标签按钮的激活状态
    slackingOffTabBar.querySelectorAll('.slacking-off-tab-item').forEach(tab => {
        tab.classList.remove('active');
    });
    targetTab.classList.add('active');

    // 更新内容面板的显示状态
    slackingOffScreen.querySelectorAll('.slacking-off-content-panel').forEach(panel => {
        if (panel.id === panelIdToShow) {
            panel.classList.add('active');
        } else {
            panel.classList.remove('active');
        }
    });
});
// ▼▼▼ 在这里粘贴新的钱包管理函数 ▼▼▼

/**
 * 获取当前用户余额
 * @returns {Promise<number>} 返回当前余额，如果不存在则返回初始值100
 */
 async function getBalance() {
    const balanceData = await dbHelper.loadData('settingsStore', 'userBalance');
    // 如果没有余额记录，给予100的初始资金
    return balanceData ? balanceData.value : 100;
}

/**
 * 更新用户余额
 * @param {number} amount - 要增加（正数）或减少（负数）的金额
 * @returns {Promise<number>} 返回更新后的新余额
 */
// 用这个新版本替换旧的 updateBalance 函数


/**
 * 刷新“储蓄”界面的余额显示
 */
// 用这个新版本替换旧的 updateBalanceDisplay 函数

async function updateBalanceDisplay() {
    const currentBalance = await getBalance();
    if (balanceDisplay) {
        balanceDisplay.textContent = `¥${currentBalance.toFixed(2)}`;
    }
    // --- 控制“申请解除”按钮的可见性 ---
    if (applyUnlockBtn) {
        if (currentBalance <= -200) {
            applyUnlockBtn.style.display = 'block';
        } else {
            applyUnlockBtn.style.display = 'none';
        }
    }
}
// ▼▼▼ 在这里粘贴游戏数据和渲染逻辑 ▼▼▼

// 1. 定义游戏数据
const gamesData = [
    {
        id: 'coin-flip',
        name: '幸运硬币',
        description: '猜猜硬币是正面还是反面？猜对赢¥50，猜错亏¥20。',
        image: 'https://i.postimg.cc/q7BWsqYB/0728bde4133c361a0d86d02dc7f0c625.png',
        winChance: 0.5, // 50%的胜率
        reward: 50,
        penalty: -20
    },
    {
        id: 'number-guess',
        name: '数字大师',
        description: '从1-3中猜一个数字。猜对赢¥80，猜错亏¥40。',
        image: 'https://i.postimg.cc/fLpFQKbk/26408f03e171688d69f0ac84c5f0bdc3.jpg',
        winChance: 0.33, // 33%的胜率
        reward: 80,
        penalty: -40
    },
    {
        id: 'go_to_work',
        name: '上班模拟',
        description: '体验打工人的悲欢离合，你的薪水将由今日的运势决定。',
        image: 'https://i.postimg.cc/tJ6cqx1k/e40723f24112fcbfb5b593fab10e3b5c.png'
    },
    {
        id: 'lottery',
        name: '买彩票',
        description: '搏一搏，单车变摩托！花费少量储蓄，赢取最高2000元大奖！',
        image: 'https://i.postimg.cc/8504rz8Y/bc4d45476e2902ff4bd22788d2119ae6.jpg'
    }
];

// 2. 渲染所有游戏卡片到界面
function renderGames() {
    if (!gamesGrid) return;
    gamesGrid.innerHTML = ''; // 清空旧内容
    gamesData.forEach(game => {
        const card = document.createElement('div');
        card.className = 'game-card';
        card.innerHTML = `
            <img src="${game.image}" alt="${game.name}">
            <div class="game-card-info">
                <h3>${game.name}</h3>
                <p>${game.description}</p>
                <button class="play-game-btn" data-game-id="${game.id}">开始玩</button>
            </div>
        `;
        gamesGrid.appendChild(card);
    });
}
// ▲▲▲ 游戏数据和渲染逻辑粘贴结束 ▲▲▲
// ▲▲▲ 钱包管理函数粘贴结束 ▲▲▲

// ▲▲▲ 摸鱼App交互逻辑粘贴结束 ▲▲▲
// ▼▼▼ 在这里粘贴游戏点击处理逻辑 ▼▼▼
// 用这个新版本替换旧的 gamesGrid.addEventListener

// 用这个新版本替换旧的 gamesGrid.addEventListener

// 用这个新版本替换旧的 gamesGrid.addEventListener

gamesGrid.addEventListener('click', async (event) => {
    if (!event.target.classList.contains('play-game-btn')) return;

    const gameId = event.target.dataset.gameId;
    const game = gamesData.find(g => g.id === gameId);
    if (!game) return;

    const currentBalance = await getBalance();
    if (currentBalance <= -200) {
        openCreditModal(blacklistModal);
        return;
    }

    // 根据游戏ID决定行为
    if (gameId === 'coin-flip' || gameId === 'number-guess') {
        openGameModal(document.getElementById(`${gameId}-modal`));
    } else if (gameId === 'lottery') { // 【新增】处理彩票游戏
        openGameModal(document.getElementById('lottery-modal'));
    } else if (gameId === 'go_to_work') {
        const eventResult = workEvents[Math.floor(Math.random() * workEvents.length)];
        await logTransactionAndUpdateBalance({
            description: eventResult.text.split('，')[0],
            amount: eventResult.amount
        });
        let resultMessage = `【今日工作总结】\n\n${eventResult.text}\n\n`;
        if (eventResult.amount > 0) {
            resultMessage += `储蓄增加: ¥${eventResult.amount.toFixed(2)}`;
        } else if (eventResult.amount < 0) {
            resultMessage += `储蓄减少: ¥${Math.abs(eventResult.amount).toFixed(2)}`;
        } else {
            resultMessage += `储蓄无变化。`;
        }
        alert(resultMessage);
    }
});

// 用这个新版本替换旧的 numberGuessModal 事件监听器
numberGuessModal.addEventListener('click', async (event) => {
    const choiceBtn = event.target.closest('.game-choice-btn');
    if (!choiceBtn) return;

    const userChoice = parseInt(choiceBtn.dataset.choice, 10);
    const game = gamesData.find(g => g.id === 'number-guess');
    
    const computerChoice = Math.floor(Math.random() * 3) + 1;
    
    let resultMessage = `你选择了 ${userChoice}，正确答案是 ${computerChoice}。\n\n`;
    let transactionAmount; // 用于记录本次交易金额

    if (userChoice === computerChoice) {
        transactionAmount = game.reward;
        resultMessage += `猜对了！恭喜你赢了 ¥${game.reward.toFixed(2)}！`;
    } else {
        transactionAmount = game.penalty;
        resultMessage += `真遗憾！你输了 ¥${Math.abs(game.penalty).toFixed(2)}。`;
    }

    // ▼▼▼ 核心修改：调用新的记账函数 ▼▼▼
    await logTransactionAndUpdateBalance({ description: '玩数字大师', amount: transactionAmount });
    // ▲▲▲ 修改结束 ▲▲▲

    closeGameModals();
    setTimeout(() => alert(resultMessage), 310);
});


// 用这个新版本替换旧的 coinFlipModal 事件监听器
coinFlipModal.addEventListener('click', async (event) => {
    const choiceBtn = event.target.closest('.game-choice-btn');
    if (!choiceBtn) return;

    const userChoice = choiceBtn.dataset.choice;
    const game = gamesData.find(g => g.id === 'coin-flip');

    const computerChoice = Math.random() < 0.5 ? 'heads' : 'tails';
    const computerChoiceText = computerChoice === 'heads' ? '正面' : '反面';
    
    let resultMessage = `你猜了 ${userChoice === 'heads' ? '正面' : '反面'}，结果是 ${computerChoiceText}。\n\n`;
    let transactionAmount; // 用于记录本次交易金额

    if (userChoice === computerChoice) {
        transactionAmount = game.reward;
        resultMessage += `猜对了！恭喜你赢了 ¥${game.reward.toFixed(2)}！`;
    } else {
        transactionAmount = game.penalty;
        resultMessage += `真遗憾！你输了 ¥${Math.abs(game.penalty).toFixed(2)}。`;
    }
    
    // ▼▼▼ 核心修改：调用新的记账函数 ▼▼▼
    await logTransactionAndUpdateBalance({ description: '玩幸运硬币', amount: transactionAmount });
    // ▲▲▲ 修改结束 ▲▲▲
    
    closeGameModals();
    setTimeout(() => alert(resultMessage), 310);
});
// ▼▼▼ 在这里粘贴新的游戏弹窗控制函数 ▼▼▼

/**
 * 打开一个指定的游戏弹窗
 * @param {HTMLElement} modalElement 要打开的弹窗元素
 */
 function openGameModal(modalElement) {
    if (!modalElement) return;
    modalElement.style.display = 'flex';
    setTimeout(() => {
        modalElement.style.opacity = '1';
        modalElement.querySelector('.modal-content').style.transform = 'scale(1)';
    }, 10);
}

/**
 * 关闭所有游戏弹窗
 */
 function closeGameModals() {
    // 找到所有游戏弹窗并关闭它们
    document.querySelectorAll('#coin-flip-modal, #number-guess-modal, #lottery-modal, #blacklist-modal, #unlock-modal').forEach(modal => {
        modal.style.opacity = '0';
        modal.querySelector('.modal-content').style.transform = 'scale(0.95)';
        setTimeout(() => {
            modal.style.display = 'none';
        }, 300);
    });
}
// ▼▼▼ 在这里粘贴游戏核心逻辑代码 ▼▼▼

// --- 猜数字游戏的核心逻辑 ---
numberGuessModal.addEventListener('click', async (event) => {
    const choiceBtn = event.target.closest('.game-choice-btn');
    if (!choiceBtn) return; // 如果点的不是按钮，则不执行任何操作

    const userChoice = parseInt(choiceBtn.dataset.choice, 10);
    const game = gamesData.find(g => g.id === 'number_guess');
    
    // 生成一个1, 2, 或 3的随机数作为正确答案
    const computerChoice = Math.floor(Math.random() * 3) + 1;
    
    let resultMessage = `你选择了 ${userChoice}，正确答案是 ${computerChoice}。\n\n`;

    if (userChoice === computerChoice) {
        await updateBalance(game.reward);
        resultMessage += `猜对了！恭喜你赢了 ¥${game.reward.toFixed(2)}！`;
    } else {
        await updateBalance(game.penalty);
        resultMessage += `真遗憾！你输了 ¥${Math.abs(game.penalty).toFixed(2)}。`;
    }

    closeGameModals(); // 先关闭弹窗
    setTimeout(() => alert(resultMessage), 310); // 稍作延迟后显示结果
});

// --- 抛硬币游戏的核心逻辑 ---
coinFlipModal.addEventListener('click', async (event) => {
    const choiceBtn = event.target.closest('.game-choice-btn');
    if (!choiceBtn) return;

    const userChoice = choiceBtn.dataset.choice; // "heads" 或 "tails"
    const game = gamesData.find(g => g.id === 'coin_flip');

    // 随机生成硬币正反面
    const computerChoice = Math.random() < 0.5 ? 'heads' : 'tails';
    const computerChoiceText = computerChoice === 'heads' ? '正面' : '反面';
    
    let resultMessage = `你猜了 ${userChoice === 'heads' ? '正面' : '反面'}，结果是 ${computerChoiceText}。\n\n`;

    if (userChoice === computerChoice) {
        await updateBalance(game.reward);
        resultMessage += `猜对了！恭喜你赢了 ¥${game.reward.toFixed(2)}！`;
    } else {
        await updateBalance(game.penalty);
        resultMessage += `真遗憾！你输了 ¥${Math.abs(game.penalty).toFixed(2)}。`;
    }
    
    closeGameModals();
    setTimeout(() => alert(resultMessage), 310);
});
// ▼▼▼ 在这里粘贴新的信用系统函数 ▼▼▼

/**
 * 如果数据库中没有解锁码，则创建并存入初始解锁码
 */
 async function initializeUnlockCodes() {
    const codesData = await dbHelper.loadData('settingsStore', 'unlockCodes');
    if (!codesData) { // 只在完全没有记录时执行
        const initialCodes = [
            'QIQI-LOVE-U-01', 'SLACK-OFF-KING', 'GAME-MASTER-77', 'CODE-BREAKER-X',
            'LUCKY-STAR-2024', 'FREEDOM-PASS-A', 'GET-RICH-QUICK', 'DEBT-CLEANER-PRO',
            'QIQI-BANK-VIP', 'THE-ONLY-WAY', 'RESET-MY-LIFE', 'GOLDEN-TICKET-7',
            'PHOENIX-DOWN-GG', 'ULTIMATE-CODE', 'SECRET-HANDSHAKE', 'BACK-TO-ZERO-00',
            'GAME-CHANGER-25', 'MASTER-KEY-007', 'NEW-BEGINNING', 'LAST-CHANCE-OK'
        ];
        const codesObject = {};
        initialCodes.forEach(code => {
            codesObject[code] = 5; // 每个码可以用5次
        });
        await dbHelper.saveData('settingsStore', 'unlockCodes', codesObject);
        console.log("解锁码已初始化。");
    }
}

/**
 * 打开指定的信用系统弹窗
 * @param {HTMLElement} modalElement
 */
function openCreditModal(modalElement) {
    if (!modalElement) return;
    modalElement.style.display = 'flex';
    setTimeout(() => {
        modalElement.style.opacity = '1';
        modalElement.querySelector('.modal-content').style.transform = 'scale(1)';
    }, 10);
}

/**
 * 关闭所有信用系统弹窗
 */
function closeCreditModals() {
    document.querySelectorAll('#blacklist-modal, #unlock-modal').forEach(modal => {
        modal.style.opacity = '0';
        modal.querySelector('.modal-content').style.transform = 'scale(0.95)';
        setTimeout(() => {
            modal.style.display = 'none';
        }, 300);
    });
}
// ▼▼▼ 在这里粘贴新的信用系统事件监听器 ▼▼▼

// “拉黑弹窗”里的按钮，点击后跳转到储蓄标签页
goToSavingsBtn.addEventListener('click', () => {
    closeCreditModals();
    // 模拟点击“储蓄”标签页
    document.getElementById('slacking-off-tab-savings').click();
});

// 点击“申请解除”按钮，打开解锁码输入弹窗
applyUnlockBtn.addEventListener('click', () => {
    openCreditModal(unlockModal);
});

// 关闭解锁码弹窗
unlockModalCloseBtn.addEventListener('click', closeCreditModals);

// “确认解锁”按钮的核心逻辑
confirmUnlockBtn.addEventListener('click', async () => {
    const inputCode = unlockCodeInput.value.trim();
    if (!inputCode) {
        alert('请输入解锁码！');
        return;
    }

    try {
        const codesData = await dbHelper.loadData('settingsStore', 'unlockCodes');
        let codesObject = codesData.value;

        // 检查解锁码是否存在且可用
        if (codesObject && codesObject[inputCode] && codesObject[inputCode] > 0) {
            // 解锁成功
            codesObject[inputCode]--; // 使用次数减1
            
            // 将更新后的解锁码数据存回数据库
            await dbHelper.saveData('settingsStore', 'unlockCodes', codesObject);
            
            // 将余额重置为0
            await dbHelper.saveData('settingsStore', 'userBalance', 0);
            
            // 刷新显示
            await updateBalanceDisplay();

            alert(`解锁成功！\n\n该解锁码剩余使用次数：${codesObject[inputCode]}\n\n您的账户已恢复正常，储蓄已重置为 ¥0.00。`);
            closeCreditModals();
            unlockCodeInput.value = '';

        } else if (codesObject && codesObject[inputCode] === 0) {
            // 解锁码已用完
            alert('解锁失败！该解锁码的使用次数已用尽。');
        } else {
            // 解锁码无效
            alert('解锁失败！无效的解锁码。');
        }

    } catch (error) {
        console.error("解锁过程中发生错误:", error);
        alert("操作失败，请稍后重试。");
    }
});


// ▼▼▼ 在这里粘贴上班模拟的随机事件数据 ▼▼▼

const workEvents = [
    { text: "业绩突出，拿下大单，老板高兴地发了奖金！", amount: 200, type: 'reward' },
    { text: "会议上提出绝妙点子，项目奖金到手！", amount: 150, type: 'reward' },
    { text: "帮同事解决了技术难题，收获了下午茶基金。", amount: 50, type: 'reward' },
    { text: "公司年会抽中二等奖！", amount: 300, type: 'reward' },
    { text: "写的报告被评为最佳范本，获得了绩效奖励。", amount: 120, type: 'reward' },
    { text: "迟到5分钟，正好撞见老板，被扣了工资。", amount: -50, type: 'penalty' },
    { text: "上班摸鱼刷手机被发现，本月绩效减半。", amount: -100, type: 'penalty' },
    { text: "提交的方案出现重大疏漏，需要自费请客赔罪。", amount: -80, type: 'penalty' },
    { text: "在茶水间说老板坏话，被路过的老板听见了...", amount: -150, type: 'penalty' },
    { text: "电脑突然蓝屏，重要文件没保存，项目延误被罚款。", amount: -180, type: 'penalty' },
    { text: "通勤路上捡到钱包，交给警察叔叔后发现里面有感谢费。", amount: 100, type: 'reward' },
    { text: "下班后买彩票，竟然中了末等奖。", amount: 10, type: 'reward' },
    { text: "在公司楼下遇到总裁，总裁看你骨骼惊奇，给了你一个红包。", amount: 88, type: 'reward' },
    { text: "午休时做梦，梦到一组神秘数字，醒来后发现是自己的银行卡余额。", amount: 0, type: 'neutral' },
    { text: "一整天都在开会，精神恍惚，无功无过。", amount: 0, type: 'neutral' },
    { text: "坐电梯时遇到超载，你主动走了出来，结果电梯坏了，你因此躲过一劫并获得了见义勇为奖。", amount: 20, type: 'reward' },
    { text: "点外卖时用错了优惠券，多花了一笔钱。", amount: -15, type: 'penalty' },
    { text: "参加公司组织的团建，因为太离谱而精神受创，获得了精神损失费。", amount: 30, type: 'reward' },
    { text: "把公司打印机弄坏了，需要赔偿维修费。", amount: -200, type: 'penalty' },
    { text: "发现公司财务系统的一个BUG，避免了巨大损失，获得特殊贡献奖！", amount: 500, type: 'reward' }
];
// ▼▼▼ 在这里粘贴全新的统一记账函数 ▼▼▼

/**
 * 记录一笔交易，并更新余额
 * 这是新的核心函数，所有金钱变动都必须调用它
 * @param {object} transaction - 交易对象，包含 { description: string, amount: number }
 * @returns {Promise<number>} 返回更新后的新余额
 */
 async function logTransactionAndUpdateBalance(transaction) {
    // 1. 添加时间戳
    transaction.timestamp = new Date();

    // 2. 从数据库读取旧的交易记录
    const historyData = await dbHelper.loadData('settingsStore', 'transactionHistory');
    let history = (historyData && Array.isArray(historyData.value)) ? historyData.value : [];

    // 3. 将新记录添加到最前面
    history.unshift(transaction);

    // 4. 将更新后的记录存回数据库
    await dbHelper.saveData('settingsStore', 'transactionHistory', history);

    // 5. 更新余额
    let currentBalance = await getBalance();
    const newBalance = currentBalance + transaction.amount;

    if (newBalance <= -200) {
        openCreditModal(blacklistModal);
        await dbHelper.saveData('settingsStore', 'userBalance', -200);
    } else {
        await dbHelper.saveData('settingsStore', 'userBalance', newBalance);
    }

    await updateBalanceDisplay();
    return newBalance;
}
// ▼▼▼ 在这里粘贴新的明细页面导航和渲染逻辑 ▼▼▼

// --- 导航逻辑 ---
transactionHistoryCard.addEventListener('click', () => {
    renderTransactions(); // 打开页面前先渲染内容
    phoneFrame.classList.add('show-transactions');
});

transactionsBackButton.addEventListener('click', () => {
    phoneFrame.classList.remove('show-transactions');
});

// --- 渲染逻辑 ---
async function renderTransactions() {
    const historyData = await dbHelper.loadData('settingsStore', 'transactionHistory');
    let history = (historyData && Array.isArray(historyData.value)) ? historyData.value : [];

    transactionsListContainer.innerHTML = ''; // 清空旧列表

    if (history.length === 0) {
        transactionsListContainer.innerHTML = '<p style="text-align:center; color:#888;">暂无收支记录</p>';
        return;
    }

    history.forEach(tx => {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'transaction-item';
        
        const amountClass = tx.amount >= 0 ? 'income' : 'expense';
        const amountPrefix = tx.amount >= 0 ? '+' : '';
        
        itemDiv.innerHTML = `
            <div class="transaction-info">
                <div class="description">${tx.description}</div>
                <div class="timestamp">${new Date(tx.timestamp).toLocaleString('zh-CN')}</div>
            </div>
            <div class="transaction-amount ${amountClass}">
                ${amountPrefix}${tx.amount.toFixed(2)}
            </div>
        `;
        transactionsListContainer.appendChild(itemDiv);
    });
}
// --- 2. 导航逻辑：进入和退出App ---

// 点击“GACHA！”App图标，显示App界面
gachaAppIcon.addEventListener('click', () => {
    phoneFrame.classList.add('show-gacha');
});

// 点击返回按钮，回到主屏幕
gachaBackButton.addEventListener('click', () => {
    phoneFrame.classList.remove('show-gacha');
});

// --- 3. 底部标签页切换逻辑 ---

gachaTabBar.addEventListener('click', (event) => {
    const targetTab = event.target.closest('.gacha-tab-item');
    if (!targetTab) return;

    const panelIdToShow = targetTab.dataset.panelId;
    const newTitle = targetTab.dataset.title;

    // 更新顶栏标题
    gachaTitle.textContent = newTitle;

    // 更新标签按钮的激活状态
    gachaTabBar.querySelectorAll('.gacha-tab-item').forEach(tab => {
        tab.classList.remove('active');
    });
    targetTab.classList.add('active');

    // 更新内容面板的显示状态
    gachaScreen.querySelectorAll('.gacha-content-panel').forEach(panel => {
        if (panel.id === panelIdToShow) {
            panel.classList.add('active');
        } else {
            panel.classList.remove('active');
        }
    });
});
// ▼▼▼ START: GACHA App 身份选择逻辑 ▼▼▼

// 1. 点击右上角头像，打开身份选择对话框
gachaAvatarButton.addEventListener('click', () => {
    // 我们直接调用七袋App已经写好的函数来打开选择框
    openShopperSelectModal(); 
});

// 2. 监听身份选择对话框的点击事件 (事件委托)
// 我们需要找到 #shopper-list-container，因为它在七袋App的JS里已经定义了
const gachaShopperListContainer = document.getElementById('shopper-list-container');

gachaShopperListContainer.addEventListener('click', async (event) => {
    // 检查是否正在GACHA App界面操作，避免与七袋App的功能冲突
    if (!gachaScreen.classList.contains('active')) return;

    const item = event.target.closest('.invite-contact-item');
    if (item) {
        const contactId = parseInt(item.dataset.contactId, 10);
        
        // 从数据库找到完整的联系人信息
        const contactsData = await dbHelper.loadData('messageContacts', 'allContacts');
        const selectedContact = contactsData.value.find(c => c.id === contactId);

        if (selectedContact) {
            // 关键一步：更新当前GACHA身份
            currentGachaIdentity = selectedContact; 
            
            // 更新右上角头像的显示
            gachaAvatarImg.src = selectedContact.user.avatar; // 默认使用用户的头像作为身份头像

            console.log(`GACHA 身份已切换为: ${currentGachaIdentity.user.name}`);
            
            // 关闭对话框
            closeShopperSelectModal();
        }
    }
});

// 3. 进入 GACHA App 时，自动设置一个默认身份
gachaAppIcon.addEventListener('click', async () => {
    phoneFrame.classList.add('show-gacha');
    
    // 如果还没有设置过身份，就自动加载第一个联系人作为默认身份
    if (!currentGachaIdentity) {
        const contactsData = await dbHelper.loadData('messageContacts', 'allContacts');
        if (contactsData && Array.isArray(contactsData.value) && contactsData.value.length > 0) {
            currentGachaIdentity = contactsData.value[0];
            gachaAvatarImg.src = currentGachaIdentity.user.avatar;
            console.log(`GACHA 默认身份已设置为: ${currentGachaIdentity.user.name}`);
        }
    }
    renderAllPosts();
});

// ▼▼▼ START: 统一的身份选择逻辑 (修正版) ▼▼▼

// 1. 获取身份选择列表的容器
const identityListContainer = document.getElementById('shopper-list-container');

// 2. 为该容器绑定唯一的点击事件监听器
identityListContainer.addEventListener('click', async (event) => {
    const item = event.target.closest('.invite-contact-item');
    if (!item) return; // 如果点击的不是列表项，则退出

    const contactId = parseInt(item.dataset.contactId, 10);
    const contactsData = await dbHelper.loadData('messageContacts', 'allContacts');
    const selectedContact = contactsData.value.find(c => c.id === contactId);

    if (selectedContact) {
        // 关键修正：检查 phoneFrame 的 class 来判断当前是哪个App
        if (phoneFrame.classList.contains('show-gacha')) {
            // 如果是 GACHA App，则更新 GACHA 的身份
            currentGachaIdentity = selectedContact;
            gachaAvatarImg.src = selectedContact.user.avatar;
            console.log(`GACHA 身份已切换为: ${currentGachaIdentity.user.name}`);

        } else if (phoneFrame.classList.contains('show-shop')) {
            // 如果是七袋 App，则更新七袋的身份 (调用它原来的函数)
            updateShopper(selectedContact);
        }

        // 无论哪个App，操作完成后都关闭对话框
        closeShopperSelectModal();
    }
});// ▼▼▼ START: GACHA App 发帖逻辑 ▼▼▼

function openSharePostModal() {
    postModal.style.display = 'flex';
    setTimeout(() => {
        postModal.style.opacity = '1';
        postModal.querySelector('.modal-content').style.transform = 'scale(1)';
    }, 10);
}

// 关闭对话框的函数保持不变 (如果您之前删除了，可以把这个也加回去)
function closePostModal() {
    postModal.style.opacity = '0';
    postModal.querySelector('.modal-content').style.transform = 'scale(0.95)';
    setTimeout(() => {
        postModal.style.display = 'none';
        postTextInput.value = '';
        postImageDescInput.value = '';
    }, 300);
}

// 确保关闭按钮仍然有效
postModalCloseBtn.addEventListener('click', closePostModal);
// 2. 为相关按钮绑定事件
newPostBtn.addEventListener('click', () => {
    // 1. 检查是否已选择身份
    if (!currentGachaIdentity) {
        alert('请先点击右上角头像选择一个发帖身份！');
        return;
    }

    // 2. 检查当前是哪个标签页处于激活状态
    const isShareTabActive = document.getElementById('gacha-tab-share').classList.contains('active');
    const isForumTabActive = document.getElementById('gacha-tab-forum').classList.contains('active');

    if (isShareTabActive) {
        // 如果是 SHARE 标签页，执行原来的打开分享对话框的逻辑
        openSharePostModal();
    } else if (isForumTabActive) {
        // 如果是 FORUM 标签页，执行新的逻辑
        // 目前我们先用一个提示来占位，您可以后续在这里实现打开论坛发帖窗口的功能
        alert('论坛发帖功能待实现！');
    }
});
postModalCloseBtn.addEventListener('click', closePostModal);

// 3. 核心：点击“确认分享”按钮的逻辑
confirmPostBtn.addEventListener('click', async () => {
    const postText = postTextInput.value.trim();
    const imageDesc = postImageDescInput.value.trim();

    if (!postText && !imageDesc) {
        alert('分享内容和图片描述不能都为空！');
        return;
    }

    // 创建一个帖子对象，包含所有需要的信息
    const newPost = {
        id: Date.now(), // 用时间戳作为唯一ID
        authorId: currentGachaIdentity.id, // 记录作者的ID
        authorName: currentGachaIdentity.user.name, // 使用当前身份的用户名
        authorAvatar: currentGachaIdentity.user.avatar, // 使用当前身份的头像
        timestamp: new Date().toISOString(),
        content: postText,
        imageDescription: imageDesc,
        likes: [], // 初始化一个空数组来存放点赞的人
        comments: [],
        visibleTo: [],
    };
    
    // 4. 保存帖子到数据库
    try {
        const postsData = await dbHelper.loadData('gachaPosts', 'allPosts');
        let allPosts = (postsData && Array.isArray(postsData.value)) ? postsData.value : [];
        allPosts.unshift(newPost); // unshift 将新帖子加到数组最前面
        await dbHelper.saveData('gachaPosts', 'allPosts', allPosts);

        // 5. 刷新帖子列表并关闭对话框
        renderAllPosts(); 
        closePostModal();

    } catch (error) {
        console.error("保存帖子失败:", error);
        alert("发布失败，请检查数据库设置。");
    }
});

// ▼▼▼ START: GACHA App 帖子渲染逻辑 ▼▼▼

/**
 * 主函数：从数据库加载所有帖子并渲染到页面上
 */
 async function renderAllPosts() {
    const postsData = await dbHelper.loadData('gachaPosts', 'allPosts');
    const allPosts = (postsData && Array.isArray(postsData.value)) ? postsData.value : [];
    postsContainer.innerHTML = '';
    if (allPosts.length === 0) {
        postsContainer.innerHTML = '<p style="text-align:center; color:#888; margin-top: 50px;">还没有任何分享，快来发布第一条吧！</p>';
        return;
    }
    allPosts.forEach(post => {
        const postElement = createPostElement(post);
        postsContainer.appendChild(postElement);
    });
}
/**
 * 辅助函数：根据单个帖子对象，创建并返回其对应的 HTML 元素
 * @param {object} post - 包含帖子信息的对象
 * @returns {HTMLElement} - 代表该帖子的 div 元素
 */
/**
 * 辅助函数：根据单个帖子对象，创建并返回其对应的 HTML 元素 (V2 - 最终版)
 * @param {object} post - 包含帖子信息的对象
 * @returns {HTMLElement} - 代表该帖子的 div 元素
 */
// 用这个【包含完整SVG】的新版本，替换掉你原来的 createPostElement 函数
function createPostElement(post) {
    const postCard = document.createElement('div');
    postCard.className = 'gp-card';
    postCard.dataset.postId = post.id;
    const postDate = new Date(post.timestamp);
    const timeString = `${postDate.getFullYear()}年${postDate.getMonth() + 1}月${postDate.getDate()}日 星期${['日', '一', '二', '三', '四', '五', '六'][postDate.getDay()]}`;
    const isLikedByCurrentUser = currentGachaIdentity ? post.likes.some(liker => liker.id === currentGachaIdentity.id) : false;
    const likedClass = isLikedByCurrentUser ? 'liked' : '';
    const postContentHTML = post.content.replace(/\n/g, '<br>');
    const imageDescHTML = post.imageDescription ? `<p class="gp-image-desc">[图片描述]: ${post.imageDescription}</p>` : '';
    const isPrivate = Array.isArray(post.visibleTo) && post.visibleTo.length > 0;
    postCard.innerHTML = `
        <div class="gp-header">
            <div class="gp-header-content">
                <div class="gp-user-info">
                    <div class="gp-avatar" style="background-image: url('${post.authorAvatar}');"></div>
                    <div>
                        <div class="gp-user-name">${post.authorName}</div>
                        <div class="gp-user-handle">个性签名</div>
                    </div>
                </div>
                <button class="gp-visibility-btn ${isPrivate ? 'private' : ''}" data-post-id="${post.id}">
                    <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg>
                </button>
                <div class="gp-post-date">${timeString}</div>
            </div>
        </div>
        <div class="gp-divider"></div>
        <div class="gp-post-content">
            <div class="gp-post-text"><p>${postContentHTML}</p>${imageDescHTML}</div>
            <div class="gp-action-buttons">
                <button class="gp-like-btn gp-action-button ${likedClass}"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M7.125 3.75C4.02246 3.75 1.5 6.30176 1.5 9.375C1.5 10.4473 1.98633 11.376 2.4375 12.0469C2.88867 12.7178 3.35156 13.1484 3.35156 13.1484L11.4609 21.2812L12 21.8203L12.5391 21.2812L20.6484 13.1484C20.6484 13.1484 22.5 11.5166 22.5 9.375C22.5 6.30176 19.9775 3.75 16.875 3.75C14.2998 3.75 12.6416 5.2998 12 5.95312C11.3584 5.2998 9.7002 3.75 7.125 3.75ZM7.125 5.25C9.36621 5.25 11.4375 7.42969 11.4375 7.42969L12 8.0625L12.5625 7.42969C12.5625 7.42969 14.6338 5.25 16.875 5.25C19.1572 5.25 21 7.12207 21 9.375C21 10.5322 19.5938 12.0938 19.5938 12.0938L12 19.6875L4.40625 12.0938C4.40625 12.0938 4.04297 11.7451 3.67969 11.2031C3.31641 10.6611 3 9.95508 3 9.375C3 7.12207 4.84277 5.25 7.125 5.25Z" fill="#808080" fill-opacity="0.55"/></svg></button>
                <button class="gp-comment-btn gp-action-button"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.25 4.5V19.5H9.43945L12 22.0605L14.5605 19.5H21.75V4.5H2.25ZM3.75 6H20.25V18H13.9395L12 19.9395L10.0605 18H3.75V6ZM6.75 8.25V9.75H17.25V8.25H6.75ZM6.75 11.25V12.75H17.25V11.25H6.75ZM6.75 14.25V15.75H14.25V14.25H6.75Z" fill="#808080" fill-opacity="0.55"/></svg></button>
                <button class="gp-favorite-btn gp-action-button"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 3.75L11.7656 3.96094L3.21094 12.6094L2.69531 13.125L3.21094 13.6641L10.3359 20.7891L10.875 21.3047L11.3906 20.7891L20.0391 12.2344L20.25 12V3.75H12ZM12.6328 5.25H18.75V11.3672L10.875 19.1953L4.80469 13.125L12.6328 5.25ZM16.5 6.75C16.0869 6.75 15.75 7.08691 15.75 7.5C15.75 7.91309 16.0869 8.25 16.5 8.25C16.9131 8.25 17.25 7.91309 17.25 7.5C17.25 7.08691 16.9131 6.75 16.5 6.75Z" fill="#808080" fill-opacity="0.55"/></svg></button>
                <button class="gp-summon-btn gp-action-button"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.25 4.5V10.5H6.47607L9 14.9312V20.25H15V14.25H10.3374L8.20312 10.5H8.25V8.25H15.75V10.5H21.75V4.5H15.75V6.75H8.25V4.5H2.25ZM3.75 6H6.75V9H3.75V6ZM17.25 6H20.25V9H17.25V6ZM10.8135 15.75H13.5V18.75H10.5V15.9287L10.8135 15.75Z" fill="#808080" fill-opacity="0.55"/></svg></button>
            </div>
        </div>
        <div class="gp-comment-section" style="display: none;">
            <div class="gp-comment-input-area"><div class="gp-comment-input-wrapper"><div class="gp-comment-avatar" style="background-image: url('${currentGachaIdentity ? currentGachaIdentity.user.avatar : ''}');"></div><input type="text" class="gp-comment-input" placeholder="写下你的评论..."></div></div>
            <div class="gp-comment-list"></div>
        </div>
    `;
    if (post.comments && post.comments.length > 0) {
        const commentList = postCard.querySelector('.gp-comment-list');
        post.comments.forEach(comment => {
            const commentElement = createCommentElement(comment);
            commentList.appendChild(commentElement);
        });
    }
    return postCard;
}
// ▼▼▼ START: GACHA App 帖子互动逻辑 ▼▼▼

// ▼▼▼ START: GACHA Post 统一点击事件监听器 (V10 最终修复版) ▼▼▼
// ▼▼▼ START: GACHA Post 统一点击事件监听器 (V12 最终修复版) ▼▼▼
postsContainer.addEventListener('click', async (event) => {
    const button = event.target.closest('button');
    if (!button) return;
    if (button.classList.contains('gp-like-btn')) {
        await toggleLike(parseInt(button.closest('.gp-card').dataset.postId));
        renderAllPosts();
    } else if (button.classList.contains('gp-comment-btn')) {
        const commentSection = button.closest('.gp-card').querySelector('.gp-comment-section');
        commentSection.style.display = (commentSection.style.display === 'none' || commentSection.style.display === '') ? 'block' : 'none';
    } else if (button.classList.contains('gp-reply-btn')) {
        showReplyInput(button);
    } else if (button.classList.contains('gp-visibility-btn')) {
        openVisibilityModal(parseInt(button.dataset.postId));
    } else if (button.classList.contains('gp-summon-btn')) {
        openSummonAiModal(parseInt(button.closest('.gp-card').dataset.postId));
    }
});

// ▲▲▲ END: GACHA Post 统一点击事件监听器 (V12 最终修复版) ▲▲▲


// ▲▲▲ END: GACHA Post 统一点击事件监听器 (V9 修复版) ▲▲▲
postsContainer.addEventListener('keydown', async (event) => {
    const input = event.target;
    if (event.key === 'Enter' && (input.classList.contains('gp-comment-input') || input.classList.contains('gp-reply-input'))) {
        event.preventDefault();
        const text = input.value.trim();
        if (!text || !currentGachaIdentity) return;
        const postCard = input.closest('.gp-card');
        const postId = parseInt(postCard.dataset.postId);
        const replyTo = input.classList.contains('gp-reply-input') ? input.dataset.replyTo : null;
        const newComment = await addUserComment(postId, text, replyTo);
        if (newComment) {
            const commentList = postCard.querySelector('.gp-comment-list');
            const newCommentElement = createCommentElement(newComment);
            commentList.appendChild(newCommentElement);
            input.value = '';
            commentList.scrollTop = commentList.scrollHeight;
            if (replyTo) {
                // Case A: 如果是回复 (replyTo有值)，触发被回复者
                await triggerAiCommentReply(postId, replyTo, text);
            } else {
                // Case B: 如果是新评论 (replyTo为null)，检查帖子作者是不是AI
                const authorName = postCard.querySelector('.gp-user-name').textContent;
                // 调用同一个触发函数，只不过目标是被评论的帖子作者
                await triggerAiCommentReply(postId, authorName, text);
            }
        }
    }
});


/**
 * 辅助函数：处理点赞/取消点赞
 * @param {number} postId - 被操作的帖子ID
 */
 async function toggleLike(postId) {
    if (!currentGachaIdentity) { alert('请先选择身份！'); return; }
    const postsData = await dbHelper.loadData('gachaPosts', 'allPosts');
    let allPosts = postsData.value;
    const post = allPosts.find(p => p.id === postId);
    if (post) {
        const likerIndex = post.likes.findIndex(liker => liker.id === currentGachaIdentity.id);
        if (likerIndex > -1) {
            post.likes.splice(likerIndex, 1);
        } else {
            post.likes.push({ id: currentGachaIdentity.id, name: currentGachaIdentity.user.name });
        }
        await dbHelper.saveData('gachaPosts', 'allPosts', allPosts);
    }
}
// ▼▼▼ START: addComment 和 likeCommentById 函数 (V11 AI身份修复版) ▼▼▼

/**
 * 添加评论函数
 * @param {number} postId - 帖子ID
 * @param {string} text - 评论内容
 * @param {string|null} replyTo - 回复的用户名
 * @param {object} authorContact - 【新增】发表评论的作者信息对象
 */
 async function addComment(postId, text, replyTo = null, authorContact = null) {
    const author = authorContact || currentGachaIdentity;
    if (!author) {
        console.error("无法确定评论作者身份！");
        return null;
    }
    const commentText = replyTo ? `@${replyTo} ${text}` : text;
    const newComment = {
        id: Date.now(),
        authorId: author.id,
        authorName: author.ai ? author.ai.name : author.user.name,
        authorAvatar: author.ai ? author.ai.avatar : author.user.avatar,
        text: commentText,
        timestamp: new Date().toISOString(),
        likes: [] // 新评论点赞数为空
    };
    const postsData = await dbHelper.loadData('gachaPosts', 'allPosts');
    let allPosts = postsData.value;
    const post = allPosts.find(p => p.id === postId);
    if (post) {
        if (!post.comments) post.comments = [];
        post.comments.push(newComment);
        await dbHelper.saveData('gachaPosts', 'allPosts', allPosts);
    }
    return newComment;
}





function showReplyInput(button) {
    const existingReplyInputs = document.querySelectorAll('.gp-reply-input-area');
    existingReplyInputs.forEach(input => input.remove());
    const commentItem = button.closest('.gp-comment-item');
    const username = commentItem.querySelector('.gp-comment-username').textContent;
    const commentContent = commentItem.querySelector('.gp-comment-content');
    const replyInputArea = document.createElement('div');
    replyInputArea.className = 'gp-reply-input-area';
    replyInputArea.innerHTML = `<div class="gp-comment-avatar" style="width: 24px; height: 24px; background-image: url('${currentGachaIdentity.user.avatar}');"></div><input type="text" class="gp-reply-input" placeholder="回复 ${username}..." data-reply-to="${username}">`;
    commentContent.appendChild(replyInputArea);
    const replyInput = replyInputArea.querySelector('.gp-reply-input');
    replyInput.focus();
    replyInput.addEventListener('blur', () => setTimeout(() => {
        if (!replyInput.matches(':focus')) replyInputArea.remove();
    }, 150));
}
function applyDarkMode(isEnabled) {
    phoneFrame.classList.toggle('dark-mode', isEnabled);
}

// --- 辅助函数 ---

/**
 * 【新增】辅助函数：根据单个评论对象，创建并返回其对应的 HTML 元素
 * @param {object} comment - 包含评论信息的对象
 * @returns {HTMLElement} - 代表该评论的 div 元素
 */
 // ▼▼▼ START: createCommentElement 函数 (V12 - 带点赞显示) ▼▼▼
/**
 * 【已更新】辅助函数：根据单个评论对象，创建并返回其对应的 HTML 元素
 * @param {object} comment - 包含评论信息的对象
 * @returns {HTMLElement} - 代表该评论的 div 元素
 */
 function createCommentElement(comment) {
    const commentElement = document.createElement('div');
    commentElement.className = 'gp-comment-item';
    const commentDate = new Date(comment.timestamp);
    const commentTimeString = `${commentDate.getMonth() + 1}-${commentDate.getDate()} ${commentDate.getHours()}:${String(commentDate.getMinutes()).padStart(2, '0')}`;
    const styledText = comment.text.replace(/(@\S+)/g, '<span class="gp-reply-mention">$1</span>');

    let likesHtml = '';
    if (comment.likes && comment.likes.length > 0) {
        const likerNames = comment.likes.map(liker => liker.name).join(', ');
        likesHtml = `
            <div class="gp-comment-likes">
                <svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>
                <span>${likerNames} 觉得很赞</span>
            </div>
        `;
    }

    commentElement.innerHTML = `
        <div class="gp-comment-avatar" style="background-image: url('${comment.authorAvatar}');"></div>
        <div class="gp-comment-content">
            <div class="gp-comment-header">
                <span class="gp-comment-username">${comment.authorName}</span>
                <span class="gp-comment-time">${commentTimeString}</span>
            </div>
            <div class="gp-comment-text">${styledText}</div>
            <div class="gp-comment-actions">
                <button class="gp-reply-btn">回复</button>
            </div>
            ${likesHtml}
        </div>
    `;
    return commentElement;
}
// ▲▲▲ END: createCommentElement 函数 (V12 - 带点赞显示) ▲▲▲


async function toggleLike(postId) {
    const postsData = await dbHelper.loadData('gachaPosts', 'allPosts');
    let allPosts = postsData.value;
    const post = allPosts.find(p => p.id === postId);

    if (post) {
        const likerIndex = post.likes.findIndex(liker => liker.id === currentGachaIdentity.id);
        if (likerIndex > -1) {
            post.likes.splice(likerIndex, 1);
        } else {
            post.likes.push({ id: currentGachaIdentity.id, name: currentGachaIdentity.user.name });
        }
        await dbHelper.saveData('gachaPosts', 'allPosts', allPosts);
    }
}
async function openVisibilityModal(postId) {
    currentPostIdForVisibility = postId;
    worldbookVisibilityList.innerHTML = '<p>正在加载世界书...</p>';
    
    try {
        // 从数据库加载帖子和世界书的数据
        const postsData = await dbHelper.loadData('gachaPosts', 'allPosts');
        const post = postsData.value.find(p => p.id === postId);
        const worldbooksData = await dbHelper.loadData('worldBooks', 'allWorldBooks');
        const allWorldbooks = (worldbooksData && Array.isArray(worldbooksData.value)) ? worldbooksData.value : [];
        
        if (!post) throw new Error("找不到帖子");

        const selectedIds = new Set(post.visibleTo || []);
        worldbookVisibilityList.innerHTML = '';

        if (allWorldbooks.length === 0) {
            worldbookVisibilityList.innerHTML = '<p style="color: #888;">暂无世界书可选</p>';
        } else {
            // 为每个世界书创建一个带复选框的列表项
            allWorldbooks.forEach(book => {
                const isChecked = selectedIds.has(book.id);
                const item = document.createElement('div');
                item.className = 'visibility-item';
                item.innerHTML = `
                    <input type="checkbox" id="wb-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}>
                    <label for="wb-${book.id}">${book.name}</label>
                `;
                worldbookVisibilityList.appendChild(item);
            });
        }
        
        // 显示Modal
        visibilityModal.style.display = 'flex';
        setTimeout(() => { visibilityModal.style.opacity = '1'; }, 10);

    } catch (error) {
        console.error("打开可见性设置失败:", error);
        alert("加载失败，请重试。");
    }
}

// 3. 关闭对话框的函数
function closeVisibilityModal() {
    visibilityModal.style.opacity = '0';
    setTimeout(() => {
        visibilityModal.style.display = 'none';
        currentPostIdForVisibility = null;
    }, 300);
}

// 4. 为“保存”按钮绑定点击事件
saveVisibilityBtn.addEventListener('click', async () => {
    if (!currentPostIdForVisibility) return;

    // 收集所有被选中的世界书ID
    const selectedIds = [];
    worldbookVisibilityList.querySelectorAll('input[type="checkbox"]:checked').forEach(checkbox => {
        selectedIds.push(parseInt(checkbox.value));
    });

    try {
        const postsData = await dbHelper.loadData('gachaPosts', 'allPosts');
        let allPosts = postsData.value;
        const postIndex = allPosts.findIndex(p => p.id === currentPostIdForVisibility);

        if (postIndex > -1) {
            allPosts[postIndex].visibleTo = selectedIds; // 更新可见范围
            await dbHelper.saveData('gachaPosts', 'allPosts', allPosts); // 保存回数据库
            
            closeVisibilityModal();
            renderAllPosts(); // 刷新帖子列表以更新图标状态
            alert('可见范围已更新！');
        } else {
            throw new Error("保存时找不到帖子");
        }
    } catch (error) {
        console.error("保存可见范围失败:", error);
        alert("保存失败，请重试。");
    }
});

// 5. 绑定关闭事件
visibilityModalCloseBtn.addEventListener('click', closeVisibilityModal);


/**
 * AI点赞评论的辅助函数
 * @param {number} postId - 帖子ID
 * @param {number} commentId - 评论ID
 * @param {number} likerId - 【新增】点赞者的ID
 */
 async function likeCommentById(postId, commentId, likerId) {
    if (!likerId) { console.error("点赞失败：未提供点赞者ID。"); return; }
    const postsData = await dbHelper.loadData('gachaPosts', 'allPosts');
    let allPosts = postsData.value;
    const post = allPosts.find(p => p.id === postId);
    if (!post) return;
    const comment = post.comments.find(c => c.id === commentId);
    if (!comment) return;
    const likerIdentity = await getContactById(likerId);
    if (!likerIdentity) return;
    if (!Array.isArray(comment.likes)) { comment.likes = []; }
    const likerIndex = comment.likes.findIndex(liker => liker.id === likerIdentity.id);
    if (likerIndex === -1) {
        comment.likes.push({ id: likerIdentity.id, name: likerIdentity.ai.name });
        await dbHelper.saveData('gachaPosts', 'allPosts', allPosts);
    }
}

// ▼▼▼ START: 【新增】根据ID获取联系人的辅助函数 ▼▼▼

/**
 * 根据联系人ID从数据库中获取完整的联系人对象
 * @param {number} contactId - 要查找的联系人ID
 * @returns {Promise<object|null>} - 返回找到的联系人对象，如果找不到则返回null
 */
 async function getContactById(contactId) {
    try {
        const contactsData = await dbHelper.loadData('messageContacts', 'allContacts');
        if (contactsData && Array.isArray(contactsData.value)) {
            return contactsData.value.find(c => c.id === contactId);
        }
        return null;
    } catch (error) {
        console.error("通过ID获取联系人失败:", error);
        return null;
    }
}
// --- 2. 打开和关闭“选择召唤AI”对话框的函数 ---
function openSummonAiModal(postId) {
    currentPostIdForSummoning = postId;
    summonAiListContainer.innerHTML = '<p style="padding: 20px; text-align: center; color: #888;">正在加载AI角色列表...</p>';
    dbHelper.loadData('messageContacts', 'allContacts').then(contactsData => {
        if (contactsData && Array.isArray(contactsData.value) && contactsData.value.length > 0) {
            summonAiListContainer.innerHTML = '';
            contactsData.value.forEach(contact => {
                const item = document.createElement('div');
                item.className = 'invite-contact-item';
                item.style.cursor = 'pointer';
                item.dataset.contactId = contact.id;
                item.innerHTML = `<img src="${contact.ai.avatar}" alt="avatar" class="invite-contact-avatar"><span class="invite-contact-name">${contact.ai.name}</span>`;
                summonAiListContainer.appendChild(item);
            });
        } else { /* ... */ }
    });
    summonAiModal.style.display = 'flex';
    setTimeout(() => { summonAiModal.style.opacity = '1'; }, 10);
}


function closeSummonAiModal() {
    summonAiModal.style.opacity = '0';
    setTimeout(() => {
        summonAiModal.style.display = 'none';
        currentPostIdForSummoning = null;
    }, 300);
}
// --- 3. 核心执行函数：当用户选择了要召唤的AI后，触发此函数 ---
async function executeSummon(postId, contactToSummonId) {
    try {
        const postData = await dbHelper.loadData('gachaPosts', 'allPosts');
        const post = postData.value.find(p => p.id === postId);
        if (!post) throw new Error("找不到帖子。");

        const contactToSummon = await getContactById(contactToSummonId);
        if (!contactToSummon) {
            throw new Error("无法加载被召唤的AI角色信息，操作已取消。");
        }
        
        alert(`${contactToSummon.ai.name} 已被召唤，正在查看动态...`);

        let context = `[动态发布者]:\n${post.authorName}\n\n[动态内容]:\n${post.content || '(无文字内容)'}\n`;
        if (post.imageDescription) { context += `[图片描述]: ${post.imageDescription}\n`; }
        context += "\n[当前评论区]:\n";
        if (post.comments && post.comments.length > 0) {
            post.comments.forEach(comment => {
                const likerNames = (comment.likes || []).map(l => l.name).join(', ');
                context += `- (评论ID: ${comment.id}) ${comment.authorName} 说: "${comment.text}" ${likerNames ? `(已被 ${likerNames} 点赞)` : ''}\n`;
            });
        } else { context += "(暂无评论)\n"; }
        
        const triggerMessage = `(系统指令：你被用户召唤去查看一条好友动态。发布者是'${post.authorName}'。\n你的任务是：\n1. 仔细阅读下面的动态内容和所有评论。\n2. 根据你的角色性格，【必须】从以下操作中选择至少一项来执行：\n   - 调用 "likeComment" 工具，为你欣赏的一条或多条评论点赞。\n   - 调用 "addCommentToPost" 工具，发表一条你自己的评论来参与互动。\n   - 同时使用以上两种工具。\n这是一个强制要求，请务必做出互动。)\n\n${context}`;

        // 【核心修改】在这里，我们将正确的postId作为第三个参数传递给callAI
        await callAI(triggerMessage, contactToSummon, { postId: post.id });
        
        alert(`${contactToSummon.ai.name} 已完成互动！`);

    } catch (error) {
        console.error("执行召唤失败:", error);
        alert(`操作失败: ${error.message}`);
    }
}
// ▼▼▼ START: 【已更新】触发AI回复评论的函数 (V17 - 传递回复目标) ▼▼▼

/**
 * 当用户回复了AI的评论时，触发被回复的AI进行再次回复。
 * @param {number} postId - 当前操作的帖子ID
 * @param {string} repliedToUsername - 被回复的AI的用户名
 * @param {string} userReplyText - 用户发送的回复内容
 */
 async function triggerAiCommentReply(postId, repliedToUsername, userReplyText) {
    console.log(`尝试触发 ${repliedToUsername} 来回复...`);

    try {
        const contactsData = await dbHelper.loadData('messageContacts', 'allContacts');
        if (!contactsData || !Array.isArray(contactsData.value)) return;

        const aiContact = contactsData.value.find(c => c.ai.name === repliedToUsername);

        if (!aiContact) {
            console.log(`${repliedToUsername} 不是一个可触发的AI角色。`);
            return;
        }

        const replierName = currentGachaIdentity.user.name;

        const triggerMessage = `(系统指令：'${replierName}' 刚刚在一条动态下回复了你的评论。
        这是TA的回复内容： “${userReplyText}”
        请根据你的角色性格和聊天记录以及帖子内容，针对TA的回复，使用 "addCommentToPost" 工具在同一个帖子下（帖子ID: ${postId}）发表一条新的公开回复。)`;
        
        console.log(`准备向 ${aiContact.ai.name} 发送指令:`, triggerMessage);

        // --- 【核心修改】在这里，我们将您的名字作为 replyToUsername 传递过去 ---
        await callAI(triggerMessage, aiContact, { 
            postId: postId,
            replyToUsername: replierName // 新增：告诉AI它应该@谁
        });

    } catch (error) {
        console.error("触发AI回复失败:", error);
    }
}

// ▲▲▲ END: 【已更新】触发AI回复评论的函数 (V17 - 传递回复目标) ▲▲▲
// --- 4. 为新对话框绑定事件 ---
summonAiModalCloseBtn.addEventListener('click', closeSummonAiModal);
summonAiListContainer.addEventListener('click', (event) => {
    const item = event.target.closest('.invite-contact-item');
    if (item) {
        const contactId = parseInt(item.dataset.contactId);
        if (currentPostIdForSummoning && contactId) {
            closeSummonAiModal();
            executeSummon(currentPostIdForSummoning, contactId);
        }
    }
});

function applyDarkMode(isEnabled) {
    phoneFrame.classList.toggle('dark-mode', isEnabled);
}
// ▼▼▼ START: 【新增】专用于用户发表评论的函数 (V15 修复) ▼▼▼

/**
 * 专用于用户（通过输入框）发表新评论或回复。
 * 这个函数只使用全局的 currentGachaIdentity 作为作者身份。
 * @param {number} postId - 帖子ID
 * @param {string} text - 评论内容
 * @param {string|null} replyTo - 回复的用户名
 * @returns {Promise<object|null>} - 返回新创建的评论对象
 */
 async function addUserComment(postId, text, replyTo = null) {
    // 1. 检查用户是否已选择身份
    if (!currentGachaIdentity) {
        alert("请先选择一个身份再发表评论！");
        return null;
    }

    const author = currentGachaIdentity; // 直接使用当前用户身份
    const commentText = replyTo ? `@${replyTo} ${text}` : text;

    const newComment = {
        id: Date.now(),
        authorId: author.id,
        authorName: author.user.name, // 直接从 user 对象获取
        authorAvatar: author.user.avatar, // 直接从 user 对象获取
        text: commentText,
        timestamp: new Date().toISOString(),
        likes: []
    };

    // 2. 将新评论保存到数据库
    try {
        const postsData = await dbHelper.loadData('gachaPosts', 'allPosts');
        let allPosts = postsData.value || [];
        const post = allPosts.find(p => p.id === postId);
        if (post) {
            if (!post.comments) post.comments = [];
            post.comments.push(newComment);
            await dbHelper.saveData('gachaPosts', 'allPosts', allPosts);
            return newComment;
        } else {
            throw new Error(`找不到ID为 ${postId} 的帖子`);
        }
    } catch (error) {
        console.error("用户发表评论失败:", error);
        return null;
    }
}

// ▲▲▲ END: 【新增】专用于用户发表评论的函数 (V15 修复) ▲▲▲

// ▼▼▼ START: 【新增】执行AI发帖的函数 (V17) ▼▼▼

/**
 * 由AI调用，创建一个新的朋友圈帖子并保存到数据库。
 * @param {object} aiContact - 发帖的AI角色对象
 * @param {string} postText - 帖子正文
 * @param {string|null} imageDescription - (可选) 图片描述
 */
 async function createAiPost(aiContact, postText, imageDescription = null) {
    if (!aiContact || !postText) {
        console.error("AI创建帖子失败：缺少作者信息或正文。");
        return;
    }

    // 1. 构建帖子对象，作者信息来自AI
    const newPost = {
        id: Date.now(),
        authorId: aiContact.id,
        authorName: aiContact.ai.name,
        authorAvatar: aiContact.ai.avatar,
        timestamp: new Date().toISOString(),
        content: postText,
        imageDescription: imageDescription,
        likes: [],
        comments: [],
        visibleTo: [],
    };

    // 2. 保存到数据库
    try {
        const postsData = await dbHelper.loadData('gachaPosts', 'allPosts');
        let allPosts = (postsData && Array.isArray(postsData.value)) ? postsData.value : [];
        allPosts.unshift(newPost); // unshift 将新帖子加到数组最前面
        await dbHelper.saveData('gachaPosts', 'allPosts', allPosts);
        
        console.log(`${aiContact.ai.name} 成功发布了一条朋友圈！`);

    } catch (error) {
        console.error("AI保存帖子失败:", error);
    }
}

// ▼▼▼ START: 【新增】触发AI发朋友圈的函数 (V17) ▼▼▼

/**
 * 当对话满足条件时，触发AI根据最近聊天记录发朋友圈。
 * @param {object} contact - 要发朋友圈的AI角色对象
 */
 async function triggerAiSocialPost(contact) {
    console.log(`达到消息阈值，正在触发 ${contact.ai.name} 发朋友圈...`);
    try {
        const history = contact.history || [];
        const recentHistory = history.slice(-5); 
        
        let context = "[最近的50条聊天记录]:\n";
        recentHistory.forEach(msg => {
            const senderName = msg.sender === 'user' ? contact.user.name : contact.ai.name;
            context += `- ${senderName}: "${msg.text}"\n`;
        });

        // --- 【核心修改】使用更强力、更明确的提示词 ---
        const triggerMessage = `(系统指令：你和 '${contact.user.name}' 的对话非常愉快。
        你的任务是：
        1.  阅读并理解以上最近的聊天记录。
        2.  根据聊天内容，提炼一个有趣或有感触的瞬间。
        3.  【必须】调用 "createSocialPost" 工具，发布一条关于这个瞬间的朋友圈动态。动态内容要符合你的人设。
        这是一个强制要求，你必须发布动态。)\n\n${context}`;

        // 调用AI，让它自己决策发什么内容
        await callAI(triggerMessage, contact);
        
    } catch (error) {
        console.error("触发AI发朋友圈失败:", error);
    }
}

// ▼▼▼ START: 【新增】彩票开奖核心逻辑函数 ▼▼▼

/**
 * 根据带权重的概率计算彩票奖金。
 * @returns {number} - 返回一个在5到2000之间的随机奖金金额
 */
 function calculateLotteryPrize() {
    const rand = Math.random(); // 生成一个 0 到 1 之间的随机数

    let prize;

    if (rand < 0.8) { 
        // 80% 的概率中 5 - 500 元
        prize = Math.floor(Math.random() * (500 - 5 + 1)) + 5;
    } else if (rand < 0.95) { 
        // 15% 的概率中 501 - 1000 元
        prize = Math.floor(Math.random() * (1000 - 501 + 1)) + 501;
    } else if (rand < 0.99) { 
        // 4% 的概率中 1001 - 1500 元
        prize = Math.floor(Math.random() * (1500 - 1001 + 1)) + 1001;
    } else { 
        // 1% 的概率中 1501 - 2000 元
        prize = Math.floor(Math.random() * (2000 - 1501 + 1)) + 1501;
    }
    
    return prize;
}

lotteryModal.addEventListener('click', async (event) => {
    // 【新增】处理关闭事件
    if (event.target.classList.contains('modal-close-button') || event.target === lotteryModal) {
        closeGameModals();
        return;
    }

    const choiceBtn = event.target.closest('.game-choice-btn');
    if (!choiceBtn) return;

    const cost = parseInt(choiceBtn.dataset.cost, 10);
    const currentBalance = await getBalance();

    if (currentBalance < cost) {
        alert(`余额不足！您需要 ¥${cost.toFixed(2)}，但当前只有 ¥${currentBalance.toFixed(2)}。`);
        return;
    }

    await logTransactionAndUpdateBalance({
        description: `购买 ${cost} 元彩票`,
        amount: -cost
    });

    const prize = calculateLotteryPrize();

    await logTransactionAndUpdateBalance({
        description: '彩票中奖',
        amount: prize
    });

    closeGameModals();
    setTimeout(() => {
        alert(`恭喜你！\n\n花费 ¥${cost.toFixed(2)}，喜中 ¥${prize.toFixed(2)} 元大奖！`);
    }, 310);
});

    </script>

</body>

</html>
